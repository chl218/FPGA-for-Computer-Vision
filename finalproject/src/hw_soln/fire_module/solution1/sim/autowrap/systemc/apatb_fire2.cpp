// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2015.4
// Copyright (C) 2015 Xilinx Inc. All rights reserved.
// ==============================================================

#include <systemc>
#include <iostream>
#include <cstdlib>
#include <cstddef>
#include <stdint.h>
#include "SysCFileHandler.h"
#include "ap_int.h"
#include "ap_fixed.h"
#include <complex>
#include <stdbool.h>
#include "autopilot_cbe.h"
#include "ap_stream.h"
#include "hls_stream.h"
#include "hls_half.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


// [dump_struct_tree [build_nameSpaceTree] dumpedStructList] ---------->


// [dump_enumeration [get_enumeration_list]] ---------->


// wrapc file define: "matrix_i_0_V"
#define AUTOTB_TVIN_matrix_i_0_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_0_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_0_V  "../tv/stream_size/stream_size_in_matrix_i_0_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V  "../tv/stream_size/stream_ingress_status_matrix_i_0_V.dat"
// wrapc file define: "matrix_i_1_V"
#define AUTOTB_TVIN_matrix_i_1_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_1_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_1_V  "../tv/stream_size/stream_size_in_matrix_i_1_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V  "../tv/stream_size/stream_ingress_status_matrix_i_1_V.dat"
// wrapc file define: "matrix_i_2_V"
#define AUTOTB_TVIN_matrix_i_2_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_2_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_2_V  "../tv/stream_size/stream_size_in_matrix_i_2_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V  "../tv/stream_size/stream_ingress_status_matrix_i_2_V.dat"
// wrapc file define: "matrix_i_3_V"
#define AUTOTB_TVIN_matrix_i_3_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_3_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_3_V  "../tv/stream_size/stream_size_in_matrix_i_3_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V  "../tv/stream_size/stream_ingress_status_matrix_i_3_V.dat"
// wrapc file define: "matrix_i_4_V"
#define AUTOTB_TVIN_matrix_i_4_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_4_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_4_V  "../tv/stream_size/stream_size_in_matrix_i_4_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V  "../tv/stream_size/stream_ingress_status_matrix_i_4_V.dat"
// wrapc file define: "matrix_i_5_V"
#define AUTOTB_TVIN_matrix_i_5_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_5_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_5_V  "../tv/stream_size/stream_size_in_matrix_i_5_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V  "../tv/stream_size/stream_ingress_status_matrix_i_5_V.dat"
// wrapc file define: "matrix_i_6_V"
#define AUTOTB_TVIN_matrix_i_6_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_6_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_6_V  "../tv/stream_size/stream_size_in_matrix_i_6_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V  "../tv/stream_size/stream_ingress_status_matrix_i_6_V.dat"
// wrapc file define: "matrix_i_7_V"
#define AUTOTB_TVIN_matrix_i_7_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_7_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_7_V  "../tv/stream_size/stream_size_in_matrix_i_7_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V  "../tv/stream_size/stream_ingress_status_matrix_i_7_V.dat"
// wrapc file define: "matrix_i_8_V"
#define AUTOTB_TVIN_matrix_i_8_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_8_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_8_V  "../tv/stream_size/stream_size_in_matrix_i_8_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V  "../tv/stream_size/stream_ingress_status_matrix_i_8_V.dat"
// wrapc file define: "matrix_i_9_V"
#define AUTOTB_TVIN_matrix_i_9_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_9_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_9_V  "../tv/stream_size/stream_size_in_matrix_i_9_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V  "../tv/stream_size/stream_ingress_status_matrix_i_9_V.dat"
// wrapc file define: "matrix_i_10_V"
#define AUTOTB_TVIN_matrix_i_10_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_10_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_10_V  "../tv/stream_size/stream_size_in_matrix_i_10_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V  "../tv/stream_size/stream_ingress_status_matrix_i_10_V.dat"
// wrapc file define: "matrix_i_11_V"
#define AUTOTB_TVIN_matrix_i_11_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_11_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_11_V  "../tv/stream_size/stream_size_in_matrix_i_11_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V  "../tv/stream_size/stream_ingress_status_matrix_i_11_V.dat"
// wrapc file define: "matrix_i_12_V"
#define AUTOTB_TVIN_matrix_i_12_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_12_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_12_V  "../tv/stream_size/stream_size_in_matrix_i_12_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V  "../tv/stream_size/stream_ingress_status_matrix_i_12_V.dat"
// wrapc file define: "matrix_i_13_V"
#define AUTOTB_TVIN_matrix_i_13_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_13_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_13_V  "../tv/stream_size/stream_size_in_matrix_i_13_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V  "../tv/stream_size/stream_ingress_status_matrix_i_13_V.dat"
// wrapc file define: "matrix_i_14_V"
#define AUTOTB_TVIN_matrix_i_14_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_14_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_14_V  "../tv/stream_size/stream_size_in_matrix_i_14_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V  "../tv/stream_size/stream_ingress_status_matrix_i_14_V.dat"
// wrapc file define: "matrix_i_15_V"
#define AUTOTB_TVIN_matrix_i_15_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_15_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_15_V  "../tv/stream_size/stream_size_in_matrix_i_15_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V  "../tv/stream_size/stream_ingress_status_matrix_i_15_V.dat"
// wrapc file define: "matrix_i_16_V"
#define AUTOTB_TVIN_matrix_i_16_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_16_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_16_V  "../tv/stream_size/stream_size_in_matrix_i_16_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V  "../tv/stream_size/stream_ingress_status_matrix_i_16_V.dat"
// wrapc file define: "matrix_i_17_V"
#define AUTOTB_TVIN_matrix_i_17_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_17_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_17_V  "../tv/stream_size/stream_size_in_matrix_i_17_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V  "../tv/stream_size/stream_ingress_status_matrix_i_17_V.dat"
// wrapc file define: "matrix_i_18_V"
#define AUTOTB_TVIN_matrix_i_18_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_18_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_18_V  "../tv/stream_size/stream_size_in_matrix_i_18_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V  "../tv/stream_size/stream_ingress_status_matrix_i_18_V.dat"
// wrapc file define: "matrix_i_19_V"
#define AUTOTB_TVIN_matrix_i_19_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_19_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_19_V  "../tv/stream_size/stream_size_in_matrix_i_19_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V  "../tv/stream_size/stream_ingress_status_matrix_i_19_V.dat"
// wrapc file define: "matrix_i_20_V"
#define AUTOTB_TVIN_matrix_i_20_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_20_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_20_V  "../tv/stream_size/stream_size_in_matrix_i_20_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V  "../tv/stream_size/stream_ingress_status_matrix_i_20_V.dat"
// wrapc file define: "matrix_i_21_V"
#define AUTOTB_TVIN_matrix_i_21_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_21_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_21_V  "../tv/stream_size/stream_size_in_matrix_i_21_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V  "../tv/stream_size/stream_ingress_status_matrix_i_21_V.dat"
// wrapc file define: "matrix_i_22_V"
#define AUTOTB_TVIN_matrix_i_22_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_22_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_22_V  "../tv/stream_size/stream_size_in_matrix_i_22_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V  "../tv/stream_size/stream_ingress_status_matrix_i_22_V.dat"
// wrapc file define: "matrix_i_23_V"
#define AUTOTB_TVIN_matrix_i_23_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_23_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_23_V  "../tv/stream_size/stream_size_in_matrix_i_23_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V  "../tv/stream_size/stream_ingress_status_matrix_i_23_V.dat"
// wrapc file define: "matrix_i_24_V"
#define AUTOTB_TVIN_matrix_i_24_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_24_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_24_V  "../tv/stream_size/stream_size_in_matrix_i_24_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V  "../tv/stream_size/stream_ingress_status_matrix_i_24_V.dat"
// wrapc file define: "matrix_i_25_V"
#define AUTOTB_TVIN_matrix_i_25_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_25_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_25_V  "../tv/stream_size/stream_size_in_matrix_i_25_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V  "../tv/stream_size/stream_ingress_status_matrix_i_25_V.dat"
// wrapc file define: "matrix_i_26_V"
#define AUTOTB_TVIN_matrix_i_26_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_26_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_26_V  "../tv/stream_size/stream_size_in_matrix_i_26_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V  "../tv/stream_size/stream_ingress_status_matrix_i_26_V.dat"
// wrapc file define: "matrix_i_27_V"
#define AUTOTB_TVIN_matrix_i_27_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_27_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_27_V  "../tv/stream_size/stream_size_in_matrix_i_27_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V  "../tv/stream_size/stream_ingress_status_matrix_i_27_V.dat"
// wrapc file define: "matrix_i_28_V"
#define AUTOTB_TVIN_matrix_i_28_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_28_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_28_V  "../tv/stream_size/stream_size_in_matrix_i_28_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V  "../tv/stream_size/stream_ingress_status_matrix_i_28_V.dat"
// wrapc file define: "matrix_i_29_V"
#define AUTOTB_TVIN_matrix_i_29_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_29_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_29_V  "../tv/stream_size/stream_size_in_matrix_i_29_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V  "../tv/stream_size/stream_ingress_status_matrix_i_29_V.dat"
// wrapc file define: "matrix_i_30_V"
#define AUTOTB_TVIN_matrix_i_30_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_30_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_30_V  "../tv/stream_size/stream_size_in_matrix_i_30_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V  "../tv/stream_size/stream_ingress_status_matrix_i_30_V.dat"
// wrapc file define: "matrix_i_31_V"
#define AUTOTB_TVIN_matrix_i_31_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_31_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_31_V  "../tv/stream_size/stream_size_in_matrix_i_31_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V  "../tv/stream_size/stream_ingress_status_matrix_i_31_V.dat"
// wrapc file define: "matrix_i_32_V"
#define AUTOTB_TVIN_matrix_i_32_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_32_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_32_V  "../tv/stream_size/stream_size_in_matrix_i_32_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V  "../tv/stream_size/stream_ingress_status_matrix_i_32_V.dat"
// wrapc file define: "matrix_i_33_V"
#define AUTOTB_TVIN_matrix_i_33_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_33_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_33_V  "../tv/stream_size/stream_size_in_matrix_i_33_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V  "../tv/stream_size/stream_ingress_status_matrix_i_33_V.dat"
// wrapc file define: "matrix_i_34_V"
#define AUTOTB_TVIN_matrix_i_34_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_34_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_34_V  "../tv/stream_size/stream_size_in_matrix_i_34_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V  "../tv/stream_size/stream_ingress_status_matrix_i_34_V.dat"
// wrapc file define: "matrix_i_35_V"
#define AUTOTB_TVIN_matrix_i_35_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_35_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_35_V  "../tv/stream_size/stream_size_in_matrix_i_35_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V  "../tv/stream_size/stream_ingress_status_matrix_i_35_V.dat"
// wrapc file define: "matrix_i_36_V"
#define AUTOTB_TVIN_matrix_i_36_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_36_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_36_V  "../tv/stream_size/stream_size_in_matrix_i_36_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V  "../tv/stream_size/stream_ingress_status_matrix_i_36_V.dat"
// wrapc file define: "matrix_i_37_V"
#define AUTOTB_TVIN_matrix_i_37_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_37_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_37_V  "../tv/stream_size/stream_size_in_matrix_i_37_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V  "../tv/stream_size/stream_ingress_status_matrix_i_37_V.dat"
// wrapc file define: "matrix_i_38_V"
#define AUTOTB_TVIN_matrix_i_38_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_38_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_38_V  "../tv/stream_size/stream_size_in_matrix_i_38_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V  "../tv/stream_size/stream_ingress_status_matrix_i_38_V.dat"
// wrapc file define: "matrix_i_39_V"
#define AUTOTB_TVIN_matrix_i_39_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_39_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_39_V  "../tv/stream_size/stream_size_in_matrix_i_39_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V  "../tv/stream_size/stream_ingress_status_matrix_i_39_V.dat"
// wrapc file define: "matrix_i_40_V"
#define AUTOTB_TVIN_matrix_i_40_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_40_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_40_V  "../tv/stream_size/stream_size_in_matrix_i_40_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V  "../tv/stream_size/stream_ingress_status_matrix_i_40_V.dat"
// wrapc file define: "matrix_i_41_V"
#define AUTOTB_TVIN_matrix_i_41_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_41_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_41_V  "../tv/stream_size/stream_size_in_matrix_i_41_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V  "../tv/stream_size/stream_ingress_status_matrix_i_41_V.dat"
// wrapc file define: "matrix_i_42_V"
#define AUTOTB_TVIN_matrix_i_42_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_42_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_42_V  "../tv/stream_size/stream_size_in_matrix_i_42_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V  "../tv/stream_size/stream_ingress_status_matrix_i_42_V.dat"
// wrapc file define: "matrix_i_43_V"
#define AUTOTB_TVIN_matrix_i_43_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_43_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_43_V  "../tv/stream_size/stream_size_in_matrix_i_43_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V  "../tv/stream_size/stream_ingress_status_matrix_i_43_V.dat"
// wrapc file define: "matrix_i_44_V"
#define AUTOTB_TVIN_matrix_i_44_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_44_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_44_V  "../tv/stream_size/stream_size_in_matrix_i_44_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V  "../tv/stream_size/stream_ingress_status_matrix_i_44_V.dat"
// wrapc file define: "matrix_i_45_V"
#define AUTOTB_TVIN_matrix_i_45_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_45_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_45_V  "../tv/stream_size/stream_size_in_matrix_i_45_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V  "../tv/stream_size/stream_ingress_status_matrix_i_45_V.dat"
// wrapc file define: "matrix_i_46_V"
#define AUTOTB_TVIN_matrix_i_46_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_46_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_46_V  "../tv/stream_size/stream_size_in_matrix_i_46_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V  "../tv/stream_size/stream_ingress_status_matrix_i_46_V.dat"
// wrapc file define: "matrix_i_47_V"
#define AUTOTB_TVIN_matrix_i_47_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_47_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_47_V  "../tv/stream_size/stream_size_in_matrix_i_47_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V  "../tv/stream_size/stream_ingress_status_matrix_i_47_V.dat"
// wrapc file define: "matrix_i_48_V"
#define AUTOTB_TVIN_matrix_i_48_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_48_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_48_V  "../tv/stream_size/stream_size_in_matrix_i_48_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V  "../tv/stream_size/stream_ingress_status_matrix_i_48_V.dat"
// wrapc file define: "matrix_i_49_V"
#define AUTOTB_TVIN_matrix_i_49_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_49_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_49_V  "../tv/stream_size/stream_size_in_matrix_i_49_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V  "../tv/stream_size/stream_ingress_status_matrix_i_49_V.dat"
// wrapc file define: "matrix_i_50_V"
#define AUTOTB_TVIN_matrix_i_50_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_50_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_50_V  "../tv/stream_size/stream_size_in_matrix_i_50_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V  "../tv/stream_size/stream_ingress_status_matrix_i_50_V.dat"
// wrapc file define: "matrix_i_51_V"
#define AUTOTB_TVIN_matrix_i_51_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_51_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_51_V  "../tv/stream_size/stream_size_in_matrix_i_51_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V  "../tv/stream_size/stream_ingress_status_matrix_i_51_V.dat"
// wrapc file define: "matrix_i_52_V"
#define AUTOTB_TVIN_matrix_i_52_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_52_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_52_V  "../tv/stream_size/stream_size_in_matrix_i_52_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V  "../tv/stream_size/stream_ingress_status_matrix_i_52_V.dat"
// wrapc file define: "matrix_i_53_V"
#define AUTOTB_TVIN_matrix_i_53_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_53_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_53_V  "../tv/stream_size/stream_size_in_matrix_i_53_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V  "../tv/stream_size/stream_ingress_status_matrix_i_53_V.dat"
// wrapc file define: "matrix_i_54_V"
#define AUTOTB_TVIN_matrix_i_54_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_54_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_54_V  "../tv/stream_size/stream_size_in_matrix_i_54_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V  "../tv/stream_size/stream_ingress_status_matrix_i_54_V.dat"
// wrapc file define: "matrix_i_55_V"
#define AUTOTB_TVIN_matrix_i_55_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_55_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_55_V  "../tv/stream_size/stream_size_in_matrix_i_55_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V  "../tv/stream_size/stream_ingress_status_matrix_i_55_V.dat"
// wrapc file define: "matrix_i_56_V"
#define AUTOTB_TVIN_matrix_i_56_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_56_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_56_V  "../tv/stream_size/stream_size_in_matrix_i_56_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V  "../tv/stream_size/stream_ingress_status_matrix_i_56_V.dat"
// wrapc file define: "matrix_i_57_V"
#define AUTOTB_TVIN_matrix_i_57_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_57_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_57_V  "../tv/stream_size/stream_size_in_matrix_i_57_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V  "../tv/stream_size/stream_ingress_status_matrix_i_57_V.dat"
// wrapc file define: "matrix_i_58_V"
#define AUTOTB_TVIN_matrix_i_58_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_58_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_58_V  "../tv/stream_size/stream_size_in_matrix_i_58_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V  "../tv/stream_size/stream_ingress_status_matrix_i_58_V.dat"
// wrapc file define: "matrix_i_59_V"
#define AUTOTB_TVIN_matrix_i_59_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_59_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_59_V  "../tv/stream_size/stream_size_in_matrix_i_59_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V  "../tv/stream_size/stream_ingress_status_matrix_i_59_V.dat"
// wrapc file define: "matrix_i_60_V"
#define AUTOTB_TVIN_matrix_i_60_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_60_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_60_V  "../tv/stream_size/stream_size_in_matrix_i_60_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V  "../tv/stream_size/stream_ingress_status_matrix_i_60_V.dat"
// wrapc file define: "matrix_i_61_V"
#define AUTOTB_TVIN_matrix_i_61_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_61_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_61_V  "../tv/stream_size/stream_size_in_matrix_i_61_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V  "../tv/stream_size/stream_ingress_status_matrix_i_61_V.dat"
// wrapc file define: "matrix_i_62_V"
#define AUTOTB_TVIN_matrix_i_62_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_62_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_62_V  "../tv/stream_size/stream_size_in_matrix_i_62_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V  "../tv/stream_size/stream_ingress_status_matrix_i_62_V.dat"
// wrapc file define: "matrix_i_63_V"
#define AUTOTB_TVIN_matrix_i_63_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_63_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_63_V  "../tv/stream_size/stream_size_in_matrix_i_63_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V  "../tv/stream_size/stream_ingress_status_matrix_i_63_V.dat"
// wrapc file define: "matrix_i_64_V"
#define AUTOTB_TVIN_matrix_i_64_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_64_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_64_V  "../tv/stream_size/stream_size_in_matrix_i_64_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V  "../tv/stream_size/stream_ingress_status_matrix_i_64_V.dat"
// wrapc file define: "matrix_i_65_V"
#define AUTOTB_TVIN_matrix_i_65_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_65_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_65_V  "../tv/stream_size/stream_size_in_matrix_i_65_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V  "../tv/stream_size/stream_ingress_status_matrix_i_65_V.dat"
// wrapc file define: "matrix_i_66_V"
#define AUTOTB_TVIN_matrix_i_66_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_66_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_66_V  "../tv/stream_size/stream_size_in_matrix_i_66_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V  "../tv/stream_size/stream_ingress_status_matrix_i_66_V.dat"
// wrapc file define: "matrix_i_67_V"
#define AUTOTB_TVIN_matrix_i_67_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_67_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_67_V  "../tv/stream_size/stream_size_in_matrix_i_67_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V  "../tv/stream_size/stream_ingress_status_matrix_i_67_V.dat"
// wrapc file define: "matrix_i_68_V"
#define AUTOTB_TVIN_matrix_i_68_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_68_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_68_V  "../tv/stream_size/stream_size_in_matrix_i_68_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V  "../tv/stream_size/stream_ingress_status_matrix_i_68_V.dat"
// wrapc file define: "matrix_i_69_V"
#define AUTOTB_TVIN_matrix_i_69_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_69_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_69_V  "../tv/stream_size/stream_size_in_matrix_i_69_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V  "../tv/stream_size/stream_ingress_status_matrix_i_69_V.dat"
// wrapc file define: "matrix_i_70_V"
#define AUTOTB_TVIN_matrix_i_70_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_70_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_70_V  "../tv/stream_size/stream_size_in_matrix_i_70_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V  "../tv/stream_size/stream_ingress_status_matrix_i_70_V.dat"
// wrapc file define: "matrix_i_71_V"
#define AUTOTB_TVIN_matrix_i_71_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_71_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_71_V  "../tv/stream_size/stream_size_in_matrix_i_71_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V  "../tv/stream_size/stream_ingress_status_matrix_i_71_V.dat"
// wrapc file define: "matrix_i_72_V"
#define AUTOTB_TVIN_matrix_i_72_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_72_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_72_V  "../tv/stream_size/stream_size_in_matrix_i_72_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V  "../tv/stream_size/stream_ingress_status_matrix_i_72_V.dat"
// wrapc file define: "matrix_i_73_V"
#define AUTOTB_TVIN_matrix_i_73_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_73_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_73_V  "../tv/stream_size/stream_size_in_matrix_i_73_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V  "../tv/stream_size/stream_ingress_status_matrix_i_73_V.dat"
// wrapc file define: "matrix_i_74_V"
#define AUTOTB_TVIN_matrix_i_74_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_74_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_74_V  "../tv/stream_size/stream_size_in_matrix_i_74_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V  "../tv/stream_size/stream_ingress_status_matrix_i_74_V.dat"
// wrapc file define: "matrix_i_75_V"
#define AUTOTB_TVIN_matrix_i_75_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_75_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_75_V  "../tv/stream_size/stream_size_in_matrix_i_75_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V  "../tv/stream_size/stream_ingress_status_matrix_i_75_V.dat"
// wrapc file define: "matrix_i_76_V"
#define AUTOTB_TVIN_matrix_i_76_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_76_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_76_V  "../tv/stream_size/stream_size_in_matrix_i_76_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V  "../tv/stream_size/stream_ingress_status_matrix_i_76_V.dat"
// wrapc file define: "matrix_i_77_V"
#define AUTOTB_TVIN_matrix_i_77_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_77_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_77_V  "../tv/stream_size/stream_size_in_matrix_i_77_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V  "../tv/stream_size/stream_ingress_status_matrix_i_77_V.dat"
// wrapc file define: "matrix_i_78_V"
#define AUTOTB_TVIN_matrix_i_78_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_78_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_78_V  "../tv/stream_size/stream_size_in_matrix_i_78_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V  "../tv/stream_size/stream_ingress_status_matrix_i_78_V.dat"
// wrapc file define: "matrix_i_79_V"
#define AUTOTB_TVIN_matrix_i_79_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_79_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_79_V  "../tv/stream_size/stream_size_in_matrix_i_79_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V  "../tv/stream_size/stream_ingress_status_matrix_i_79_V.dat"
// wrapc file define: "matrix_i_80_V"
#define AUTOTB_TVIN_matrix_i_80_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_80_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_80_V  "../tv/stream_size/stream_size_in_matrix_i_80_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V  "../tv/stream_size/stream_ingress_status_matrix_i_80_V.dat"
// wrapc file define: "matrix_i_81_V"
#define AUTOTB_TVIN_matrix_i_81_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_81_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_81_V  "../tv/stream_size/stream_size_in_matrix_i_81_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V  "../tv/stream_size/stream_ingress_status_matrix_i_81_V.dat"
// wrapc file define: "matrix_i_82_V"
#define AUTOTB_TVIN_matrix_i_82_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_82_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_82_V  "../tv/stream_size/stream_size_in_matrix_i_82_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V  "../tv/stream_size/stream_ingress_status_matrix_i_82_V.dat"
// wrapc file define: "matrix_i_83_V"
#define AUTOTB_TVIN_matrix_i_83_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_83_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_83_V  "../tv/stream_size/stream_size_in_matrix_i_83_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V  "../tv/stream_size/stream_ingress_status_matrix_i_83_V.dat"
// wrapc file define: "matrix_i_84_V"
#define AUTOTB_TVIN_matrix_i_84_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_84_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_84_V  "../tv/stream_size/stream_size_in_matrix_i_84_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V  "../tv/stream_size/stream_ingress_status_matrix_i_84_V.dat"
// wrapc file define: "matrix_i_85_V"
#define AUTOTB_TVIN_matrix_i_85_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_85_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_85_V  "../tv/stream_size/stream_size_in_matrix_i_85_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V  "../tv/stream_size/stream_ingress_status_matrix_i_85_V.dat"
// wrapc file define: "matrix_i_86_V"
#define AUTOTB_TVIN_matrix_i_86_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_86_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_86_V  "../tv/stream_size/stream_size_in_matrix_i_86_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V  "../tv/stream_size/stream_ingress_status_matrix_i_86_V.dat"
// wrapc file define: "matrix_i_87_V"
#define AUTOTB_TVIN_matrix_i_87_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_87_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_87_V  "../tv/stream_size/stream_size_in_matrix_i_87_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V  "../tv/stream_size/stream_ingress_status_matrix_i_87_V.dat"
// wrapc file define: "matrix_i_88_V"
#define AUTOTB_TVIN_matrix_i_88_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_88_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_88_V  "../tv/stream_size/stream_size_in_matrix_i_88_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V  "../tv/stream_size/stream_ingress_status_matrix_i_88_V.dat"
// wrapc file define: "matrix_i_89_V"
#define AUTOTB_TVIN_matrix_i_89_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_89_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_89_V  "../tv/stream_size/stream_size_in_matrix_i_89_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V  "../tv/stream_size/stream_ingress_status_matrix_i_89_V.dat"
// wrapc file define: "matrix_i_90_V"
#define AUTOTB_TVIN_matrix_i_90_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_90_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_90_V  "../tv/stream_size/stream_size_in_matrix_i_90_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V  "../tv/stream_size/stream_ingress_status_matrix_i_90_V.dat"
// wrapc file define: "matrix_i_91_V"
#define AUTOTB_TVIN_matrix_i_91_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_91_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_91_V  "../tv/stream_size/stream_size_in_matrix_i_91_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V  "../tv/stream_size/stream_ingress_status_matrix_i_91_V.dat"
// wrapc file define: "matrix_i_92_V"
#define AUTOTB_TVIN_matrix_i_92_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_92_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_92_V  "../tv/stream_size/stream_size_in_matrix_i_92_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V  "../tv/stream_size/stream_ingress_status_matrix_i_92_V.dat"
// wrapc file define: "matrix_i_93_V"
#define AUTOTB_TVIN_matrix_i_93_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_93_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_93_V  "../tv/stream_size/stream_size_in_matrix_i_93_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V  "../tv/stream_size/stream_ingress_status_matrix_i_93_V.dat"
// wrapc file define: "matrix_i_94_V"
#define AUTOTB_TVIN_matrix_i_94_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_94_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_94_V  "../tv/stream_size/stream_size_in_matrix_i_94_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V  "../tv/stream_size/stream_ingress_status_matrix_i_94_V.dat"
// wrapc file define: "matrix_i_95_V"
#define AUTOTB_TVIN_matrix_i_95_V  "../tv/cdatafile/c.fire2.autotvin_matrix_i_95_V.dat"
#define WRAPC_STREAM_SIZE_IN_matrix_i_95_V  "../tv/stream_size/stream_size_in_matrix_i_95_V.dat"
#define WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V  "../tv/stream_size/stream_ingress_status_matrix_i_95_V.dat"
// wrapc file define: "kernel_s1x1"
#define AUTOTB_TVIN_kernel_s1x1  "../tv/cdatafile/c.fire2.autotvin_kernel_s1x1.dat"
// wrapc file define: "kernel_e1x1"
#define AUTOTB_TVIN_kernel_e1x1  "../tv/cdatafile/c.fire2.autotvin_kernel_e1x1.dat"
// wrapc file define: "kernel_e3x3"
#define AUTOTB_TVIN_kernel_e3x3  "../tv/cdatafile/c.fire2.autotvin_kernel_e3x3.dat"
// wrapc file define: "matrix_o_0_V"
#define AUTOTB_TVOUT_matrix_o_0_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_0_V.dat"
#define AUTOTB_TVIN_matrix_o_0_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_0_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_0_V  "../tv/stream_size/stream_size_out_matrix_o_0_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_0_V  "../tv/stream_size/stream_egress_status_matrix_o_0_V.dat"
// wrapc file define: "matrix_o_1_V"
#define AUTOTB_TVOUT_matrix_o_1_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_1_V.dat"
#define AUTOTB_TVIN_matrix_o_1_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_1_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_1_V  "../tv/stream_size/stream_size_out_matrix_o_1_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_1_V  "../tv/stream_size/stream_egress_status_matrix_o_1_V.dat"
// wrapc file define: "matrix_o_2_V"
#define AUTOTB_TVOUT_matrix_o_2_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_2_V.dat"
#define AUTOTB_TVIN_matrix_o_2_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_2_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_2_V  "../tv/stream_size/stream_size_out_matrix_o_2_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_2_V  "../tv/stream_size/stream_egress_status_matrix_o_2_V.dat"
// wrapc file define: "matrix_o_3_V"
#define AUTOTB_TVOUT_matrix_o_3_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_3_V.dat"
#define AUTOTB_TVIN_matrix_o_3_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_3_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_3_V  "../tv/stream_size/stream_size_out_matrix_o_3_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_3_V  "../tv/stream_size/stream_egress_status_matrix_o_3_V.dat"
// wrapc file define: "matrix_o_4_V"
#define AUTOTB_TVOUT_matrix_o_4_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_4_V.dat"
#define AUTOTB_TVIN_matrix_o_4_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_4_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_4_V  "../tv/stream_size/stream_size_out_matrix_o_4_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_4_V  "../tv/stream_size/stream_egress_status_matrix_o_4_V.dat"
// wrapc file define: "matrix_o_5_V"
#define AUTOTB_TVOUT_matrix_o_5_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_5_V.dat"
#define AUTOTB_TVIN_matrix_o_5_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_5_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_5_V  "../tv/stream_size/stream_size_out_matrix_o_5_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_5_V  "../tv/stream_size/stream_egress_status_matrix_o_5_V.dat"
// wrapc file define: "matrix_o_6_V"
#define AUTOTB_TVOUT_matrix_o_6_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_6_V.dat"
#define AUTOTB_TVIN_matrix_o_6_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_6_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_6_V  "../tv/stream_size/stream_size_out_matrix_o_6_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_6_V  "../tv/stream_size/stream_egress_status_matrix_o_6_V.dat"
// wrapc file define: "matrix_o_7_V"
#define AUTOTB_TVOUT_matrix_o_7_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_7_V.dat"
#define AUTOTB_TVIN_matrix_o_7_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_7_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_7_V  "../tv/stream_size/stream_size_out_matrix_o_7_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_7_V  "../tv/stream_size/stream_egress_status_matrix_o_7_V.dat"
// wrapc file define: "matrix_o_8_V"
#define AUTOTB_TVOUT_matrix_o_8_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_8_V.dat"
#define AUTOTB_TVIN_matrix_o_8_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_8_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_8_V  "../tv/stream_size/stream_size_out_matrix_o_8_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_8_V  "../tv/stream_size/stream_egress_status_matrix_o_8_V.dat"
// wrapc file define: "matrix_o_9_V"
#define AUTOTB_TVOUT_matrix_o_9_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_9_V.dat"
#define AUTOTB_TVIN_matrix_o_9_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_9_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_9_V  "../tv/stream_size/stream_size_out_matrix_o_9_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_9_V  "../tv/stream_size/stream_egress_status_matrix_o_9_V.dat"
// wrapc file define: "matrix_o_10_V"
#define AUTOTB_TVOUT_matrix_o_10_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_10_V.dat"
#define AUTOTB_TVIN_matrix_o_10_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_10_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_10_V  "../tv/stream_size/stream_size_out_matrix_o_10_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_10_V  "../tv/stream_size/stream_egress_status_matrix_o_10_V.dat"
// wrapc file define: "matrix_o_11_V"
#define AUTOTB_TVOUT_matrix_o_11_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_11_V.dat"
#define AUTOTB_TVIN_matrix_o_11_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_11_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_11_V  "../tv/stream_size/stream_size_out_matrix_o_11_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_11_V  "../tv/stream_size/stream_egress_status_matrix_o_11_V.dat"
// wrapc file define: "matrix_o_12_V"
#define AUTOTB_TVOUT_matrix_o_12_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_12_V.dat"
#define AUTOTB_TVIN_matrix_o_12_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_12_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_12_V  "../tv/stream_size/stream_size_out_matrix_o_12_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_12_V  "../tv/stream_size/stream_egress_status_matrix_o_12_V.dat"
// wrapc file define: "matrix_o_13_V"
#define AUTOTB_TVOUT_matrix_o_13_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_13_V.dat"
#define AUTOTB_TVIN_matrix_o_13_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_13_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_13_V  "../tv/stream_size/stream_size_out_matrix_o_13_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_13_V  "../tv/stream_size/stream_egress_status_matrix_o_13_V.dat"
// wrapc file define: "matrix_o_14_V"
#define AUTOTB_TVOUT_matrix_o_14_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_14_V.dat"
#define AUTOTB_TVIN_matrix_o_14_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_14_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_14_V  "../tv/stream_size/stream_size_out_matrix_o_14_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_14_V  "../tv/stream_size/stream_egress_status_matrix_o_14_V.dat"
// wrapc file define: "matrix_o_15_V"
#define AUTOTB_TVOUT_matrix_o_15_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_15_V.dat"
#define AUTOTB_TVIN_matrix_o_15_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_15_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_15_V  "../tv/stream_size/stream_size_out_matrix_o_15_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_15_V  "../tv/stream_size/stream_egress_status_matrix_o_15_V.dat"
// wrapc file define: "matrix_o_16_V"
#define AUTOTB_TVOUT_matrix_o_16_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_16_V.dat"
#define AUTOTB_TVIN_matrix_o_16_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_16_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_16_V  "../tv/stream_size/stream_size_out_matrix_o_16_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_16_V  "../tv/stream_size/stream_egress_status_matrix_o_16_V.dat"
// wrapc file define: "matrix_o_17_V"
#define AUTOTB_TVOUT_matrix_o_17_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_17_V.dat"
#define AUTOTB_TVIN_matrix_o_17_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_17_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_17_V  "../tv/stream_size/stream_size_out_matrix_o_17_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_17_V  "../tv/stream_size/stream_egress_status_matrix_o_17_V.dat"
// wrapc file define: "matrix_o_18_V"
#define AUTOTB_TVOUT_matrix_o_18_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_18_V.dat"
#define AUTOTB_TVIN_matrix_o_18_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_18_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_18_V  "../tv/stream_size/stream_size_out_matrix_o_18_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_18_V  "../tv/stream_size/stream_egress_status_matrix_o_18_V.dat"
// wrapc file define: "matrix_o_19_V"
#define AUTOTB_TVOUT_matrix_o_19_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_19_V.dat"
#define AUTOTB_TVIN_matrix_o_19_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_19_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_19_V  "../tv/stream_size/stream_size_out_matrix_o_19_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_19_V  "../tv/stream_size/stream_egress_status_matrix_o_19_V.dat"
// wrapc file define: "matrix_o_20_V"
#define AUTOTB_TVOUT_matrix_o_20_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_20_V.dat"
#define AUTOTB_TVIN_matrix_o_20_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_20_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_20_V  "../tv/stream_size/stream_size_out_matrix_o_20_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_20_V  "../tv/stream_size/stream_egress_status_matrix_o_20_V.dat"
// wrapc file define: "matrix_o_21_V"
#define AUTOTB_TVOUT_matrix_o_21_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_21_V.dat"
#define AUTOTB_TVIN_matrix_o_21_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_21_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_21_V  "../tv/stream_size/stream_size_out_matrix_o_21_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_21_V  "../tv/stream_size/stream_egress_status_matrix_o_21_V.dat"
// wrapc file define: "matrix_o_22_V"
#define AUTOTB_TVOUT_matrix_o_22_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_22_V.dat"
#define AUTOTB_TVIN_matrix_o_22_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_22_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_22_V  "../tv/stream_size/stream_size_out_matrix_o_22_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_22_V  "../tv/stream_size/stream_egress_status_matrix_o_22_V.dat"
// wrapc file define: "matrix_o_23_V"
#define AUTOTB_TVOUT_matrix_o_23_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_23_V.dat"
#define AUTOTB_TVIN_matrix_o_23_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_23_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_23_V  "../tv/stream_size/stream_size_out_matrix_o_23_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_23_V  "../tv/stream_size/stream_egress_status_matrix_o_23_V.dat"
// wrapc file define: "matrix_o_24_V"
#define AUTOTB_TVOUT_matrix_o_24_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_24_V.dat"
#define AUTOTB_TVIN_matrix_o_24_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_24_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_24_V  "../tv/stream_size/stream_size_out_matrix_o_24_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_24_V  "../tv/stream_size/stream_egress_status_matrix_o_24_V.dat"
// wrapc file define: "matrix_o_25_V"
#define AUTOTB_TVOUT_matrix_o_25_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_25_V.dat"
#define AUTOTB_TVIN_matrix_o_25_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_25_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_25_V  "../tv/stream_size/stream_size_out_matrix_o_25_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_25_V  "../tv/stream_size/stream_egress_status_matrix_o_25_V.dat"
// wrapc file define: "matrix_o_26_V"
#define AUTOTB_TVOUT_matrix_o_26_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_26_V.dat"
#define AUTOTB_TVIN_matrix_o_26_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_26_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_26_V  "../tv/stream_size/stream_size_out_matrix_o_26_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_26_V  "../tv/stream_size/stream_egress_status_matrix_o_26_V.dat"
// wrapc file define: "matrix_o_27_V"
#define AUTOTB_TVOUT_matrix_o_27_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_27_V.dat"
#define AUTOTB_TVIN_matrix_o_27_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_27_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_27_V  "../tv/stream_size/stream_size_out_matrix_o_27_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_27_V  "../tv/stream_size/stream_egress_status_matrix_o_27_V.dat"
// wrapc file define: "matrix_o_28_V"
#define AUTOTB_TVOUT_matrix_o_28_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_28_V.dat"
#define AUTOTB_TVIN_matrix_o_28_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_28_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_28_V  "../tv/stream_size/stream_size_out_matrix_o_28_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_28_V  "../tv/stream_size/stream_egress_status_matrix_o_28_V.dat"
// wrapc file define: "matrix_o_29_V"
#define AUTOTB_TVOUT_matrix_o_29_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_29_V.dat"
#define AUTOTB_TVIN_matrix_o_29_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_29_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_29_V  "../tv/stream_size/stream_size_out_matrix_o_29_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_29_V  "../tv/stream_size/stream_egress_status_matrix_o_29_V.dat"
// wrapc file define: "matrix_o_30_V"
#define AUTOTB_TVOUT_matrix_o_30_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_30_V.dat"
#define AUTOTB_TVIN_matrix_o_30_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_30_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_30_V  "../tv/stream_size/stream_size_out_matrix_o_30_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_30_V  "../tv/stream_size/stream_egress_status_matrix_o_30_V.dat"
// wrapc file define: "matrix_o_31_V"
#define AUTOTB_TVOUT_matrix_o_31_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_31_V.dat"
#define AUTOTB_TVIN_matrix_o_31_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_31_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_31_V  "../tv/stream_size/stream_size_out_matrix_o_31_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_31_V  "../tv/stream_size/stream_egress_status_matrix_o_31_V.dat"
// wrapc file define: "matrix_o_32_V"
#define AUTOTB_TVOUT_matrix_o_32_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_32_V.dat"
#define AUTOTB_TVIN_matrix_o_32_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_32_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_32_V  "../tv/stream_size/stream_size_out_matrix_o_32_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_32_V  "../tv/stream_size/stream_egress_status_matrix_o_32_V.dat"
// wrapc file define: "matrix_o_33_V"
#define AUTOTB_TVOUT_matrix_o_33_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_33_V.dat"
#define AUTOTB_TVIN_matrix_o_33_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_33_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_33_V  "../tv/stream_size/stream_size_out_matrix_o_33_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_33_V  "../tv/stream_size/stream_egress_status_matrix_o_33_V.dat"
// wrapc file define: "matrix_o_34_V"
#define AUTOTB_TVOUT_matrix_o_34_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_34_V.dat"
#define AUTOTB_TVIN_matrix_o_34_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_34_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_34_V  "../tv/stream_size/stream_size_out_matrix_o_34_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_34_V  "../tv/stream_size/stream_egress_status_matrix_o_34_V.dat"
// wrapc file define: "matrix_o_35_V"
#define AUTOTB_TVOUT_matrix_o_35_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_35_V.dat"
#define AUTOTB_TVIN_matrix_o_35_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_35_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_35_V  "../tv/stream_size/stream_size_out_matrix_o_35_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_35_V  "../tv/stream_size/stream_egress_status_matrix_o_35_V.dat"
// wrapc file define: "matrix_o_36_V"
#define AUTOTB_TVOUT_matrix_o_36_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_36_V.dat"
#define AUTOTB_TVIN_matrix_o_36_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_36_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_36_V  "../tv/stream_size/stream_size_out_matrix_o_36_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_36_V  "../tv/stream_size/stream_egress_status_matrix_o_36_V.dat"
// wrapc file define: "matrix_o_37_V"
#define AUTOTB_TVOUT_matrix_o_37_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_37_V.dat"
#define AUTOTB_TVIN_matrix_o_37_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_37_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_37_V  "../tv/stream_size/stream_size_out_matrix_o_37_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_37_V  "../tv/stream_size/stream_egress_status_matrix_o_37_V.dat"
// wrapc file define: "matrix_o_38_V"
#define AUTOTB_TVOUT_matrix_o_38_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_38_V.dat"
#define AUTOTB_TVIN_matrix_o_38_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_38_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_38_V  "../tv/stream_size/stream_size_out_matrix_o_38_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_38_V  "../tv/stream_size/stream_egress_status_matrix_o_38_V.dat"
// wrapc file define: "matrix_o_39_V"
#define AUTOTB_TVOUT_matrix_o_39_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_39_V.dat"
#define AUTOTB_TVIN_matrix_o_39_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_39_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_39_V  "../tv/stream_size/stream_size_out_matrix_o_39_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_39_V  "../tv/stream_size/stream_egress_status_matrix_o_39_V.dat"
// wrapc file define: "matrix_o_40_V"
#define AUTOTB_TVOUT_matrix_o_40_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_40_V.dat"
#define AUTOTB_TVIN_matrix_o_40_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_40_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_40_V  "../tv/stream_size/stream_size_out_matrix_o_40_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_40_V  "../tv/stream_size/stream_egress_status_matrix_o_40_V.dat"
// wrapc file define: "matrix_o_41_V"
#define AUTOTB_TVOUT_matrix_o_41_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_41_V.dat"
#define AUTOTB_TVIN_matrix_o_41_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_41_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_41_V  "../tv/stream_size/stream_size_out_matrix_o_41_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_41_V  "../tv/stream_size/stream_egress_status_matrix_o_41_V.dat"
// wrapc file define: "matrix_o_42_V"
#define AUTOTB_TVOUT_matrix_o_42_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_42_V.dat"
#define AUTOTB_TVIN_matrix_o_42_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_42_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_42_V  "../tv/stream_size/stream_size_out_matrix_o_42_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_42_V  "../tv/stream_size/stream_egress_status_matrix_o_42_V.dat"
// wrapc file define: "matrix_o_43_V"
#define AUTOTB_TVOUT_matrix_o_43_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_43_V.dat"
#define AUTOTB_TVIN_matrix_o_43_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_43_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_43_V  "../tv/stream_size/stream_size_out_matrix_o_43_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_43_V  "../tv/stream_size/stream_egress_status_matrix_o_43_V.dat"
// wrapc file define: "matrix_o_44_V"
#define AUTOTB_TVOUT_matrix_o_44_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_44_V.dat"
#define AUTOTB_TVIN_matrix_o_44_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_44_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_44_V  "../tv/stream_size/stream_size_out_matrix_o_44_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_44_V  "../tv/stream_size/stream_egress_status_matrix_o_44_V.dat"
// wrapc file define: "matrix_o_45_V"
#define AUTOTB_TVOUT_matrix_o_45_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_45_V.dat"
#define AUTOTB_TVIN_matrix_o_45_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_45_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_45_V  "../tv/stream_size/stream_size_out_matrix_o_45_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_45_V  "../tv/stream_size/stream_egress_status_matrix_o_45_V.dat"
// wrapc file define: "matrix_o_46_V"
#define AUTOTB_TVOUT_matrix_o_46_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_46_V.dat"
#define AUTOTB_TVIN_matrix_o_46_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_46_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_46_V  "../tv/stream_size/stream_size_out_matrix_o_46_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_46_V  "../tv/stream_size/stream_egress_status_matrix_o_46_V.dat"
// wrapc file define: "matrix_o_47_V"
#define AUTOTB_TVOUT_matrix_o_47_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_47_V.dat"
#define AUTOTB_TVIN_matrix_o_47_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_47_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_47_V  "../tv/stream_size/stream_size_out_matrix_o_47_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_47_V  "../tv/stream_size/stream_egress_status_matrix_o_47_V.dat"
// wrapc file define: "matrix_o_48_V"
#define AUTOTB_TVOUT_matrix_o_48_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_48_V.dat"
#define AUTOTB_TVIN_matrix_o_48_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_48_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_48_V  "../tv/stream_size/stream_size_out_matrix_o_48_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_48_V  "../tv/stream_size/stream_egress_status_matrix_o_48_V.dat"
// wrapc file define: "matrix_o_49_V"
#define AUTOTB_TVOUT_matrix_o_49_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_49_V.dat"
#define AUTOTB_TVIN_matrix_o_49_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_49_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_49_V  "../tv/stream_size/stream_size_out_matrix_o_49_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_49_V  "../tv/stream_size/stream_egress_status_matrix_o_49_V.dat"
// wrapc file define: "matrix_o_50_V"
#define AUTOTB_TVOUT_matrix_o_50_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_50_V.dat"
#define AUTOTB_TVIN_matrix_o_50_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_50_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_50_V  "../tv/stream_size/stream_size_out_matrix_o_50_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_50_V  "../tv/stream_size/stream_egress_status_matrix_o_50_V.dat"
// wrapc file define: "matrix_o_51_V"
#define AUTOTB_TVOUT_matrix_o_51_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_51_V.dat"
#define AUTOTB_TVIN_matrix_o_51_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_51_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_51_V  "../tv/stream_size/stream_size_out_matrix_o_51_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_51_V  "../tv/stream_size/stream_egress_status_matrix_o_51_V.dat"
// wrapc file define: "matrix_o_52_V"
#define AUTOTB_TVOUT_matrix_o_52_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_52_V.dat"
#define AUTOTB_TVIN_matrix_o_52_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_52_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_52_V  "../tv/stream_size/stream_size_out_matrix_o_52_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_52_V  "../tv/stream_size/stream_egress_status_matrix_o_52_V.dat"
// wrapc file define: "matrix_o_53_V"
#define AUTOTB_TVOUT_matrix_o_53_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_53_V.dat"
#define AUTOTB_TVIN_matrix_o_53_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_53_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_53_V  "../tv/stream_size/stream_size_out_matrix_o_53_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_53_V  "../tv/stream_size/stream_egress_status_matrix_o_53_V.dat"
// wrapc file define: "matrix_o_54_V"
#define AUTOTB_TVOUT_matrix_o_54_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_54_V.dat"
#define AUTOTB_TVIN_matrix_o_54_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_54_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_54_V  "../tv/stream_size/stream_size_out_matrix_o_54_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_54_V  "../tv/stream_size/stream_egress_status_matrix_o_54_V.dat"
// wrapc file define: "matrix_o_55_V"
#define AUTOTB_TVOUT_matrix_o_55_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_55_V.dat"
#define AUTOTB_TVIN_matrix_o_55_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_55_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_55_V  "../tv/stream_size/stream_size_out_matrix_o_55_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_55_V  "../tv/stream_size/stream_egress_status_matrix_o_55_V.dat"
// wrapc file define: "matrix_o_56_V"
#define AUTOTB_TVOUT_matrix_o_56_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_56_V.dat"
#define AUTOTB_TVIN_matrix_o_56_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_56_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_56_V  "../tv/stream_size/stream_size_out_matrix_o_56_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_56_V  "../tv/stream_size/stream_egress_status_matrix_o_56_V.dat"
// wrapc file define: "matrix_o_57_V"
#define AUTOTB_TVOUT_matrix_o_57_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_57_V.dat"
#define AUTOTB_TVIN_matrix_o_57_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_57_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_57_V  "../tv/stream_size/stream_size_out_matrix_o_57_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_57_V  "../tv/stream_size/stream_egress_status_matrix_o_57_V.dat"
// wrapc file define: "matrix_o_58_V"
#define AUTOTB_TVOUT_matrix_o_58_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_58_V.dat"
#define AUTOTB_TVIN_matrix_o_58_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_58_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_58_V  "../tv/stream_size/stream_size_out_matrix_o_58_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_58_V  "../tv/stream_size/stream_egress_status_matrix_o_58_V.dat"
// wrapc file define: "matrix_o_59_V"
#define AUTOTB_TVOUT_matrix_o_59_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_59_V.dat"
#define AUTOTB_TVIN_matrix_o_59_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_59_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_59_V  "../tv/stream_size/stream_size_out_matrix_o_59_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_59_V  "../tv/stream_size/stream_egress_status_matrix_o_59_V.dat"
// wrapc file define: "matrix_o_60_V"
#define AUTOTB_TVOUT_matrix_o_60_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_60_V.dat"
#define AUTOTB_TVIN_matrix_o_60_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_60_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_60_V  "../tv/stream_size/stream_size_out_matrix_o_60_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_60_V  "../tv/stream_size/stream_egress_status_matrix_o_60_V.dat"
// wrapc file define: "matrix_o_61_V"
#define AUTOTB_TVOUT_matrix_o_61_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_61_V.dat"
#define AUTOTB_TVIN_matrix_o_61_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_61_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_61_V  "../tv/stream_size/stream_size_out_matrix_o_61_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_61_V  "../tv/stream_size/stream_egress_status_matrix_o_61_V.dat"
// wrapc file define: "matrix_o_62_V"
#define AUTOTB_TVOUT_matrix_o_62_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_62_V.dat"
#define AUTOTB_TVIN_matrix_o_62_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_62_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_62_V  "../tv/stream_size/stream_size_out_matrix_o_62_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_62_V  "../tv/stream_size/stream_egress_status_matrix_o_62_V.dat"
// wrapc file define: "matrix_o_63_V"
#define AUTOTB_TVOUT_matrix_o_63_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_63_V.dat"
#define AUTOTB_TVIN_matrix_o_63_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_63_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_63_V  "../tv/stream_size/stream_size_out_matrix_o_63_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_63_V  "../tv/stream_size/stream_egress_status_matrix_o_63_V.dat"
// wrapc file define: "matrix_o_64_V"
#define AUTOTB_TVOUT_matrix_o_64_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_64_V.dat"
#define AUTOTB_TVIN_matrix_o_64_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_64_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_64_V  "../tv/stream_size/stream_size_out_matrix_o_64_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_64_V  "../tv/stream_size/stream_egress_status_matrix_o_64_V.dat"
// wrapc file define: "matrix_o_65_V"
#define AUTOTB_TVOUT_matrix_o_65_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_65_V.dat"
#define AUTOTB_TVIN_matrix_o_65_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_65_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_65_V  "../tv/stream_size/stream_size_out_matrix_o_65_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_65_V  "../tv/stream_size/stream_egress_status_matrix_o_65_V.dat"
// wrapc file define: "matrix_o_66_V"
#define AUTOTB_TVOUT_matrix_o_66_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_66_V.dat"
#define AUTOTB_TVIN_matrix_o_66_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_66_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_66_V  "../tv/stream_size/stream_size_out_matrix_o_66_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_66_V  "../tv/stream_size/stream_egress_status_matrix_o_66_V.dat"
// wrapc file define: "matrix_o_67_V"
#define AUTOTB_TVOUT_matrix_o_67_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_67_V.dat"
#define AUTOTB_TVIN_matrix_o_67_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_67_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_67_V  "../tv/stream_size/stream_size_out_matrix_o_67_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_67_V  "../tv/stream_size/stream_egress_status_matrix_o_67_V.dat"
// wrapc file define: "matrix_o_68_V"
#define AUTOTB_TVOUT_matrix_o_68_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_68_V.dat"
#define AUTOTB_TVIN_matrix_o_68_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_68_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_68_V  "../tv/stream_size/stream_size_out_matrix_o_68_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_68_V  "../tv/stream_size/stream_egress_status_matrix_o_68_V.dat"
// wrapc file define: "matrix_o_69_V"
#define AUTOTB_TVOUT_matrix_o_69_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_69_V.dat"
#define AUTOTB_TVIN_matrix_o_69_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_69_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_69_V  "../tv/stream_size/stream_size_out_matrix_o_69_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_69_V  "../tv/stream_size/stream_egress_status_matrix_o_69_V.dat"
// wrapc file define: "matrix_o_70_V"
#define AUTOTB_TVOUT_matrix_o_70_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_70_V.dat"
#define AUTOTB_TVIN_matrix_o_70_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_70_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_70_V  "../tv/stream_size/stream_size_out_matrix_o_70_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_70_V  "../tv/stream_size/stream_egress_status_matrix_o_70_V.dat"
// wrapc file define: "matrix_o_71_V"
#define AUTOTB_TVOUT_matrix_o_71_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_71_V.dat"
#define AUTOTB_TVIN_matrix_o_71_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_71_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_71_V  "../tv/stream_size/stream_size_out_matrix_o_71_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_71_V  "../tv/stream_size/stream_egress_status_matrix_o_71_V.dat"
// wrapc file define: "matrix_o_72_V"
#define AUTOTB_TVOUT_matrix_o_72_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_72_V.dat"
#define AUTOTB_TVIN_matrix_o_72_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_72_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_72_V  "../tv/stream_size/stream_size_out_matrix_o_72_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_72_V  "../tv/stream_size/stream_egress_status_matrix_o_72_V.dat"
// wrapc file define: "matrix_o_73_V"
#define AUTOTB_TVOUT_matrix_o_73_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_73_V.dat"
#define AUTOTB_TVIN_matrix_o_73_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_73_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_73_V  "../tv/stream_size/stream_size_out_matrix_o_73_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_73_V  "../tv/stream_size/stream_egress_status_matrix_o_73_V.dat"
// wrapc file define: "matrix_o_74_V"
#define AUTOTB_TVOUT_matrix_o_74_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_74_V.dat"
#define AUTOTB_TVIN_matrix_o_74_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_74_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_74_V  "../tv/stream_size/stream_size_out_matrix_o_74_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_74_V  "../tv/stream_size/stream_egress_status_matrix_o_74_V.dat"
// wrapc file define: "matrix_o_75_V"
#define AUTOTB_TVOUT_matrix_o_75_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_75_V.dat"
#define AUTOTB_TVIN_matrix_o_75_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_75_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_75_V  "../tv/stream_size/stream_size_out_matrix_o_75_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_75_V  "../tv/stream_size/stream_egress_status_matrix_o_75_V.dat"
// wrapc file define: "matrix_o_76_V"
#define AUTOTB_TVOUT_matrix_o_76_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_76_V.dat"
#define AUTOTB_TVIN_matrix_o_76_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_76_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_76_V  "../tv/stream_size/stream_size_out_matrix_o_76_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_76_V  "../tv/stream_size/stream_egress_status_matrix_o_76_V.dat"
// wrapc file define: "matrix_o_77_V"
#define AUTOTB_TVOUT_matrix_o_77_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_77_V.dat"
#define AUTOTB_TVIN_matrix_o_77_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_77_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_77_V  "../tv/stream_size/stream_size_out_matrix_o_77_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_77_V  "../tv/stream_size/stream_egress_status_matrix_o_77_V.dat"
// wrapc file define: "matrix_o_78_V"
#define AUTOTB_TVOUT_matrix_o_78_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_78_V.dat"
#define AUTOTB_TVIN_matrix_o_78_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_78_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_78_V  "../tv/stream_size/stream_size_out_matrix_o_78_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_78_V  "../tv/stream_size/stream_egress_status_matrix_o_78_V.dat"
// wrapc file define: "matrix_o_79_V"
#define AUTOTB_TVOUT_matrix_o_79_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_79_V.dat"
#define AUTOTB_TVIN_matrix_o_79_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_79_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_79_V  "../tv/stream_size/stream_size_out_matrix_o_79_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_79_V  "../tv/stream_size/stream_egress_status_matrix_o_79_V.dat"
// wrapc file define: "matrix_o_80_V"
#define AUTOTB_TVOUT_matrix_o_80_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_80_V.dat"
#define AUTOTB_TVIN_matrix_o_80_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_80_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_80_V  "../tv/stream_size/stream_size_out_matrix_o_80_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_80_V  "../tv/stream_size/stream_egress_status_matrix_o_80_V.dat"
// wrapc file define: "matrix_o_81_V"
#define AUTOTB_TVOUT_matrix_o_81_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_81_V.dat"
#define AUTOTB_TVIN_matrix_o_81_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_81_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_81_V  "../tv/stream_size/stream_size_out_matrix_o_81_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_81_V  "../tv/stream_size/stream_egress_status_matrix_o_81_V.dat"
// wrapc file define: "matrix_o_82_V"
#define AUTOTB_TVOUT_matrix_o_82_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_82_V.dat"
#define AUTOTB_TVIN_matrix_o_82_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_82_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_82_V  "../tv/stream_size/stream_size_out_matrix_o_82_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_82_V  "../tv/stream_size/stream_egress_status_matrix_o_82_V.dat"
// wrapc file define: "matrix_o_83_V"
#define AUTOTB_TVOUT_matrix_o_83_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_83_V.dat"
#define AUTOTB_TVIN_matrix_o_83_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_83_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_83_V  "../tv/stream_size/stream_size_out_matrix_o_83_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_83_V  "../tv/stream_size/stream_egress_status_matrix_o_83_V.dat"
// wrapc file define: "matrix_o_84_V"
#define AUTOTB_TVOUT_matrix_o_84_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_84_V.dat"
#define AUTOTB_TVIN_matrix_o_84_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_84_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_84_V  "../tv/stream_size/stream_size_out_matrix_o_84_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_84_V  "../tv/stream_size/stream_egress_status_matrix_o_84_V.dat"
// wrapc file define: "matrix_o_85_V"
#define AUTOTB_TVOUT_matrix_o_85_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_85_V.dat"
#define AUTOTB_TVIN_matrix_o_85_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_85_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_85_V  "../tv/stream_size/stream_size_out_matrix_o_85_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_85_V  "../tv/stream_size/stream_egress_status_matrix_o_85_V.dat"
// wrapc file define: "matrix_o_86_V"
#define AUTOTB_TVOUT_matrix_o_86_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_86_V.dat"
#define AUTOTB_TVIN_matrix_o_86_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_86_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_86_V  "../tv/stream_size/stream_size_out_matrix_o_86_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_86_V  "../tv/stream_size/stream_egress_status_matrix_o_86_V.dat"
// wrapc file define: "matrix_o_87_V"
#define AUTOTB_TVOUT_matrix_o_87_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_87_V.dat"
#define AUTOTB_TVIN_matrix_o_87_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_87_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_87_V  "../tv/stream_size/stream_size_out_matrix_o_87_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_87_V  "../tv/stream_size/stream_egress_status_matrix_o_87_V.dat"
// wrapc file define: "matrix_o_88_V"
#define AUTOTB_TVOUT_matrix_o_88_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_88_V.dat"
#define AUTOTB_TVIN_matrix_o_88_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_88_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_88_V  "../tv/stream_size/stream_size_out_matrix_o_88_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_88_V  "../tv/stream_size/stream_egress_status_matrix_o_88_V.dat"
// wrapc file define: "matrix_o_89_V"
#define AUTOTB_TVOUT_matrix_o_89_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_89_V.dat"
#define AUTOTB_TVIN_matrix_o_89_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_89_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_89_V  "../tv/stream_size/stream_size_out_matrix_o_89_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_89_V  "../tv/stream_size/stream_egress_status_matrix_o_89_V.dat"
// wrapc file define: "matrix_o_90_V"
#define AUTOTB_TVOUT_matrix_o_90_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_90_V.dat"
#define AUTOTB_TVIN_matrix_o_90_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_90_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_90_V  "../tv/stream_size/stream_size_out_matrix_o_90_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_90_V  "../tv/stream_size/stream_egress_status_matrix_o_90_V.dat"
// wrapc file define: "matrix_o_91_V"
#define AUTOTB_TVOUT_matrix_o_91_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_91_V.dat"
#define AUTOTB_TVIN_matrix_o_91_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_91_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_91_V  "../tv/stream_size/stream_size_out_matrix_o_91_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_91_V  "../tv/stream_size/stream_egress_status_matrix_o_91_V.dat"
// wrapc file define: "matrix_o_92_V"
#define AUTOTB_TVOUT_matrix_o_92_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_92_V.dat"
#define AUTOTB_TVIN_matrix_o_92_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_92_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_92_V  "../tv/stream_size/stream_size_out_matrix_o_92_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_92_V  "../tv/stream_size/stream_egress_status_matrix_o_92_V.dat"
// wrapc file define: "matrix_o_93_V"
#define AUTOTB_TVOUT_matrix_o_93_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_93_V.dat"
#define AUTOTB_TVIN_matrix_o_93_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_93_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_93_V  "../tv/stream_size/stream_size_out_matrix_o_93_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_93_V  "../tv/stream_size/stream_egress_status_matrix_o_93_V.dat"
// wrapc file define: "matrix_o_94_V"
#define AUTOTB_TVOUT_matrix_o_94_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_94_V.dat"
#define AUTOTB_TVIN_matrix_o_94_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_94_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_94_V  "../tv/stream_size/stream_size_out_matrix_o_94_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_94_V  "../tv/stream_size/stream_egress_status_matrix_o_94_V.dat"
// wrapc file define: "matrix_o_95_V"
#define AUTOTB_TVOUT_matrix_o_95_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_95_V.dat"
#define AUTOTB_TVIN_matrix_o_95_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_95_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_95_V  "../tv/stream_size/stream_size_out_matrix_o_95_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_95_V  "../tv/stream_size/stream_egress_status_matrix_o_95_V.dat"
// wrapc file define: "matrix_o_96_V"
#define AUTOTB_TVOUT_matrix_o_96_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_96_V.dat"
#define AUTOTB_TVIN_matrix_o_96_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_96_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_96_V  "../tv/stream_size/stream_size_out_matrix_o_96_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_96_V  "../tv/stream_size/stream_egress_status_matrix_o_96_V.dat"
// wrapc file define: "matrix_o_97_V"
#define AUTOTB_TVOUT_matrix_o_97_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_97_V.dat"
#define AUTOTB_TVIN_matrix_o_97_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_97_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_97_V  "../tv/stream_size/stream_size_out_matrix_o_97_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_97_V  "../tv/stream_size/stream_egress_status_matrix_o_97_V.dat"
// wrapc file define: "matrix_o_98_V"
#define AUTOTB_TVOUT_matrix_o_98_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_98_V.dat"
#define AUTOTB_TVIN_matrix_o_98_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_98_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_98_V  "../tv/stream_size/stream_size_out_matrix_o_98_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_98_V  "../tv/stream_size/stream_egress_status_matrix_o_98_V.dat"
// wrapc file define: "matrix_o_99_V"
#define AUTOTB_TVOUT_matrix_o_99_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_99_V.dat"
#define AUTOTB_TVIN_matrix_o_99_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_99_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_99_V  "../tv/stream_size/stream_size_out_matrix_o_99_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_99_V  "../tv/stream_size/stream_egress_status_matrix_o_99_V.dat"
// wrapc file define: "matrix_o_100_V"
#define AUTOTB_TVOUT_matrix_o_100_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_100_V.dat"
#define AUTOTB_TVIN_matrix_o_100_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_100_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_100_V  "../tv/stream_size/stream_size_out_matrix_o_100_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_100_V  "../tv/stream_size/stream_egress_status_matrix_o_100_V.dat"
// wrapc file define: "matrix_o_101_V"
#define AUTOTB_TVOUT_matrix_o_101_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_101_V.dat"
#define AUTOTB_TVIN_matrix_o_101_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_101_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_101_V  "../tv/stream_size/stream_size_out_matrix_o_101_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_101_V  "../tv/stream_size/stream_egress_status_matrix_o_101_V.dat"
// wrapc file define: "matrix_o_102_V"
#define AUTOTB_TVOUT_matrix_o_102_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_102_V.dat"
#define AUTOTB_TVIN_matrix_o_102_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_102_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_102_V  "../tv/stream_size/stream_size_out_matrix_o_102_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_102_V  "../tv/stream_size/stream_egress_status_matrix_o_102_V.dat"
// wrapc file define: "matrix_o_103_V"
#define AUTOTB_TVOUT_matrix_o_103_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_103_V.dat"
#define AUTOTB_TVIN_matrix_o_103_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_103_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_103_V  "../tv/stream_size/stream_size_out_matrix_o_103_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_103_V  "../tv/stream_size/stream_egress_status_matrix_o_103_V.dat"
// wrapc file define: "matrix_o_104_V"
#define AUTOTB_TVOUT_matrix_o_104_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_104_V.dat"
#define AUTOTB_TVIN_matrix_o_104_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_104_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_104_V  "../tv/stream_size/stream_size_out_matrix_o_104_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_104_V  "../tv/stream_size/stream_egress_status_matrix_o_104_V.dat"
// wrapc file define: "matrix_o_105_V"
#define AUTOTB_TVOUT_matrix_o_105_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_105_V.dat"
#define AUTOTB_TVIN_matrix_o_105_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_105_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_105_V  "../tv/stream_size/stream_size_out_matrix_o_105_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_105_V  "../tv/stream_size/stream_egress_status_matrix_o_105_V.dat"
// wrapc file define: "matrix_o_106_V"
#define AUTOTB_TVOUT_matrix_o_106_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_106_V.dat"
#define AUTOTB_TVIN_matrix_o_106_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_106_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_106_V  "../tv/stream_size/stream_size_out_matrix_o_106_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_106_V  "../tv/stream_size/stream_egress_status_matrix_o_106_V.dat"
// wrapc file define: "matrix_o_107_V"
#define AUTOTB_TVOUT_matrix_o_107_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_107_V.dat"
#define AUTOTB_TVIN_matrix_o_107_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_107_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_107_V  "../tv/stream_size/stream_size_out_matrix_o_107_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_107_V  "../tv/stream_size/stream_egress_status_matrix_o_107_V.dat"
// wrapc file define: "matrix_o_108_V"
#define AUTOTB_TVOUT_matrix_o_108_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_108_V.dat"
#define AUTOTB_TVIN_matrix_o_108_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_108_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_108_V  "../tv/stream_size/stream_size_out_matrix_o_108_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_108_V  "../tv/stream_size/stream_egress_status_matrix_o_108_V.dat"
// wrapc file define: "matrix_o_109_V"
#define AUTOTB_TVOUT_matrix_o_109_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_109_V.dat"
#define AUTOTB_TVIN_matrix_o_109_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_109_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_109_V  "../tv/stream_size/stream_size_out_matrix_o_109_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_109_V  "../tv/stream_size/stream_egress_status_matrix_o_109_V.dat"
// wrapc file define: "matrix_o_110_V"
#define AUTOTB_TVOUT_matrix_o_110_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_110_V.dat"
#define AUTOTB_TVIN_matrix_o_110_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_110_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_110_V  "../tv/stream_size/stream_size_out_matrix_o_110_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_110_V  "../tv/stream_size/stream_egress_status_matrix_o_110_V.dat"
// wrapc file define: "matrix_o_111_V"
#define AUTOTB_TVOUT_matrix_o_111_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_111_V.dat"
#define AUTOTB_TVIN_matrix_o_111_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_111_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_111_V  "../tv/stream_size/stream_size_out_matrix_o_111_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_111_V  "../tv/stream_size/stream_egress_status_matrix_o_111_V.dat"
// wrapc file define: "matrix_o_112_V"
#define AUTOTB_TVOUT_matrix_o_112_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_112_V.dat"
#define AUTOTB_TVIN_matrix_o_112_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_112_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_112_V  "../tv/stream_size/stream_size_out_matrix_o_112_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_112_V  "../tv/stream_size/stream_egress_status_matrix_o_112_V.dat"
// wrapc file define: "matrix_o_113_V"
#define AUTOTB_TVOUT_matrix_o_113_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_113_V.dat"
#define AUTOTB_TVIN_matrix_o_113_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_113_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_113_V  "../tv/stream_size/stream_size_out_matrix_o_113_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_113_V  "../tv/stream_size/stream_egress_status_matrix_o_113_V.dat"
// wrapc file define: "matrix_o_114_V"
#define AUTOTB_TVOUT_matrix_o_114_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_114_V.dat"
#define AUTOTB_TVIN_matrix_o_114_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_114_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_114_V  "../tv/stream_size/stream_size_out_matrix_o_114_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_114_V  "../tv/stream_size/stream_egress_status_matrix_o_114_V.dat"
// wrapc file define: "matrix_o_115_V"
#define AUTOTB_TVOUT_matrix_o_115_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_115_V.dat"
#define AUTOTB_TVIN_matrix_o_115_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_115_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_115_V  "../tv/stream_size/stream_size_out_matrix_o_115_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_115_V  "../tv/stream_size/stream_egress_status_matrix_o_115_V.dat"
// wrapc file define: "matrix_o_116_V"
#define AUTOTB_TVOUT_matrix_o_116_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_116_V.dat"
#define AUTOTB_TVIN_matrix_o_116_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_116_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_116_V  "../tv/stream_size/stream_size_out_matrix_o_116_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_116_V  "../tv/stream_size/stream_egress_status_matrix_o_116_V.dat"
// wrapc file define: "matrix_o_117_V"
#define AUTOTB_TVOUT_matrix_o_117_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_117_V.dat"
#define AUTOTB_TVIN_matrix_o_117_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_117_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_117_V  "../tv/stream_size/stream_size_out_matrix_o_117_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_117_V  "../tv/stream_size/stream_egress_status_matrix_o_117_V.dat"
// wrapc file define: "matrix_o_118_V"
#define AUTOTB_TVOUT_matrix_o_118_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_118_V.dat"
#define AUTOTB_TVIN_matrix_o_118_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_118_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_118_V  "../tv/stream_size/stream_size_out_matrix_o_118_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_118_V  "../tv/stream_size/stream_egress_status_matrix_o_118_V.dat"
// wrapc file define: "matrix_o_119_V"
#define AUTOTB_TVOUT_matrix_o_119_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_119_V.dat"
#define AUTOTB_TVIN_matrix_o_119_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_119_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_119_V  "../tv/stream_size/stream_size_out_matrix_o_119_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_119_V  "../tv/stream_size/stream_egress_status_matrix_o_119_V.dat"
// wrapc file define: "matrix_o_120_V"
#define AUTOTB_TVOUT_matrix_o_120_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_120_V.dat"
#define AUTOTB_TVIN_matrix_o_120_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_120_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_120_V  "../tv/stream_size/stream_size_out_matrix_o_120_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_120_V  "../tv/stream_size/stream_egress_status_matrix_o_120_V.dat"
// wrapc file define: "matrix_o_121_V"
#define AUTOTB_TVOUT_matrix_o_121_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_121_V.dat"
#define AUTOTB_TVIN_matrix_o_121_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_121_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_121_V  "../tv/stream_size/stream_size_out_matrix_o_121_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_121_V  "../tv/stream_size/stream_egress_status_matrix_o_121_V.dat"
// wrapc file define: "matrix_o_122_V"
#define AUTOTB_TVOUT_matrix_o_122_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_122_V.dat"
#define AUTOTB_TVIN_matrix_o_122_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_122_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_122_V  "../tv/stream_size/stream_size_out_matrix_o_122_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_122_V  "../tv/stream_size/stream_egress_status_matrix_o_122_V.dat"
// wrapc file define: "matrix_o_123_V"
#define AUTOTB_TVOUT_matrix_o_123_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_123_V.dat"
#define AUTOTB_TVIN_matrix_o_123_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_123_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_123_V  "../tv/stream_size/stream_size_out_matrix_o_123_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_123_V  "../tv/stream_size/stream_egress_status_matrix_o_123_V.dat"
// wrapc file define: "matrix_o_124_V"
#define AUTOTB_TVOUT_matrix_o_124_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_124_V.dat"
#define AUTOTB_TVIN_matrix_o_124_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_124_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_124_V  "../tv/stream_size/stream_size_out_matrix_o_124_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_124_V  "../tv/stream_size/stream_egress_status_matrix_o_124_V.dat"
// wrapc file define: "matrix_o_125_V"
#define AUTOTB_TVOUT_matrix_o_125_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_125_V.dat"
#define AUTOTB_TVIN_matrix_o_125_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_125_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_125_V  "../tv/stream_size/stream_size_out_matrix_o_125_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_125_V  "../tv/stream_size/stream_egress_status_matrix_o_125_V.dat"
// wrapc file define: "matrix_o_126_V"
#define AUTOTB_TVOUT_matrix_o_126_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_126_V.dat"
#define AUTOTB_TVIN_matrix_o_126_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_126_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_126_V  "../tv/stream_size/stream_size_out_matrix_o_126_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_126_V  "../tv/stream_size/stream_egress_status_matrix_o_126_V.dat"
// wrapc file define: "matrix_o_127_V"
#define AUTOTB_TVOUT_matrix_o_127_V  "../tv/cdatafile/c.fire2.autotvout_matrix_o_127_V.dat"
#define AUTOTB_TVIN_matrix_o_127_V  "../tv/cdatafile/c.fire2.autotvin_matrix_o_127_V.dat"
#define WRAPC_STREAM_SIZE_OUT_matrix_o_127_V  "../tv/stream_size/stream_size_out_matrix_o_127_V.dat"
#define WRAPC_STREAM_EGRESS_STATUS_matrix_o_127_V  "../tv/stream_size/stream_egress_status_matrix_o_127_V.dat"

#define INTER_TCL  "../tv/cdatafile/ref.tcl"

// tvout file define: "matrix_o_0_V"
#define AUTOTB_TVOUT_PC_matrix_o_0_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_0_V.dat"
// tvout file define: "matrix_o_1_V"
#define AUTOTB_TVOUT_PC_matrix_o_1_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_1_V.dat"
// tvout file define: "matrix_o_2_V"
#define AUTOTB_TVOUT_PC_matrix_o_2_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_2_V.dat"
// tvout file define: "matrix_o_3_V"
#define AUTOTB_TVOUT_PC_matrix_o_3_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_3_V.dat"
// tvout file define: "matrix_o_4_V"
#define AUTOTB_TVOUT_PC_matrix_o_4_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_4_V.dat"
// tvout file define: "matrix_o_5_V"
#define AUTOTB_TVOUT_PC_matrix_o_5_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_5_V.dat"
// tvout file define: "matrix_o_6_V"
#define AUTOTB_TVOUT_PC_matrix_o_6_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_6_V.dat"
// tvout file define: "matrix_o_7_V"
#define AUTOTB_TVOUT_PC_matrix_o_7_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_7_V.dat"
// tvout file define: "matrix_o_8_V"
#define AUTOTB_TVOUT_PC_matrix_o_8_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_8_V.dat"
// tvout file define: "matrix_o_9_V"
#define AUTOTB_TVOUT_PC_matrix_o_9_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_9_V.dat"
// tvout file define: "matrix_o_10_V"
#define AUTOTB_TVOUT_PC_matrix_o_10_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_10_V.dat"
// tvout file define: "matrix_o_11_V"
#define AUTOTB_TVOUT_PC_matrix_o_11_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_11_V.dat"
// tvout file define: "matrix_o_12_V"
#define AUTOTB_TVOUT_PC_matrix_o_12_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_12_V.dat"
// tvout file define: "matrix_o_13_V"
#define AUTOTB_TVOUT_PC_matrix_o_13_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_13_V.dat"
// tvout file define: "matrix_o_14_V"
#define AUTOTB_TVOUT_PC_matrix_o_14_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_14_V.dat"
// tvout file define: "matrix_o_15_V"
#define AUTOTB_TVOUT_PC_matrix_o_15_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_15_V.dat"
// tvout file define: "matrix_o_16_V"
#define AUTOTB_TVOUT_PC_matrix_o_16_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_16_V.dat"
// tvout file define: "matrix_o_17_V"
#define AUTOTB_TVOUT_PC_matrix_o_17_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_17_V.dat"
// tvout file define: "matrix_o_18_V"
#define AUTOTB_TVOUT_PC_matrix_o_18_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_18_V.dat"
// tvout file define: "matrix_o_19_V"
#define AUTOTB_TVOUT_PC_matrix_o_19_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_19_V.dat"
// tvout file define: "matrix_o_20_V"
#define AUTOTB_TVOUT_PC_matrix_o_20_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_20_V.dat"
// tvout file define: "matrix_o_21_V"
#define AUTOTB_TVOUT_PC_matrix_o_21_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_21_V.dat"
// tvout file define: "matrix_o_22_V"
#define AUTOTB_TVOUT_PC_matrix_o_22_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_22_V.dat"
// tvout file define: "matrix_o_23_V"
#define AUTOTB_TVOUT_PC_matrix_o_23_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_23_V.dat"
// tvout file define: "matrix_o_24_V"
#define AUTOTB_TVOUT_PC_matrix_o_24_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_24_V.dat"
// tvout file define: "matrix_o_25_V"
#define AUTOTB_TVOUT_PC_matrix_o_25_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_25_V.dat"
// tvout file define: "matrix_o_26_V"
#define AUTOTB_TVOUT_PC_matrix_o_26_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_26_V.dat"
// tvout file define: "matrix_o_27_V"
#define AUTOTB_TVOUT_PC_matrix_o_27_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_27_V.dat"
// tvout file define: "matrix_o_28_V"
#define AUTOTB_TVOUT_PC_matrix_o_28_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_28_V.dat"
// tvout file define: "matrix_o_29_V"
#define AUTOTB_TVOUT_PC_matrix_o_29_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_29_V.dat"
// tvout file define: "matrix_o_30_V"
#define AUTOTB_TVOUT_PC_matrix_o_30_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_30_V.dat"
// tvout file define: "matrix_o_31_V"
#define AUTOTB_TVOUT_PC_matrix_o_31_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_31_V.dat"
// tvout file define: "matrix_o_32_V"
#define AUTOTB_TVOUT_PC_matrix_o_32_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_32_V.dat"
// tvout file define: "matrix_o_33_V"
#define AUTOTB_TVOUT_PC_matrix_o_33_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_33_V.dat"
// tvout file define: "matrix_o_34_V"
#define AUTOTB_TVOUT_PC_matrix_o_34_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_34_V.dat"
// tvout file define: "matrix_o_35_V"
#define AUTOTB_TVOUT_PC_matrix_o_35_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_35_V.dat"
// tvout file define: "matrix_o_36_V"
#define AUTOTB_TVOUT_PC_matrix_o_36_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_36_V.dat"
// tvout file define: "matrix_o_37_V"
#define AUTOTB_TVOUT_PC_matrix_o_37_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_37_V.dat"
// tvout file define: "matrix_o_38_V"
#define AUTOTB_TVOUT_PC_matrix_o_38_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_38_V.dat"
// tvout file define: "matrix_o_39_V"
#define AUTOTB_TVOUT_PC_matrix_o_39_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_39_V.dat"
// tvout file define: "matrix_o_40_V"
#define AUTOTB_TVOUT_PC_matrix_o_40_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_40_V.dat"
// tvout file define: "matrix_o_41_V"
#define AUTOTB_TVOUT_PC_matrix_o_41_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_41_V.dat"
// tvout file define: "matrix_o_42_V"
#define AUTOTB_TVOUT_PC_matrix_o_42_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_42_V.dat"
// tvout file define: "matrix_o_43_V"
#define AUTOTB_TVOUT_PC_matrix_o_43_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_43_V.dat"
// tvout file define: "matrix_o_44_V"
#define AUTOTB_TVOUT_PC_matrix_o_44_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_44_V.dat"
// tvout file define: "matrix_o_45_V"
#define AUTOTB_TVOUT_PC_matrix_o_45_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_45_V.dat"
// tvout file define: "matrix_o_46_V"
#define AUTOTB_TVOUT_PC_matrix_o_46_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_46_V.dat"
// tvout file define: "matrix_o_47_V"
#define AUTOTB_TVOUT_PC_matrix_o_47_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_47_V.dat"
// tvout file define: "matrix_o_48_V"
#define AUTOTB_TVOUT_PC_matrix_o_48_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_48_V.dat"
// tvout file define: "matrix_o_49_V"
#define AUTOTB_TVOUT_PC_matrix_o_49_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_49_V.dat"
// tvout file define: "matrix_o_50_V"
#define AUTOTB_TVOUT_PC_matrix_o_50_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_50_V.dat"
// tvout file define: "matrix_o_51_V"
#define AUTOTB_TVOUT_PC_matrix_o_51_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_51_V.dat"
// tvout file define: "matrix_o_52_V"
#define AUTOTB_TVOUT_PC_matrix_o_52_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_52_V.dat"
// tvout file define: "matrix_o_53_V"
#define AUTOTB_TVOUT_PC_matrix_o_53_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_53_V.dat"
// tvout file define: "matrix_o_54_V"
#define AUTOTB_TVOUT_PC_matrix_o_54_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_54_V.dat"
// tvout file define: "matrix_o_55_V"
#define AUTOTB_TVOUT_PC_matrix_o_55_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_55_V.dat"
// tvout file define: "matrix_o_56_V"
#define AUTOTB_TVOUT_PC_matrix_o_56_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_56_V.dat"
// tvout file define: "matrix_o_57_V"
#define AUTOTB_TVOUT_PC_matrix_o_57_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_57_V.dat"
// tvout file define: "matrix_o_58_V"
#define AUTOTB_TVOUT_PC_matrix_o_58_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_58_V.dat"
// tvout file define: "matrix_o_59_V"
#define AUTOTB_TVOUT_PC_matrix_o_59_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_59_V.dat"
// tvout file define: "matrix_o_60_V"
#define AUTOTB_TVOUT_PC_matrix_o_60_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_60_V.dat"
// tvout file define: "matrix_o_61_V"
#define AUTOTB_TVOUT_PC_matrix_o_61_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_61_V.dat"
// tvout file define: "matrix_o_62_V"
#define AUTOTB_TVOUT_PC_matrix_o_62_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_62_V.dat"
// tvout file define: "matrix_o_63_V"
#define AUTOTB_TVOUT_PC_matrix_o_63_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_63_V.dat"
// tvout file define: "matrix_o_64_V"
#define AUTOTB_TVOUT_PC_matrix_o_64_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_64_V.dat"
// tvout file define: "matrix_o_65_V"
#define AUTOTB_TVOUT_PC_matrix_o_65_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_65_V.dat"
// tvout file define: "matrix_o_66_V"
#define AUTOTB_TVOUT_PC_matrix_o_66_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_66_V.dat"
// tvout file define: "matrix_o_67_V"
#define AUTOTB_TVOUT_PC_matrix_o_67_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_67_V.dat"
// tvout file define: "matrix_o_68_V"
#define AUTOTB_TVOUT_PC_matrix_o_68_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_68_V.dat"
// tvout file define: "matrix_o_69_V"
#define AUTOTB_TVOUT_PC_matrix_o_69_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_69_V.dat"
// tvout file define: "matrix_o_70_V"
#define AUTOTB_TVOUT_PC_matrix_o_70_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_70_V.dat"
// tvout file define: "matrix_o_71_V"
#define AUTOTB_TVOUT_PC_matrix_o_71_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_71_V.dat"
// tvout file define: "matrix_o_72_V"
#define AUTOTB_TVOUT_PC_matrix_o_72_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_72_V.dat"
// tvout file define: "matrix_o_73_V"
#define AUTOTB_TVOUT_PC_matrix_o_73_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_73_V.dat"
// tvout file define: "matrix_o_74_V"
#define AUTOTB_TVOUT_PC_matrix_o_74_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_74_V.dat"
// tvout file define: "matrix_o_75_V"
#define AUTOTB_TVOUT_PC_matrix_o_75_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_75_V.dat"
// tvout file define: "matrix_o_76_V"
#define AUTOTB_TVOUT_PC_matrix_o_76_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_76_V.dat"
// tvout file define: "matrix_o_77_V"
#define AUTOTB_TVOUT_PC_matrix_o_77_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_77_V.dat"
// tvout file define: "matrix_o_78_V"
#define AUTOTB_TVOUT_PC_matrix_o_78_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_78_V.dat"
// tvout file define: "matrix_o_79_V"
#define AUTOTB_TVOUT_PC_matrix_o_79_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_79_V.dat"
// tvout file define: "matrix_o_80_V"
#define AUTOTB_TVOUT_PC_matrix_o_80_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_80_V.dat"
// tvout file define: "matrix_o_81_V"
#define AUTOTB_TVOUT_PC_matrix_o_81_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_81_V.dat"
// tvout file define: "matrix_o_82_V"
#define AUTOTB_TVOUT_PC_matrix_o_82_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_82_V.dat"
// tvout file define: "matrix_o_83_V"
#define AUTOTB_TVOUT_PC_matrix_o_83_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_83_V.dat"
// tvout file define: "matrix_o_84_V"
#define AUTOTB_TVOUT_PC_matrix_o_84_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_84_V.dat"
// tvout file define: "matrix_o_85_V"
#define AUTOTB_TVOUT_PC_matrix_o_85_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_85_V.dat"
// tvout file define: "matrix_o_86_V"
#define AUTOTB_TVOUT_PC_matrix_o_86_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_86_V.dat"
// tvout file define: "matrix_o_87_V"
#define AUTOTB_TVOUT_PC_matrix_o_87_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_87_V.dat"
// tvout file define: "matrix_o_88_V"
#define AUTOTB_TVOUT_PC_matrix_o_88_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_88_V.dat"
// tvout file define: "matrix_o_89_V"
#define AUTOTB_TVOUT_PC_matrix_o_89_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_89_V.dat"
// tvout file define: "matrix_o_90_V"
#define AUTOTB_TVOUT_PC_matrix_o_90_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_90_V.dat"
// tvout file define: "matrix_o_91_V"
#define AUTOTB_TVOUT_PC_matrix_o_91_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_91_V.dat"
// tvout file define: "matrix_o_92_V"
#define AUTOTB_TVOUT_PC_matrix_o_92_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_92_V.dat"
// tvout file define: "matrix_o_93_V"
#define AUTOTB_TVOUT_PC_matrix_o_93_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_93_V.dat"
// tvout file define: "matrix_o_94_V"
#define AUTOTB_TVOUT_PC_matrix_o_94_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_94_V.dat"
// tvout file define: "matrix_o_95_V"
#define AUTOTB_TVOUT_PC_matrix_o_95_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_95_V.dat"
// tvout file define: "matrix_o_96_V"
#define AUTOTB_TVOUT_PC_matrix_o_96_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_96_V.dat"
// tvout file define: "matrix_o_97_V"
#define AUTOTB_TVOUT_PC_matrix_o_97_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_97_V.dat"
// tvout file define: "matrix_o_98_V"
#define AUTOTB_TVOUT_PC_matrix_o_98_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_98_V.dat"
// tvout file define: "matrix_o_99_V"
#define AUTOTB_TVOUT_PC_matrix_o_99_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_99_V.dat"
// tvout file define: "matrix_o_100_V"
#define AUTOTB_TVOUT_PC_matrix_o_100_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_100_V.dat"
// tvout file define: "matrix_o_101_V"
#define AUTOTB_TVOUT_PC_matrix_o_101_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_101_V.dat"
// tvout file define: "matrix_o_102_V"
#define AUTOTB_TVOUT_PC_matrix_o_102_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_102_V.dat"
// tvout file define: "matrix_o_103_V"
#define AUTOTB_TVOUT_PC_matrix_o_103_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_103_V.dat"
// tvout file define: "matrix_o_104_V"
#define AUTOTB_TVOUT_PC_matrix_o_104_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_104_V.dat"
// tvout file define: "matrix_o_105_V"
#define AUTOTB_TVOUT_PC_matrix_o_105_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_105_V.dat"
// tvout file define: "matrix_o_106_V"
#define AUTOTB_TVOUT_PC_matrix_o_106_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_106_V.dat"
// tvout file define: "matrix_o_107_V"
#define AUTOTB_TVOUT_PC_matrix_o_107_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_107_V.dat"
// tvout file define: "matrix_o_108_V"
#define AUTOTB_TVOUT_PC_matrix_o_108_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_108_V.dat"
// tvout file define: "matrix_o_109_V"
#define AUTOTB_TVOUT_PC_matrix_o_109_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_109_V.dat"
// tvout file define: "matrix_o_110_V"
#define AUTOTB_TVOUT_PC_matrix_o_110_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_110_V.dat"
// tvout file define: "matrix_o_111_V"
#define AUTOTB_TVOUT_PC_matrix_o_111_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_111_V.dat"
// tvout file define: "matrix_o_112_V"
#define AUTOTB_TVOUT_PC_matrix_o_112_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_112_V.dat"
// tvout file define: "matrix_o_113_V"
#define AUTOTB_TVOUT_PC_matrix_o_113_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_113_V.dat"
// tvout file define: "matrix_o_114_V"
#define AUTOTB_TVOUT_PC_matrix_o_114_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_114_V.dat"
// tvout file define: "matrix_o_115_V"
#define AUTOTB_TVOUT_PC_matrix_o_115_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_115_V.dat"
// tvout file define: "matrix_o_116_V"
#define AUTOTB_TVOUT_PC_matrix_o_116_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_116_V.dat"
// tvout file define: "matrix_o_117_V"
#define AUTOTB_TVOUT_PC_matrix_o_117_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_117_V.dat"
// tvout file define: "matrix_o_118_V"
#define AUTOTB_TVOUT_PC_matrix_o_118_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_118_V.dat"
// tvout file define: "matrix_o_119_V"
#define AUTOTB_TVOUT_PC_matrix_o_119_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_119_V.dat"
// tvout file define: "matrix_o_120_V"
#define AUTOTB_TVOUT_PC_matrix_o_120_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_120_V.dat"
// tvout file define: "matrix_o_121_V"
#define AUTOTB_TVOUT_PC_matrix_o_121_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_121_V.dat"
// tvout file define: "matrix_o_122_V"
#define AUTOTB_TVOUT_PC_matrix_o_122_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_122_V.dat"
// tvout file define: "matrix_o_123_V"
#define AUTOTB_TVOUT_PC_matrix_o_123_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_123_V.dat"
// tvout file define: "matrix_o_124_V"
#define AUTOTB_TVOUT_PC_matrix_o_124_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_124_V.dat"
// tvout file define: "matrix_o_125_V"
#define AUTOTB_TVOUT_PC_matrix_o_125_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_125_V.dat"
// tvout file define: "matrix_o_126_V"
#define AUTOTB_TVOUT_PC_matrix_o_126_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_126_V.dat"
// tvout file define: "matrix_o_127_V"
#define AUTOTB_TVOUT_PC_matrix_o_127_V  "../tv/rtldatafile/rtl.fire2.autotvout_matrix_o_127_V.dat"

class INTER_TCL_FILE {
	public:
		INTER_TCL_FILE(const char* name) {
			mName = name;
			matrix_i_0_V_depth = 0;
			matrix_i_1_V_depth = 0;
			matrix_i_2_V_depth = 0;
			matrix_i_3_V_depth = 0;
			matrix_i_4_V_depth = 0;
			matrix_i_5_V_depth = 0;
			matrix_i_6_V_depth = 0;
			matrix_i_7_V_depth = 0;
			matrix_i_8_V_depth = 0;
			matrix_i_9_V_depth = 0;
			matrix_i_10_V_depth = 0;
			matrix_i_11_V_depth = 0;
			matrix_i_12_V_depth = 0;
			matrix_i_13_V_depth = 0;
			matrix_i_14_V_depth = 0;
			matrix_i_15_V_depth = 0;
			matrix_i_16_V_depth = 0;
			matrix_i_17_V_depth = 0;
			matrix_i_18_V_depth = 0;
			matrix_i_19_V_depth = 0;
			matrix_i_20_V_depth = 0;
			matrix_i_21_V_depth = 0;
			matrix_i_22_V_depth = 0;
			matrix_i_23_V_depth = 0;
			matrix_i_24_V_depth = 0;
			matrix_i_25_V_depth = 0;
			matrix_i_26_V_depth = 0;
			matrix_i_27_V_depth = 0;
			matrix_i_28_V_depth = 0;
			matrix_i_29_V_depth = 0;
			matrix_i_30_V_depth = 0;
			matrix_i_31_V_depth = 0;
			matrix_i_32_V_depth = 0;
			matrix_i_33_V_depth = 0;
			matrix_i_34_V_depth = 0;
			matrix_i_35_V_depth = 0;
			matrix_i_36_V_depth = 0;
			matrix_i_37_V_depth = 0;
			matrix_i_38_V_depth = 0;
			matrix_i_39_V_depth = 0;
			matrix_i_40_V_depth = 0;
			matrix_i_41_V_depth = 0;
			matrix_i_42_V_depth = 0;
			matrix_i_43_V_depth = 0;
			matrix_i_44_V_depth = 0;
			matrix_i_45_V_depth = 0;
			matrix_i_46_V_depth = 0;
			matrix_i_47_V_depth = 0;
			matrix_i_48_V_depth = 0;
			matrix_i_49_V_depth = 0;
			matrix_i_50_V_depth = 0;
			matrix_i_51_V_depth = 0;
			matrix_i_52_V_depth = 0;
			matrix_i_53_V_depth = 0;
			matrix_i_54_V_depth = 0;
			matrix_i_55_V_depth = 0;
			matrix_i_56_V_depth = 0;
			matrix_i_57_V_depth = 0;
			matrix_i_58_V_depth = 0;
			matrix_i_59_V_depth = 0;
			matrix_i_60_V_depth = 0;
			matrix_i_61_V_depth = 0;
			matrix_i_62_V_depth = 0;
			matrix_i_63_V_depth = 0;
			matrix_i_64_V_depth = 0;
			matrix_i_65_V_depth = 0;
			matrix_i_66_V_depth = 0;
			matrix_i_67_V_depth = 0;
			matrix_i_68_V_depth = 0;
			matrix_i_69_V_depth = 0;
			matrix_i_70_V_depth = 0;
			matrix_i_71_V_depth = 0;
			matrix_i_72_V_depth = 0;
			matrix_i_73_V_depth = 0;
			matrix_i_74_V_depth = 0;
			matrix_i_75_V_depth = 0;
			matrix_i_76_V_depth = 0;
			matrix_i_77_V_depth = 0;
			matrix_i_78_V_depth = 0;
			matrix_i_79_V_depth = 0;
			matrix_i_80_V_depth = 0;
			matrix_i_81_V_depth = 0;
			matrix_i_82_V_depth = 0;
			matrix_i_83_V_depth = 0;
			matrix_i_84_V_depth = 0;
			matrix_i_85_V_depth = 0;
			matrix_i_86_V_depth = 0;
			matrix_i_87_V_depth = 0;
			matrix_i_88_V_depth = 0;
			matrix_i_89_V_depth = 0;
			matrix_i_90_V_depth = 0;
			matrix_i_91_V_depth = 0;
			matrix_i_92_V_depth = 0;
			matrix_i_93_V_depth = 0;
			matrix_i_94_V_depth = 0;
			matrix_i_95_V_depth = 0;
			kernel_s1x1_depth = 0;
			kernel_e1x1_depth = 0;
			kernel_e3x3_depth = 0;
			matrix_o_0_V_depth = 0;
			matrix_o_1_V_depth = 0;
			matrix_o_2_V_depth = 0;
			matrix_o_3_V_depth = 0;
			matrix_o_4_V_depth = 0;
			matrix_o_5_V_depth = 0;
			matrix_o_6_V_depth = 0;
			matrix_o_7_V_depth = 0;
			matrix_o_8_V_depth = 0;
			matrix_o_9_V_depth = 0;
			matrix_o_10_V_depth = 0;
			matrix_o_11_V_depth = 0;
			matrix_o_12_V_depth = 0;
			matrix_o_13_V_depth = 0;
			matrix_o_14_V_depth = 0;
			matrix_o_15_V_depth = 0;
			matrix_o_16_V_depth = 0;
			matrix_o_17_V_depth = 0;
			matrix_o_18_V_depth = 0;
			matrix_o_19_V_depth = 0;
			matrix_o_20_V_depth = 0;
			matrix_o_21_V_depth = 0;
			matrix_o_22_V_depth = 0;
			matrix_o_23_V_depth = 0;
			matrix_o_24_V_depth = 0;
			matrix_o_25_V_depth = 0;
			matrix_o_26_V_depth = 0;
			matrix_o_27_V_depth = 0;
			matrix_o_28_V_depth = 0;
			matrix_o_29_V_depth = 0;
			matrix_o_30_V_depth = 0;
			matrix_o_31_V_depth = 0;
			matrix_o_32_V_depth = 0;
			matrix_o_33_V_depth = 0;
			matrix_o_34_V_depth = 0;
			matrix_o_35_V_depth = 0;
			matrix_o_36_V_depth = 0;
			matrix_o_37_V_depth = 0;
			matrix_o_38_V_depth = 0;
			matrix_o_39_V_depth = 0;
			matrix_o_40_V_depth = 0;
			matrix_o_41_V_depth = 0;
			matrix_o_42_V_depth = 0;
			matrix_o_43_V_depth = 0;
			matrix_o_44_V_depth = 0;
			matrix_o_45_V_depth = 0;
			matrix_o_46_V_depth = 0;
			matrix_o_47_V_depth = 0;
			matrix_o_48_V_depth = 0;
			matrix_o_49_V_depth = 0;
			matrix_o_50_V_depth = 0;
			matrix_o_51_V_depth = 0;
			matrix_o_52_V_depth = 0;
			matrix_o_53_V_depth = 0;
			matrix_o_54_V_depth = 0;
			matrix_o_55_V_depth = 0;
			matrix_o_56_V_depth = 0;
			matrix_o_57_V_depth = 0;
			matrix_o_58_V_depth = 0;
			matrix_o_59_V_depth = 0;
			matrix_o_60_V_depth = 0;
			matrix_o_61_V_depth = 0;
			matrix_o_62_V_depth = 0;
			matrix_o_63_V_depth = 0;
			matrix_o_64_V_depth = 0;
			matrix_o_65_V_depth = 0;
			matrix_o_66_V_depth = 0;
			matrix_o_67_V_depth = 0;
			matrix_o_68_V_depth = 0;
			matrix_o_69_V_depth = 0;
			matrix_o_70_V_depth = 0;
			matrix_o_71_V_depth = 0;
			matrix_o_72_V_depth = 0;
			matrix_o_73_V_depth = 0;
			matrix_o_74_V_depth = 0;
			matrix_o_75_V_depth = 0;
			matrix_o_76_V_depth = 0;
			matrix_o_77_V_depth = 0;
			matrix_o_78_V_depth = 0;
			matrix_o_79_V_depth = 0;
			matrix_o_80_V_depth = 0;
			matrix_o_81_V_depth = 0;
			matrix_o_82_V_depth = 0;
			matrix_o_83_V_depth = 0;
			matrix_o_84_V_depth = 0;
			matrix_o_85_V_depth = 0;
			matrix_o_86_V_depth = 0;
			matrix_o_87_V_depth = 0;
			matrix_o_88_V_depth = 0;
			matrix_o_89_V_depth = 0;
			matrix_o_90_V_depth = 0;
			matrix_o_91_V_depth = 0;
			matrix_o_92_V_depth = 0;
			matrix_o_93_V_depth = 0;
			matrix_o_94_V_depth = 0;
			matrix_o_95_V_depth = 0;
			matrix_o_96_V_depth = 0;
			matrix_o_97_V_depth = 0;
			matrix_o_98_V_depth = 0;
			matrix_o_99_V_depth = 0;
			matrix_o_100_V_depth = 0;
			matrix_o_101_V_depth = 0;
			matrix_o_102_V_depth = 0;
			matrix_o_103_V_depth = 0;
			matrix_o_104_V_depth = 0;
			matrix_o_105_V_depth = 0;
			matrix_o_106_V_depth = 0;
			matrix_o_107_V_depth = 0;
			matrix_o_108_V_depth = 0;
			matrix_o_109_V_depth = 0;
			matrix_o_110_V_depth = 0;
			matrix_o_111_V_depth = 0;
			matrix_o_112_V_depth = 0;
			matrix_o_113_V_depth = 0;
			matrix_o_114_V_depth = 0;
			matrix_o_115_V_depth = 0;
			matrix_o_116_V_depth = 0;
			matrix_o_117_V_depth = 0;
			matrix_o_118_V_depth = 0;
			matrix_o_119_V_depth = 0;
			matrix_o_120_V_depth = 0;
			matrix_o_121_V_depth = 0;
			matrix_o_122_V_depth = 0;
			matrix_o_123_V_depth = 0;
			matrix_o_124_V_depth = 0;
			matrix_o_125_V_depth = 0;
			matrix_o_126_V_depth = 0;
			matrix_o_127_V_depth = 0;
			trans_num =0;
		}

		~INTER_TCL_FILE() {
			mFile.open(mName);
			if (!mFile.good()) {
				cout << "Failed to open file ref.tcl" << endl;
				exit (1);
			}
			string total_list = get_depth_list();
			mFile << "set depth_list {\n";
			mFile << total_list;
			mFile << "}\n";
			mFile << "set trans_num "<<trans_num<<endl;
			mFile.close();
		}

		string get_depth_list () {
			stringstream total_list;
			total_list << "{matrix_i_0_V " << matrix_i_0_V_depth << "}\n";
			total_list << "{matrix_i_1_V " << matrix_i_1_V_depth << "}\n";
			total_list << "{matrix_i_2_V " << matrix_i_2_V_depth << "}\n";
			total_list << "{matrix_i_3_V " << matrix_i_3_V_depth << "}\n";
			total_list << "{matrix_i_4_V " << matrix_i_4_V_depth << "}\n";
			total_list << "{matrix_i_5_V " << matrix_i_5_V_depth << "}\n";
			total_list << "{matrix_i_6_V " << matrix_i_6_V_depth << "}\n";
			total_list << "{matrix_i_7_V " << matrix_i_7_V_depth << "}\n";
			total_list << "{matrix_i_8_V " << matrix_i_8_V_depth << "}\n";
			total_list << "{matrix_i_9_V " << matrix_i_9_V_depth << "}\n";
			total_list << "{matrix_i_10_V " << matrix_i_10_V_depth << "}\n";
			total_list << "{matrix_i_11_V " << matrix_i_11_V_depth << "}\n";
			total_list << "{matrix_i_12_V " << matrix_i_12_V_depth << "}\n";
			total_list << "{matrix_i_13_V " << matrix_i_13_V_depth << "}\n";
			total_list << "{matrix_i_14_V " << matrix_i_14_V_depth << "}\n";
			total_list << "{matrix_i_15_V " << matrix_i_15_V_depth << "}\n";
			total_list << "{matrix_i_16_V " << matrix_i_16_V_depth << "}\n";
			total_list << "{matrix_i_17_V " << matrix_i_17_V_depth << "}\n";
			total_list << "{matrix_i_18_V " << matrix_i_18_V_depth << "}\n";
			total_list << "{matrix_i_19_V " << matrix_i_19_V_depth << "}\n";
			total_list << "{matrix_i_20_V " << matrix_i_20_V_depth << "}\n";
			total_list << "{matrix_i_21_V " << matrix_i_21_V_depth << "}\n";
			total_list << "{matrix_i_22_V " << matrix_i_22_V_depth << "}\n";
			total_list << "{matrix_i_23_V " << matrix_i_23_V_depth << "}\n";
			total_list << "{matrix_i_24_V " << matrix_i_24_V_depth << "}\n";
			total_list << "{matrix_i_25_V " << matrix_i_25_V_depth << "}\n";
			total_list << "{matrix_i_26_V " << matrix_i_26_V_depth << "}\n";
			total_list << "{matrix_i_27_V " << matrix_i_27_V_depth << "}\n";
			total_list << "{matrix_i_28_V " << matrix_i_28_V_depth << "}\n";
			total_list << "{matrix_i_29_V " << matrix_i_29_V_depth << "}\n";
			total_list << "{matrix_i_30_V " << matrix_i_30_V_depth << "}\n";
			total_list << "{matrix_i_31_V " << matrix_i_31_V_depth << "}\n";
			total_list << "{matrix_i_32_V " << matrix_i_32_V_depth << "}\n";
			total_list << "{matrix_i_33_V " << matrix_i_33_V_depth << "}\n";
			total_list << "{matrix_i_34_V " << matrix_i_34_V_depth << "}\n";
			total_list << "{matrix_i_35_V " << matrix_i_35_V_depth << "}\n";
			total_list << "{matrix_i_36_V " << matrix_i_36_V_depth << "}\n";
			total_list << "{matrix_i_37_V " << matrix_i_37_V_depth << "}\n";
			total_list << "{matrix_i_38_V " << matrix_i_38_V_depth << "}\n";
			total_list << "{matrix_i_39_V " << matrix_i_39_V_depth << "}\n";
			total_list << "{matrix_i_40_V " << matrix_i_40_V_depth << "}\n";
			total_list << "{matrix_i_41_V " << matrix_i_41_V_depth << "}\n";
			total_list << "{matrix_i_42_V " << matrix_i_42_V_depth << "}\n";
			total_list << "{matrix_i_43_V " << matrix_i_43_V_depth << "}\n";
			total_list << "{matrix_i_44_V " << matrix_i_44_V_depth << "}\n";
			total_list << "{matrix_i_45_V " << matrix_i_45_V_depth << "}\n";
			total_list << "{matrix_i_46_V " << matrix_i_46_V_depth << "}\n";
			total_list << "{matrix_i_47_V " << matrix_i_47_V_depth << "}\n";
			total_list << "{matrix_i_48_V " << matrix_i_48_V_depth << "}\n";
			total_list << "{matrix_i_49_V " << matrix_i_49_V_depth << "}\n";
			total_list << "{matrix_i_50_V " << matrix_i_50_V_depth << "}\n";
			total_list << "{matrix_i_51_V " << matrix_i_51_V_depth << "}\n";
			total_list << "{matrix_i_52_V " << matrix_i_52_V_depth << "}\n";
			total_list << "{matrix_i_53_V " << matrix_i_53_V_depth << "}\n";
			total_list << "{matrix_i_54_V " << matrix_i_54_V_depth << "}\n";
			total_list << "{matrix_i_55_V " << matrix_i_55_V_depth << "}\n";
			total_list << "{matrix_i_56_V " << matrix_i_56_V_depth << "}\n";
			total_list << "{matrix_i_57_V " << matrix_i_57_V_depth << "}\n";
			total_list << "{matrix_i_58_V " << matrix_i_58_V_depth << "}\n";
			total_list << "{matrix_i_59_V " << matrix_i_59_V_depth << "}\n";
			total_list << "{matrix_i_60_V " << matrix_i_60_V_depth << "}\n";
			total_list << "{matrix_i_61_V " << matrix_i_61_V_depth << "}\n";
			total_list << "{matrix_i_62_V " << matrix_i_62_V_depth << "}\n";
			total_list << "{matrix_i_63_V " << matrix_i_63_V_depth << "}\n";
			total_list << "{matrix_i_64_V " << matrix_i_64_V_depth << "}\n";
			total_list << "{matrix_i_65_V " << matrix_i_65_V_depth << "}\n";
			total_list << "{matrix_i_66_V " << matrix_i_66_V_depth << "}\n";
			total_list << "{matrix_i_67_V " << matrix_i_67_V_depth << "}\n";
			total_list << "{matrix_i_68_V " << matrix_i_68_V_depth << "}\n";
			total_list << "{matrix_i_69_V " << matrix_i_69_V_depth << "}\n";
			total_list << "{matrix_i_70_V " << matrix_i_70_V_depth << "}\n";
			total_list << "{matrix_i_71_V " << matrix_i_71_V_depth << "}\n";
			total_list << "{matrix_i_72_V " << matrix_i_72_V_depth << "}\n";
			total_list << "{matrix_i_73_V " << matrix_i_73_V_depth << "}\n";
			total_list << "{matrix_i_74_V " << matrix_i_74_V_depth << "}\n";
			total_list << "{matrix_i_75_V " << matrix_i_75_V_depth << "}\n";
			total_list << "{matrix_i_76_V " << matrix_i_76_V_depth << "}\n";
			total_list << "{matrix_i_77_V " << matrix_i_77_V_depth << "}\n";
			total_list << "{matrix_i_78_V " << matrix_i_78_V_depth << "}\n";
			total_list << "{matrix_i_79_V " << matrix_i_79_V_depth << "}\n";
			total_list << "{matrix_i_80_V " << matrix_i_80_V_depth << "}\n";
			total_list << "{matrix_i_81_V " << matrix_i_81_V_depth << "}\n";
			total_list << "{matrix_i_82_V " << matrix_i_82_V_depth << "}\n";
			total_list << "{matrix_i_83_V " << matrix_i_83_V_depth << "}\n";
			total_list << "{matrix_i_84_V " << matrix_i_84_V_depth << "}\n";
			total_list << "{matrix_i_85_V " << matrix_i_85_V_depth << "}\n";
			total_list << "{matrix_i_86_V " << matrix_i_86_V_depth << "}\n";
			total_list << "{matrix_i_87_V " << matrix_i_87_V_depth << "}\n";
			total_list << "{matrix_i_88_V " << matrix_i_88_V_depth << "}\n";
			total_list << "{matrix_i_89_V " << matrix_i_89_V_depth << "}\n";
			total_list << "{matrix_i_90_V " << matrix_i_90_V_depth << "}\n";
			total_list << "{matrix_i_91_V " << matrix_i_91_V_depth << "}\n";
			total_list << "{matrix_i_92_V " << matrix_i_92_V_depth << "}\n";
			total_list << "{matrix_i_93_V " << matrix_i_93_V_depth << "}\n";
			total_list << "{matrix_i_94_V " << matrix_i_94_V_depth << "}\n";
			total_list << "{matrix_i_95_V " << matrix_i_95_V_depth << "}\n";
			total_list << "{kernel_s1x1 " << kernel_s1x1_depth << "}\n";
			total_list << "{kernel_e1x1 " << kernel_e1x1_depth << "}\n";
			total_list << "{kernel_e3x3 " << kernel_e3x3_depth << "}\n";
			total_list << "{matrix_o_0_V " << matrix_o_0_V_depth << "}\n";
			total_list << "{matrix_o_1_V " << matrix_o_1_V_depth << "}\n";
			total_list << "{matrix_o_2_V " << matrix_o_2_V_depth << "}\n";
			total_list << "{matrix_o_3_V " << matrix_o_3_V_depth << "}\n";
			total_list << "{matrix_o_4_V " << matrix_o_4_V_depth << "}\n";
			total_list << "{matrix_o_5_V " << matrix_o_5_V_depth << "}\n";
			total_list << "{matrix_o_6_V " << matrix_o_6_V_depth << "}\n";
			total_list << "{matrix_o_7_V " << matrix_o_7_V_depth << "}\n";
			total_list << "{matrix_o_8_V " << matrix_o_8_V_depth << "}\n";
			total_list << "{matrix_o_9_V " << matrix_o_9_V_depth << "}\n";
			total_list << "{matrix_o_10_V " << matrix_o_10_V_depth << "}\n";
			total_list << "{matrix_o_11_V " << matrix_o_11_V_depth << "}\n";
			total_list << "{matrix_o_12_V " << matrix_o_12_V_depth << "}\n";
			total_list << "{matrix_o_13_V " << matrix_o_13_V_depth << "}\n";
			total_list << "{matrix_o_14_V " << matrix_o_14_V_depth << "}\n";
			total_list << "{matrix_o_15_V " << matrix_o_15_V_depth << "}\n";
			total_list << "{matrix_o_16_V " << matrix_o_16_V_depth << "}\n";
			total_list << "{matrix_o_17_V " << matrix_o_17_V_depth << "}\n";
			total_list << "{matrix_o_18_V " << matrix_o_18_V_depth << "}\n";
			total_list << "{matrix_o_19_V " << matrix_o_19_V_depth << "}\n";
			total_list << "{matrix_o_20_V " << matrix_o_20_V_depth << "}\n";
			total_list << "{matrix_o_21_V " << matrix_o_21_V_depth << "}\n";
			total_list << "{matrix_o_22_V " << matrix_o_22_V_depth << "}\n";
			total_list << "{matrix_o_23_V " << matrix_o_23_V_depth << "}\n";
			total_list << "{matrix_o_24_V " << matrix_o_24_V_depth << "}\n";
			total_list << "{matrix_o_25_V " << matrix_o_25_V_depth << "}\n";
			total_list << "{matrix_o_26_V " << matrix_o_26_V_depth << "}\n";
			total_list << "{matrix_o_27_V " << matrix_o_27_V_depth << "}\n";
			total_list << "{matrix_o_28_V " << matrix_o_28_V_depth << "}\n";
			total_list << "{matrix_o_29_V " << matrix_o_29_V_depth << "}\n";
			total_list << "{matrix_o_30_V " << matrix_o_30_V_depth << "}\n";
			total_list << "{matrix_o_31_V " << matrix_o_31_V_depth << "}\n";
			total_list << "{matrix_o_32_V " << matrix_o_32_V_depth << "}\n";
			total_list << "{matrix_o_33_V " << matrix_o_33_V_depth << "}\n";
			total_list << "{matrix_o_34_V " << matrix_o_34_V_depth << "}\n";
			total_list << "{matrix_o_35_V " << matrix_o_35_V_depth << "}\n";
			total_list << "{matrix_o_36_V " << matrix_o_36_V_depth << "}\n";
			total_list << "{matrix_o_37_V " << matrix_o_37_V_depth << "}\n";
			total_list << "{matrix_o_38_V " << matrix_o_38_V_depth << "}\n";
			total_list << "{matrix_o_39_V " << matrix_o_39_V_depth << "}\n";
			total_list << "{matrix_o_40_V " << matrix_o_40_V_depth << "}\n";
			total_list << "{matrix_o_41_V " << matrix_o_41_V_depth << "}\n";
			total_list << "{matrix_o_42_V " << matrix_o_42_V_depth << "}\n";
			total_list << "{matrix_o_43_V " << matrix_o_43_V_depth << "}\n";
			total_list << "{matrix_o_44_V " << matrix_o_44_V_depth << "}\n";
			total_list << "{matrix_o_45_V " << matrix_o_45_V_depth << "}\n";
			total_list << "{matrix_o_46_V " << matrix_o_46_V_depth << "}\n";
			total_list << "{matrix_o_47_V " << matrix_o_47_V_depth << "}\n";
			total_list << "{matrix_o_48_V " << matrix_o_48_V_depth << "}\n";
			total_list << "{matrix_o_49_V " << matrix_o_49_V_depth << "}\n";
			total_list << "{matrix_o_50_V " << matrix_o_50_V_depth << "}\n";
			total_list << "{matrix_o_51_V " << matrix_o_51_V_depth << "}\n";
			total_list << "{matrix_o_52_V " << matrix_o_52_V_depth << "}\n";
			total_list << "{matrix_o_53_V " << matrix_o_53_V_depth << "}\n";
			total_list << "{matrix_o_54_V " << matrix_o_54_V_depth << "}\n";
			total_list << "{matrix_o_55_V " << matrix_o_55_V_depth << "}\n";
			total_list << "{matrix_o_56_V " << matrix_o_56_V_depth << "}\n";
			total_list << "{matrix_o_57_V " << matrix_o_57_V_depth << "}\n";
			total_list << "{matrix_o_58_V " << matrix_o_58_V_depth << "}\n";
			total_list << "{matrix_o_59_V " << matrix_o_59_V_depth << "}\n";
			total_list << "{matrix_o_60_V " << matrix_o_60_V_depth << "}\n";
			total_list << "{matrix_o_61_V " << matrix_o_61_V_depth << "}\n";
			total_list << "{matrix_o_62_V " << matrix_o_62_V_depth << "}\n";
			total_list << "{matrix_o_63_V " << matrix_o_63_V_depth << "}\n";
			total_list << "{matrix_o_64_V " << matrix_o_64_V_depth << "}\n";
			total_list << "{matrix_o_65_V " << matrix_o_65_V_depth << "}\n";
			total_list << "{matrix_o_66_V " << matrix_o_66_V_depth << "}\n";
			total_list << "{matrix_o_67_V " << matrix_o_67_V_depth << "}\n";
			total_list << "{matrix_o_68_V " << matrix_o_68_V_depth << "}\n";
			total_list << "{matrix_o_69_V " << matrix_o_69_V_depth << "}\n";
			total_list << "{matrix_o_70_V " << matrix_o_70_V_depth << "}\n";
			total_list << "{matrix_o_71_V " << matrix_o_71_V_depth << "}\n";
			total_list << "{matrix_o_72_V " << matrix_o_72_V_depth << "}\n";
			total_list << "{matrix_o_73_V " << matrix_o_73_V_depth << "}\n";
			total_list << "{matrix_o_74_V " << matrix_o_74_V_depth << "}\n";
			total_list << "{matrix_o_75_V " << matrix_o_75_V_depth << "}\n";
			total_list << "{matrix_o_76_V " << matrix_o_76_V_depth << "}\n";
			total_list << "{matrix_o_77_V " << matrix_o_77_V_depth << "}\n";
			total_list << "{matrix_o_78_V " << matrix_o_78_V_depth << "}\n";
			total_list << "{matrix_o_79_V " << matrix_o_79_V_depth << "}\n";
			total_list << "{matrix_o_80_V " << matrix_o_80_V_depth << "}\n";
			total_list << "{matrix_o_81_V " << matrix_o_81_V_depth << "}\n";
			total_list << "{matrix_o_82_V " << matrix_o_82_V_depth << "}\n";
			total_list << "{matrix_o_83_V " << matrix_o_83_V_depth << "}\n";
			total_list << "{matrix_o_84_V " << matrix_o_84_V_depth << "}\n";
			total_list << "{matrix_o_85_V " << matrix_o_85_V_depth << "}\n";
			total_list << "{matrix_o_86_V " << matrix_o_86_V_depth << "}\n";
			total_list << "{matrix_o_87_V " << matrix_o_87_V_depth << "}\n";
			total_list << "{matrix_o_88_V " << matrix_o_88_V_depth << "}\n";
			total_list << "{matrix_o_89_V " << matrix_o_89_V_depth << "}\n";
			total_list << "{matrix_o_90_V " << matrix_o_90_V_depth << "}\n";
			total_list << "{matrix_o_91_V " << matrix_o_91_V_depth << "}\n";
			total_list << "{matrix_o_92_V " << matrix_o_92_V_depth << "}\n";
			total_list << "{matrix_o_93_V " << matrix_o_93_V_depth << "}\n";
			total_list << "{matrix_o_94_V " << matrix_o_94_V_depth << "}\n";
			total_list << "{matrix_o_95_V " << matrix_o_95_V_depth << "}\n";
			total_list << "{matrix_o_96_V " << matrix_o_96_V_depth << "}\n";
			total_list << "{matrix_o_97_V " << matrix_o_97_V_depth << "}\n";
			total_list << "{matrix_o_98_V " << matrix_o_98_V_depth << "}\n";
			total_list << "{matrix_o_99_V " << matrix_o_99_V_depth << "}\n";
			total_list << "{matrix_o_100_V " << matrix_o_100_V_depth << "}\n";
			total_list << "{matrix_o_101_V " << matrix_o_101_V_depth << "}\n";
			total_list << "{matrix_o_102_V " << matrix_o_102_V_depth << "}\n";
			total_list << "{matrix_o_103_V " << matrix_o_103_V_depth << "}\n";
			total_list << "{matrix_o_104_V " << matrix_o_104_V_depth << "}\n";
			total_list << "{matrix_o_105_V " << matrix_o_105_V_depth << "}\n";
			total_list << "{matrix_o_106_V " << matrix_o_106_V_depth << "}\n";
			total_list << "{matrix_o_107_V " << matrix_o_107_V_depth << "}\n";
			total_list << "{matrix_o_108_V " << matrix_o_108_V_depth << "}\n";
			total_list << "{matrix_o_109_V " << matrix_o_109_V_depth << "}\n";
			total_list << "{matrix_o_110_V " << matrix_o_110_V_depth << "}\n";
			total_list << "{matrix_o_111_V " << matrix_o_111_V_depth << "}\n";
			total_list << "{matrix_o_112_V " << matrix_o_112_V_depth << "}\n";
			total_list << "{matrix_o_113_V " << matrix_o_113_V_depth << "}\n";
			total_list << "{matrix_o_114_V " << matrix_o_114_V_depth << "}\n";
			total_list << "{matrix_o_115_V " << matrix_o_115_V_depth << "}\n";
			total_list << "{matrix_o_116_V " << matrix_o_116_V_depth << "}\n";
			total_list << "{matrix_o_117_V " << matrix_o_117_V_depth << "}\n";
			total_list << "{matrix_o_118_V " << matrix_o_118_V_depth << "}\n";
			total_list << "{matrix_o_119_V " << matrix_o_119_V_depth << "}\n";
			total_list << "{matrix_o_120_V " << matrix_o_120_V_depth << "}\n";
			total_list << "{matrix_o_121_V " << matrix_o_121_V_depth << "}\n";
			total_list << "{matrix_o_122_V " << matrix_o_122_V_depth << "}\n";
			total_list << "{matrix_o_123_V " << matrix_o_123_V_depth << "}\n";
			total_list << "{matrix_o_124_V " << matrix_o_124_V_depth << "}\n";
			total_list << "{matrix_o_125_V " << matrix_o_125_V_depth << "}\n";
			total_list << "{matrix_o_126_V " << matrix_o_126_V_depth << "}\n";
			total_list << "{matrix_o_127_V " << matrix_o_127_V_depth << "}\n";
			return total_list.str();
		}

		void set_num (int num , int* class_num) {
			(*class_num) = (*class_num) > num ? (*class_num) : num;
		}
	public:
		int matrix_i_0_V_depth;
		int matrix_i_1_V_depth;
		int matrix_i_2_V_depth;
		int matrix_i_3_V_depth;
		int matrix_i_4_V_depth;
		int matrix_i_5_V_depth;
		int matrix_i_6_V_depth;
		int matrix_i_7_V_depth;
		int matrix_i_8_V_depth;
		int matrix_i_9_V_depth;
		int matrix_i_10_V_depth;
		int matrix_i_11_V_depth;
		int matrix_i_12_V_depth;
		int matrix_i_13_V_depth;
		int matrix_i_14_V_depth;
		int matrix_i_15_V_depth;
		int matrix_i_16_V_depth;
		int matrix_i_17_V_depth;
		int matrix_i_18_V_depth;
		int matrix_i_19_V_depth;
		int matrix_i_20_V_depth;
		int matrix_i_21_V_depth;
		int matrix_i_22_V_depth;
		int matrix_i_23_V_depth;
		int matrix_i_24_V_depth;
		int matrix_i_25_V_depth;
		int matrix_i_26_V_depth;
		int matrix_i_27_V_depth;
		int matrix_i_28_V_depth;
		int matrix_i_29_V_depth;
		int matrix_i_30_V_depth;
		int matrix_i_31_V_depth;
		int matrix_i_32_V_depth;
		int matrix_i_33_V_depth;
		int matrix_i_34_V_depth;
		int matrix_i_35_V_depth;
		int matrix_i_36_V_depth;
		int matrix_i_37_V_depth;
		int matrix_i_38_V_depth;
		int matrix_i_39_V_depth;
		int matrix_i_40_V_depth;
		int matrix_i_41_V_depth;
		int matrix_i_42_V_depth;
		int matrix_i_43_V_depth;
		int matrix_i_44_V_depth;
		int matrix_i_45_V_depth;
		int matrix_i_46_V_depth;
		int matrix_i_47_V_depth;
		int matrix_i_48_V_depth;
		int matrix_i_49_V_depth;
		int matrix_i_50_V_depth;
		int matrix_i_51_V_depth;
		int matrix_i_52_V_depth;
		int matrix_i_53_V_depth;
		int matrix_i_54_V_depth;
		int matrix_i_55_V_depth;
		int matrix_i_56_V_depth;
		int matrix_i_57_V_depth;
		int matrix_i_58_V_depth;
		int matrix_i_59_V_depth;
		int matrix_i_60_V_depth;
		int matrix_i_61_V_depth;
		int matrix_i_62_V_depth;
		int matrix_i_63_V_depth;
		int matrix_i_64_V_depth;
		int matrix_i_65_V_depth;
		int matrix_i_66_V_depth;
		int matrix_i_67_V_depth;
		int matrix_i_68_V_depth;
		int matrix_i_69_V_depth;
		int matrix_i_70_V_depth;
		int matrix_i_71_V_depth;
		int matrix_i_72_V_depth;
		int matrix_i_73_V_depth;
		int matrix_i_74_V_depth;
		int matrix_i_75_V_depth;
		int matrix_i_76_V_depth;
		int matrix_i_77_V_depth;
		int matrix_i_78_V_depth;
		int matrix_i_79_V_depth;
		int matrix_i_80_V_depth;
		int matrix_i_81_V_depth;
		int matrix_i_82_V_depth;
		int matrix_i_83_V_depth;
		int matrix_i_84_V_depth;
		int matrix_i_85_V_depth;
		int matrix_i_86_V_depth;
		int matrix_i_87_V_depth;
		int matrix_i_88_V_depth;
		int matrix_i_89_V_depth;
		int matrix_i_90_V_depth;
		int matrix_i_91_V_depth;
		int matrix_i_92_V_depth;
		int matrix_i_93_V_depth;
		int matrix_i_94_V_depth;
		int matrix_i_95_V_depth;
		int kernel_s1x1_depth;
		int kernel_e1x1_depth;
		int kernel_e3x3_depth;
		int matrix_o_0_V_depth;
		int matrix_o_1_V_depth;
		int matrix_o_2_V_depth;
		int matrix_o_3_V_depth;
		int matrix_o_4_V_depth;
		int matrix_o_5_V_depth;
		int matrix_o_6_V_depth;
		int matrix_o_7_V_depth;
		int matrix_o_8_V_depth;
		int matrix_o_9_V_depth;
		int matrix_o_10_V_depth;
		int matrix_o_11_V_depth;
		int matrix_o_12_V_depth;
		int matrix_o_13_V_depth;
		int matrix_o_14_V_depth;
		int matrix_o_15_V_depth;
		int matrix_o_16_V_depth;
		int matrix_o_17_V_depth;
		int matrix_o_18_V_depth;
		int matrix_o_19_V_depth;
		int matrix_o_20_V_depth;
		int matrix_o_21_V_depth;
		int matrix_o_22_V_depth;
		int matrix_o_23_V_depth;
		int matrix_o_24_V_depth;
		int matrix_o_25_V_depth;
		int matrix_o_26_V_depth;
		int matrix_o_27_V_depth;
		int matrix_o_28_V_depth;
		int matrix_o_29_V_depth;
		int matrix_o_30_V_depth;
		int matrix_o_31_V_depth;
		int matrix_o_32_V_depth;
		int matrix_o_33_V_depth;
		int matrix_o_34_V_depth;
		int matrix_o_35_V_depth;
		int matrix_o_36_V_depth;
		int matrix_o_37_V_depth;
		int matrix_o_38_V_depth;
		int matrix_o_39_V_depth;
		int matrix_o_40_V_depth;
		int matrix_o_41_V_depth;
		int matrix_o_42_V_depth;
		int matrix_o_43_V_depth;
		int matrix_o_44_V_depth;
		int matrix_o_45_V_depth;
		int matrix_o_46_V_depth;
		int matrix_o_47_V_depth;
		int matrix_o_48_V_depth;
		int matrix_o_49_V_depth;
		int matrix_o_50_V_depth;
		int matrix_o_51_V_depth;
		int matrix_o_52_V_depth;
		int matrix_o_53_V_depth;
		int matrix_o_54_V_depth;
		int matrix_o_55_V_depth;
		int matrix_o_56_V_depth;
		int matrix_o_57_V_depth;
		int matrix_o_58_V_depth;
		int matrix_o_59_V_depth;
		int matrix_o_60_V_depth;
		int matrix_o_61_V_depth;
		int matrix_o_62_V_depth;
		int matrix_o_63_V_depth;
		int matrix_o_64_V_depth;
		int matrix_o_65_V_depth;
		int matrix_o_66_V_depth;
		int matrix_o_67_V_depth;
		int matrix_o_68_V_depth;
		int matrix_o_69_V_depth;
		int matrix_o_70_V_depth;
		int matrix_o_71_V_depth;
		int matrix_o_72_V_depth;
		int matrix_o_73_V_depth;
		int matrix_o_74_V_depth;
		int matrix_o_75_V_depth;
		int matrix_o_76_V_depth;
		int matrix_o_77_V_depth;
		int matrix_o_78_V_depth;
		int matrix_o_79_V_depth;
		int matrix_o_80_V_depth;
		int matrix_o_81_V_depth;
		int matrix_o_82_V_depth;
		int matrix_o_83_V_depth;
		int matrix_o_84_V_depth;
		int matrix_o_85_V_depth;
		int matrix_o_86_V_depth;
		int matrix_o_87_V_depth;
		int matrix_o_88_V_depth;
		int matrix_o_89_V_depth;
		int matrix_o_90_V_depth;
		int matrix_o_91_V_depth;
		int matrix_o_92_V_depth;
		int matrix_o_93_V_depth;
		int matrix_o_94_V_depth;
		int matrix_o_95_V_depth;
		int matrix_o_96_V_depth;
		int matrix_o_97_V_depth;
		int matrix_o_98_V_depth;
		int matrix_o_99_V_depth;
		int matrix_o_100_V_depth;
		int matrix_o_101_V_depth;
		int matrix_o_102_V_depth;
		int matrix_o_103_V_depth;
		int matrix_o_104_V_depth;
		int matrix_o_105_V_depth;
		int matrix_o_106_V_depth;
		int matrix_o_107_V_depth;
		int matrix_o_108_V_depth;
		int matrix_o_109_V_depth;
		int matrix_o_110_V_depth;
		int matrix_o_111_V_depth;
		int matrix_o_112_V_depth;
		int matrix_o_113_V_depth;
		int matrix_o_114_V_depth;
		int matrix_o_115_V_depth;
		int matrix_o_116_V_depth;
		int matrix_o_117_V_depth;
		int matrix_o_118_V_depth;
		int matrix_o_119_V_depth;
		int matrix_o_120_V_depth;
		int matrix_o_121_V_depth;
		int matrix_o_122_V_depth;
		int matrix_o_123_V_depth;
		int matrix_o_124_V_depth;
		int matrix_o_125_V_depth;
		int matrix_o_126_V_depth;
		int matrix_o_127_V_depth;
		int trans_num;

	private:
		ofstream mFile;
		const char* mName;
};


#define fire2 AESL_ORIG_DUT_fire2
extern void fire2 (
hls::stream<short > matrix_i[96],
short kernel_s1x1[16],
short kernel_e1x1[64],
short kernel_e3x3[3][3][64],
hls::stream<short > matrix_o[128]);
#undef fire2

void fire2 (
hls::stream<short > matrix_i[96],
short kernel_s1x1[16],
short kernel_e1x1[64],
short kernel_e3x3[3][3][64],
hls::stream<short > matrix_o[128])
{
	fstream wrapc_switch_file_token;
	wrapc_switch_file_token.open(".hls_cosim_wrapc_switch.log");
	int AESL_i;
	if (wrapc_switch_file_token.good())
	{
		static unsigned AESL_transaction_pc = 0;
		string AESL_token;
		string AESL_num;
		static AESL_FILE_HANDLER aesl_fh;

		// pop stream input: "matrix_i[0]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_1 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_1; i++)
			{
				matrix_i[0].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[1]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_4 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_4; i++)
			{
				matrix_i[1].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[2]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_7 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_7; i++)
			{
				matrix_i[2].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[3]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_10 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_10; i++)
			{
				matrix_i[3].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[4]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_13 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_13; i++)
			{
				matrix_i[4].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[5]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_16 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_16; i++)
			{
				matrix_i[5].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[6]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_19 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_19; i++)
			{
				matrix_i[6].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[7]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_22 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_22; i++)
			{
				matrix_i[7].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[8]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_25 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_25; i++)
			{
				matrix_i[8].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[9]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_28 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_28; i++)
			{
				matrix_i[9].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[10]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_31 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_31; i++)
			{
				matrix_i[10].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[11]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_34 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_34; i++)
			{
				matrix_i[11].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[12]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_37 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_37; i++)
			{
				matrix_i[12].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[13]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_40 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_40; i++)
			{
				matrix_i[13].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[14]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_43 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_43; i++)
			{
				matrix_i[14].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[15]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_46 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_46; i++)
			{
				matrix_i[15].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[16]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_49 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_49; i++)
			{
				matrix_i[16].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[17]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_52 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_52; i++)
			{
				matrix_i[17].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[18]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_55 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_55; i++)
			{
				matrix_i[18].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[19]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_58 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_58; i++)
			{
				matrix_i[19].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[20]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_61 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_61; i++)
			{
				matrix_i[20].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[21]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_64 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_64; i++)
			{
				matrix_i[21].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[22]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_67 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_67; i++)
			{
				matrix_i[22].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[23]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_70 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_70; i++)
			{
				matrix_i[23].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[24]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_73 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_73; i++)
			{
				matrix_i[24].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[25]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_76 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_76; i++)
			{
				matrix_i[25].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[26]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_79 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_79; i++)
			{
				matrix_i[26].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[27]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_82 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_82; i++)
			{
				matrix_i[27].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[28]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_85 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_85; i++)
			{
				matrix_i[28].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[29]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_88 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_88; i++)
			{
				matrix_i[29].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[30]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_91 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_91; i++)
			{
				matrix_i[30].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[31]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_94 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_94; i++)
			{
				matrix_i[31].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[32]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_97 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_97; i++)
			{
				matrix_i[32].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[33]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_100 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_100; i++)
			{
				matrix_i[33].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[34]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_103 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_103; i++)
			{
				matrix_i[34].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[35]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_106 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_106; i++)
			{
				matrix_i[35].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[36]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_109 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_109; i++)
			{
				matrix_i[36].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[37]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_112 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_112; i++)
			{
				matrix_i[37].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[38]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_115 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_115; i++)
			{
				matrix_i[38].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[39]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_118 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_118; i++)
			{
				matrix_i[39].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[40]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_121 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_121; i++)
			{
				matrix_i[40].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[41]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_124 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_124; i++)
			{
				matrix_i[41].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[42]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_127 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_127; i++)
			{
				matrix_i[42].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[43]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_130 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_130; i++)
			{
				matrix_i[43].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[44]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_133 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_133; i++)
			{
				matrix_i[44].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[45]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_136 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_136; i++)
			{
				matrix_i[45].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[46]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_139 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_139; i++)
			{
				matrix_i[46].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[47]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_142 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_142; i++)
			{
				matrix_i[47].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[48]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_145 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_145; i++)
			{
				matrix_i[48].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[49]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_148 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_148; i++)
			{
				matrix_i[49].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[50]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_151 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_151; i++)
			{
				matrix_i[50].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[51]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_154 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_154; i++)
			{
				matrix_i[51].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[52]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_157 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_157; i++)
			{
				matrix_i[52].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[53]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_160 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_160; i++)
			{
				matrix_i[53].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[54]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_163 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_163; i++)
			{
				matrix_i[54].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[55]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_166 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_166; i++)
			{
				matrix_i[55].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[56]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_169 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_169; i++)
			{
				matrix_i[56].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[57]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_172 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_172; i++)
			{
				matrix_i[57].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[58]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_175 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_175; i++)
			{
				matrix_i[58].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[59]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_178 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_178; i++)
			{
				matrix_i[59].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[60]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_181 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_181; i++)
			{
				matrix_i[60].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[61]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_184 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_184; i++)
			{
				matrix_i[61].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[62]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_187 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_187; i++)
			{
				matrix_i[62].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[63]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_190 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_190; i++)
			{
				matrix_i[63].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[64]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_193 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_193; i++)
			{
				matrix_i[64].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[65]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_196 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_196; i++)
			{
				matrix_i[65].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[66]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_199 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_199; i++)
			{
				matrix_i[66].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[67]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_202 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_202; i++)
			{
				matrix_i[67].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[68]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_205 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_205; i++)
			{
				matrix_i[68].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[69]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_208 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_208; i++)
			{
				matrix_i[69].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[70]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_211 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_211; i++)
			{
				matrix_i[70].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[71]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_214 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_214; i++)
			{
				matrix_i[71].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[72]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_217 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_217; i++)
			{
				matrix_i[72].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[73]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_220 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_220; i++)
			{
				matrix_i[73].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[74]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_223 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_223; i++)
			{
				matrix_i[74].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[75]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_226 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_226; i++)
			{
				matrix_i[75].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[76]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_229 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_229; i++)
			{
				matrix_i[76].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[77]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_232 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_232; i++)
			{
				matrix_i[77].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[78]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_235 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_235; i++)
			{
				matrix_i[78].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[79]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_238 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_238; i++)
			{
				matrix_i[79].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[80]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_241 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_241; i++)
			{
				matrix_i[80].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[81]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_244 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_244; i++)
			{
				matrix_i[81].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[82]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_247 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_247; i++)
			{
				matrix_i[82].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[83]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_250 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_250; i++)
			{
				matrix_i[83].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[84]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_253 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_253; i++)
			{
				matrix_i[84].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[85]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_256 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_256; i++)
			{
				matrix_i[85].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[86]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_259 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_259; i++)
			{
				matrix_i[86].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[87]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_262 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_262; i++)
			{
				matrix_i[87].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[88]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_265 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_265; i++)
			{
				matrix_i[88].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[89]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_268 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_268; i++)
			{
				matrix_i[89].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[90]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_271 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_271; i++)
			{
				matrix_i[90].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[91]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_274 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_274; i++)
			{
				matrix_i[91].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[92]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_277 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_277; i++)
			{
				matrix_i[92].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[93]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_280 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_280; i++)
			{
				matrix_i[93].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[94]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_283 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_283; i++)
			{
				matrix_i[94].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// pop stream input: "matrix_i[95]"
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // pop_size
			int aesl_tmp_286 = atoi(AESL_token.c_str());
			for (int i = 0; i < aesl_tmp_286; i++)
			{
				matrix_i[95].read();
			}
			aesl_fh.read(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[0]"
		std::vector<short > aesl_tmp_288;
		int aesl_tmp_289;
		int aesl_tmp_290 = 0;

		// read output stream size: "matrix_o[0]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_289 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[1]"
		std::vector<short > aesl_tmp_291;
		int aesl_tmp_292;
		int aesl_tmp_293 = 0;

		// read output stream size: "matrix_o[1]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_292 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[2]"
		std::vector<short > aesl_tmp_294;
		int aesl_tmp_295;
		int aesl_tmp_296 = 0;

		// read output stream size: "matrix_o[2]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_295 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[3]"
		std::vector<short > aesl_tmp_297;
		int aesl_tmp_298;
		int aesl_tmp_299 = 0;

		// read output stream size: "matrix_o[3]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_298 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[4]"
		std::vector<short > aesl_tmp_300;
		int aesl_tmp_301;
		int aesl_tmp_302 = 0;

		// read output stream size: "matrix_o[4]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_301 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[5]"
		std::vector<short > aesl_tmp_303;
		int aesl_tmp_304;
		int aesl_tmp_305 = 0;

		// read output stream size: "matrix_o[5]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_304 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[6]"
		std::vector<short > aesl_tmp_306;
		int aesl_tmp_307;
		int aesl_tmp_308 = 0;

		// read output stream size: "matrix_o[6]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_307 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[7]"
		std::vector<short > aesl_tmp_309;
		int aesl_tmp_310;
		int aesl_tmp_311 = 0;

		// read output stream size: "matrix_o[7]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_310 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[8]"
		std::vector<short > aesl_tmp_312;
		int aesl_tmp_313;
		int aesl_tmp_314 = 0;

		// read output stream size: "matrix_o[8]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_313 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[9]"
		std::vector<short > aesl_tmp_315;
		int aesl_tmp_316;
		int aesl_tmp_317 = 0;

		// read output stream size: "matrix_o[9]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_316 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[10]"
		std::vector<short > aesl_tmp_318;
		int aesl_tmp_319;
		int aesl_tmp_320 = 0;

		// read output stream size: "matrix_o[10]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_319 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[11]"
		std::vector<short > aesl_tmp_321;
		int aesl_tmp_322;
		int aesl_tmp_323 = 0;

		// read output stream size: "matrix_o[11]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_322 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[12]"
		std::vector<short > aesl_tmp_324;
		int aesl_tmp_325;
		int aesl_tmp_326 = 0;

		// read output stream size: "matrix_o[12]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_325 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[13]"
		std::vector<short > aesl_tmp_327;
		int aesl_tmp_328;
		int aesl_tmp_329 = 0;

		// read output stream size: "matrix_o[13]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_328 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[14]"
		std::vector<short > aesl_tmp_330;
		int aesl_tmp_331;
		int aesl_tmp_332 = 0;

		// read output stream size: "matrix_o[14]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_331 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[15]"
		std::vector<short > aesl_tmp_333;
		int aesl_tmp_334;
		int aesl_tmp_335 = 0;

		// read output stream size: "matrix_o[15]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_334 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[16]"
		std::vector<short > aesl_tmp_336;
		int aesl_tmp_337;
		int aesl_tmp_338 = 0;

		// read output stream size: "matrix_o[16]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_337 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[17]"
		std::vector<short > aesl_tmp_339;
		int aesl_tmp_340;
		int aesl_tmp_341 = 0;

		// read output stream size: "matrix_o[17]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_340 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[18]"
		std::vector<short > aesl_tmp_342;
		int aesl_tmp_343;
		int aesl_tmp_344 = 0;

		// read output stream size: "matrix_o[18]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_343 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[19]"
		std::vector<short > aesl_tmp_345;
		int aesl_tmp_346;
		int aesl_tmp_347 = 0;

		// read output stream size: "matrix_o[19]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_346 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[20]"
		std::vector<short > aesl_tmp_348;
		int aesl_tmp_349;
		int aesl_tmp_350 = 0;

		// read output stream size: "matrix_o[20]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_349 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[21]"
		std::vector<short > aesl_tmp_351;
		int aesl_tmp_352;
		int aesl_tmp_353 = 0;

		// read output stream size: "matrix_o[21]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_352 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[22]"
		std::vector<short > aesl_tmp_354;
		int aesl_tmp_355;
		int aesl_tmp_356 = 0;

		// read output stream size: "matrix_o[22]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_355 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[23]"
		std::vector<short > aesl_tmp_357;
		int aesl_tmp_358;
		int aesl_tmp_359 = 0;

		// read output stream size: "matrix_o[23]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_358 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[24]"
		std::vector<short > aesl_tmp_360;
		int aesl_tmp_361;
		int aesl_tmp_362 = 0;

		// read output stream size: "matrix_o[24]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_361 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[25]"
		std::vector<short > aesl_tmp_363;
		int aesl_tmp_364;
		int aesl_tmp_365 = 0;

		// read output stream size: "matrix_o[25]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_364 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[26]"
		std::vector<short > aesl_tmp_366;
		int aesl_tmp_367;
		int aesl_tmp_368 = 0;

		// read output stream size: "matrix_o[26]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_367 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[27]"
		std::vector<short > aesl_tmp_369;
		int aesl_tmp_370;
		int aesl_tmp_371 = 0;

		// read output stream size: "matrix_o[27]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_370 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[28]"
		std::vector<short > aesl_tmp_372;
		int aesl_tmp_373;
		int aesl_tmp_374 = 0;

		// read output stream size: "matrix_o[28]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_373 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[29]"
		std::vector<short > aesl_tmp_375;
		int aesl_tmp_376;
		int aesl_tmp_377 = 0;

		// read output stream size: "matrix_o[29]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_376 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[30]"
		std::vector<short > aesl_tmp_378;
		int aesl_tmp_379;
		int aesl_tmp_380 = 0;

		// read output stream size: "matrix_o[30]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_379 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[31]"
		std::vector<short > aesl_tmp_381;
		int aesl_tmp_382;
		int aesl_tmp_383 = 0;

		// read output stream size: "matrix_o[31]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_382 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[32]"
		std::vector<short > aesl_tmp_384;
		int aesl_tmp_385;
		int aesl_tmp_386 = 0;

		// read output stream size: "matrix_o[32]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_385 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[33]"
		std::vector<short > aesl_tmp_387;
		int aesl_tmp_388;
		int aesl_tmp_389 = 0;

		// read output stream size: "matrix_o[33]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_388 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[34]"
		std::vector<short > aesl_tmp_390;
		int aesl_tmp_391;
		int aesl_tmp_392 = 0;

		// read output stream size: "matrix_o[34]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_391 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[35]"
		std::vector<short > aesl_tmp_393;
		int aesl_tmp_394;
		int aesl_tmp_395 = 0;

		// read output stream size: "matrix_o[35]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_394 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[36]"
		std::vector<short > aesl_tmp_396;
		int aesl_tmp_397;
		int aesl_tmp_398 = 0;

		// read output stream size: "matrix_o[36]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_397 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[37]"
		std::vector<short > aesl_tmp_399;
		int aesl_tmp_400;
		int aesl_tmp_401 = 0;

		// read output stream size: "matrix_o[37]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_400 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[38]"
		std::vector<short > aesl_tmp_402;
		int aesl_tmp_403;
		int aesl_tmp_404 = 0;

		// read output stream size: "matrix_o[38]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_403 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[39]"
		std::vector<short > aesl_tmp_405;
		int aesl_tmp_406;
		int aesl_tmp_407 = 0;

		// read output stream size: "matrix_o[39]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_406 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[40]"
		std::vector<short > aesl_tmp_408;
		int aesl_tmp_409;
		int aesl_tmp_410 = 0;

		// read output stream size: "matrix_o[40]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_409 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[41]"
		std::vector<short > aesl_tmp_411;
		int aesl_tmp_412;
		int aesl_tmp_413 = 0;

		// read output stream size: "matrix_o[41]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_412 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[42]"
		std::vector<short > aesl_tmp_414;
		int aesl_tmp_415;
		int aesl_tmp_416 = 0;

		// read output stream size: "matrix_o[42]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_415 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[43]"
		std::vector<short > aesl_tmp_417;
		int aesl_tmp_418;
		int aesl_tmp_419 = 0;

		// read output stream size: "matrix_o[43]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_418 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[44]"
		std::vector<short > aesl_tmp_420;
		int aesl_tmp_421;
		int aesl_tmp_422 = 0;

		// read output stream size: "matrix_o[44]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_421 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[45]"
		std::vector<short > aesl_tmp_423;
		int aesl_tmp_424;
		int aesl_tmp_425 = 0;

		// read output stream size: "matrix_o[45]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_424 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[46]"
		std::vector<short > aesl_tmp_426;
		int aesl_tmp_427;
		int aesl_tmp_428 = 0;

		// read output stream size: "matrix_o[46]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_427 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[47]"
		std::vector<short > aesl_tmp_429;
		int aesl_tmp_430;
		int aesl_tmp_431 = 0;

		// read output stream size: "matrix_o[47]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_430 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[48]"
		std::vector<short > aesl_tmp_432;
		int aesl_tmp_433;
		int aesl_tmp_434 = 0;

		// read output stream size: "matrix_o[48]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_433 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[49]"
		std::vector<short > aesl_tmp_435;
		int aesl_tmp_436;
		int aesl_tmp_437 = 0;

		// read output stream size: "matrix_o[49]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_436 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[50]"
		std::vector<short > aesl_tmp_438;
		int aesl_tmp_439;
		int aesl_tmp_440 = 0;

		// read output stream size: "matrix_o[50]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_439 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[51]"
		std::vector<short > aesl_tmp_441;
		int aesl_tmp_442;
		int aesl_tmp_443 = 0;

		// read output stream size: "matrix_o[51]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_442 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[52]"
		std::vector<short > aesl_tmp_444;
		int aesl_tmp_445;
		int aesl_tmp_446 = 0;

		// read output stream size: "matrix_o[52]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_445 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[53]"
		std::vector<short > aesl_tmp_447;
		int aesl_tmp_448;
		int aesl_tmp_449 = 0;

		// read output stream size: "matrix_o[53]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_448 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[54]"
		std::vector<short > aesl_tmp_450;
		int aesl_tmp_451;
		int aesl_tmp_452 = 0;

		// read output stream size: "matrix_o[54]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_451 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[55]"
		std::vector<short > aesl_tmp_453;
		int aesl_tmp_454;
		int aesl_tmp_455 = 0;

		// read output stream size: "matrix_o[55]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_454 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[56]"
		std::vector<short > aesl_tmp_456;
		int aesl_tmp_457;
		int aesl_tmp_458 = 0;

		// read output stream size: "matrix_o[56]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_457 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[57]"
		std::vector<short > aesl_tmp_459;
		int aesl_tmp_460;
		int aesl_tmp_461 = 0;

		// read output stream size: "matrix_o[57]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_460 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[58]"
		std::vector<short > aesl_tmp_462;
		int aesl_tmp_463;
		int aesl_tmp_464 = 0;

		// read output stream size: "matrix_o[58]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_463 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[59]"
		std::vector<short > aesl_tmp_465;
		int aesl_tmp_466;
		int aesl_tmp_467 = 0;

		// read output stream size: "matrix_o[59]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_466 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[60]"
		std::vector<short > aesl_tmp_468;
		int aesl_tmp_469;
		int aesl_tmp_470 = 0;

		// read output stream size: "matrix_o[60]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_469 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[61]"
		std::vector<short > aesl_tmp_471;
		int aesl_tmp_472;
		int aesl_tmp_473 = 0;

		// read output stream size: "matrix_o[61]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_472 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[62]"
		std::vector<short > aesl_tmp_474;
		int aesl_tmp_475;
		int aesl_tmp_476 = 0;

		// read output stream size: "matrix_o[62]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_475 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[63]"
		std::vector<short > aesl_tmp_477;
		int aesl_tmp_478;
		int aesl_tmp_479 = 0;

		// read output stream size: "matrix_o[63]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_478 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[64]"
		std::vector<short > aesl_tmp_480;
		int aesl_tmp_481;
		int aesl_tmp_482 = 0;

		// read output stream size: "matrix_o[64]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_481 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[65]"
		std::vector<short > aesl_tmp_483;
		int aesl_tmp_484;
		int aesl_tmp_485 = 0;

		// read output stream size: "matrix_o[65]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_484 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[66]"
		std::vector<short > aesl_tmp_486;
		int aesl_tmp_487;
		int aesl_tmp_488 = 0;

		// read output stream size: "matrix_o[66]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_487 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[67]"
		std::vector<short > aesl_tmp_489;
		int aesl_tmp_490;
		int aesl_tmp_491 = 0;

		// read output stream size: "matrix_o[67]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_490 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[68]"
		std::vector<short > aesl_tmp_492;
		int aesl_tmp_493;
		int aesl_tmp_494 = 0;

		// read output stream size: "matrix_o[68]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_493 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[69]"
		std::vector<short > aesl_tmp_495;
		int aesl_tmp_496;
		int aesl_tmp_497 = 0;

		// read output stream size: "matrix_o[69]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_496 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[70]"
		std::vector<short > aesl_tmp_498;
		int aesl_tmp_499;
		int aesl_tmp_500 = 0;

		// read output stream size: "matrix_o[70]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_499 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[71]"
		std::vector<short > aesl_tmp_501;
		int aesl_tmp_502;
		int aesl_tmp_503 = 0;

		// read output stream size: "matrix_o[71]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_502 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[72]"
		std::vector<short > aesl_tmp_504;
		int aesl_tmp_505;
		int aesl_tmp_506 = 0;

		// read output stream size: "matrix_o[72]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_505 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[73]"
		std::vector<short > aesl_tmp_507;
		int aesl_tmp_508;
		int aesl_tmp_509 = 0;

		// read output stream size: "matrix_o[73]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_508 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[74]"
		std::vector<short > aesl_tmp_510;
		int aesl_tmp_511;
		int aesl_tmp_512 = 0;

		// read output stream size: "matrix_o[74]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_511 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[75]"
		std::vector<short > aesl_tmp_513;
		int aesl_tmp_514;
		int aesl_tmp_515 = 0;

		// read output stream size: "matrix_o[75]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_514 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[76]"
		std::vector<short > aesl_tmp_516;
		int aesl_tmp_517;
		int aesl_tmp_518 = 0;

		// read output stream size: "matrix_o[76]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_517 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[77]"
		std::vector<short > aesl_tmp_519;
		int aesl_tmp_520;
		int aesl_tmp_521 = 0;

		// read output stream size: "matrix_o[77]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_520 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[78]"
		std::vector<short > aesl_tmp_522;
		int aesl_tmp_523;
		int aesl_tmp_524 = 0;

		// read output stream size: "matrix_o[78]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_523 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[79]"
		std::vector<short > aesl_tmp_525;
		int aesl_tmp_526;
		int aesl_tmp_527 = 0;

		// read output stream size: "matrix_o[79]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_526 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[80]"
		std::vector<short > aesl_tmp_528;
		int aesl_tmp_529;
		int aesl_tmp_530 = 0;

		// read output stream size: "matrix_o[80]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_529 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[81]"
		std::vector<short > aesl_tmp_531;
		int aesl_tmp_532;
		int aesl_tmp_533 = 0;

		// read output stream size: "matrix_o[81]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_532 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[82]"
		std::vector<short > aesl_tmp_534;
		int aesl_tmp_535;
		int aesl_tmp_536 = 0;

		// read output stream size: "matrix_o[82]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_535 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[83]"
		std::vector<short > aesl_tmp_537;
		int aesl_tmp_538;
		int aesl_tmp_539 = 0;

		// read output stream size: "matrix_o[83]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_538 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[84]"
		std::vector<short > aesl_tmp_540;
		int aesl_tmp_541;
		int aesl_tmp_542 = 0;

		// read output stream size: "matrix_o[84]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_541 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[85]"
		std::vector<short > aesl_tmp_543;
		int aesl_tmp_544;
		int aesl_tmp_545 = 0;

		// read output stream size: "matrix_o[85]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_544 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[86]"
		std::vector<short > aesl_tmp_546;
		int aesl_tmp_547;
		int aesl_tmp_548 = 0;

		// read output stream size: "matrix_o[86]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_547 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[87]"
		std::vector<short > aesl_tmp_549;
		int aesl_tmp_550;
		int aesl_tmp_551 = 0;

		// read output stream size: "matrix_o[87]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_550 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[88]"
		std::vector<short > aesl_tmp_552;
		int aesl_tmp_553;
		int aesl_tmp_554 = 0;

		// read output stream size: "matrix_o[88]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_553 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[89]"
		std::vector<short > aesl_tmp_555;
		int aesl_tmp_556;
		int aesl_tmp_557 = 0;

		// read output stream size: "matrix_o[89]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_556 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[90]"
		std::vector<short > aesl_tmp_558;
		int aesl_tmp_559;
		int aesl_tmp_560 = 0;

		// read output stream size: "matrix_o[90]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_559 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[91]"
		std::vector<short > aesl_tmp_561;
		int aesl_tmp_562;
		int aesl_tmp_563 = 0;

		// read output stream size: "matrix_o[91]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_562 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[92]"
		std::vector<short > aesl_tmp_564;
		int aesl_tmp_565;
		int aesl_tmp_566 = 0;

		// read output stream size: "matrix_o[92]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_565 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[93]"
		std::vector<short > aesl_tmp_567;
		int aesl_tmp_568;
		int aesl_tmp_569 = 0;

		// read output stream size: "matrix_o[93]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_568 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[94]"
		std::vector<short > aesl_tmp_570;
		int aesl_tmp_571;
		int aesl_tmp_572 = 0;

		// read output stream size: "matrix_o[94]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_571 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[95]"
		std::vector<short > aesl_tmp_573;
		int aesl_tmp_574;
		int aesl_tmp_575 = 0;

		// read output stream size: "matrix_o[95]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_574 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[96]"
		std::vector<short > aesl_tmp_576;
		int aesl_tmp_577;
		int aesl_tmp_578 = 0;

		// read output stream size: "matrix_o[96]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_577 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[97]"
		std::vector<short > aesl_tmp_579;
		int aesl_tmp_580;
		int aesl_tmp_581 = 0;

		// read output stream size: "matrix_o[97]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_580 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[98]"
		std::vector<short > aesl_tmp_582;
		int aesl_tmp_583;
		int aesl_tmp_584 = 0;

		// read output stream size: "matrix_o[98]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_583 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[99]"
		std::vector<short > aesl_tmp_585;
		int aesl_tmp_586;
		int aesl_tmp_587 = 0;

		// read output stream size: "matrix_o[99]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_586 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[100]"
		std::vector<short > aesl_tmp_588;
		int aesl_tmp_589;
		int aesl_tmp_590 = 0;

		// read output stream size: "matrix_o[100]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_589 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[101]"
		std::vector<short > aesl_tmp_591;
		int aesl_tmp_592;
		int aesl_tmp_593 = 0;

		// read output stream size: "matrix_o[101]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_592 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[102]"
		std::vector<short > aesl_tmp_594;
		int aesl_tmp_595;
		int aesl_tmp_596 = 0;

		// read output stream size: "matrix_o[102]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_595 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[103]"
		std::vector<short > aesl_tmp_597;
		int aesl_tmp_598;
		int aesl_tmp_599 = 0;

		// read output stream size: "matrix_o[103]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_598 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[104]"
		std::vector<short > aesl_tmp_600;
		int aesl_tmp_601;
		int aesl_tmp_602 = 0;

		// read output stream size: "matrix_o[104]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_601 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[105]"
		std::vector<short > aesl_tmp_603;
		int aesl_tmp_604;
		int aesl_tmp_605 = 0;

		// read output stream size: "matrix_o[105]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_604 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[106]"
		std::vector<short > aesl_tmp_606;
		int aesl_tmp_607;
		int aesl_tmp_608 = 0;

		// read output stream size: "matrix_o[106]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_607 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[107]"
		std::vector<short > aesl_tmp_609;
		int aesl_tmp_610;
		int aesl_tmp_611 = 0;

		// read output stream size: "matrix_o[107]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_610 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[108]"
		std::vector<short > aesl_tmp_612;
		int aesl_tmp_613;
		int aesl_tmp_614 = 0;

		// read output stream size: "matrix_o[108]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_613 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[109]"
		std::vector<short > aesl_tmp_615;
		int aesl_tmp_616;
		int aesl_tmp_617 = 0;

		// read output stream size: "matrix_o[109]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_616 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[110]"
		std::vector<short > aesl_tmp_618;
		int aesl_tmp_619;
		int aesl_tmp_620 = 0;

		// read output stream size: "matrix_o[110]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_619 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[111]"
		std::vector<short > aesl_tmp_621;
		int aesl_tmp_622;
		int aesl_tmp_623 = 0;

		// read output stream size: "matrix_o[111]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_622 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[112]"
		std::vector<short > aesl_tmp_624;
		int aesl_tmp_625;
		int aesl_tmp_626 = 0;

		// read output stream size: "matrix_o[112]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_625 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[113]"
		std::vector<short > aesl_tmp_627;
		int aesl_tmp_628;
		int aesl_tmp_629 = 0;

		// read output stream size: "matrix_o[113]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_628 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[114]"
		std::vector<short > aesl_tmp_630;
		int aesl_tmp_631;
		int aesl_tmp_632 = 0;

		// read output stream size: "matrix_o[114]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_631 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[115]"
		std::vector<short > aesl_tmp_633;
		int aesl_tmp_634;
		int aesl_tmp_635 = 0;

		// read output stream size: "matrix_o[115]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_634 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[116]"
		std::vector<short > aesl_tmp_636;
		int aesl_tmp_637;
		int aesl_tmp_638 = 0;

		// read output stream size: "matrix_o[116]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_637 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[117]"
		std::vector<short > aesl_tmp_639;
		int aesl_tmp_640;
		int aesl_tmp_641 = 0;

		// read output stream size: "matrix_o[117]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_640 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[118]"
		std::vector<short > aesl_tmp_642;
		int aesl_tmp_643;
		int aesl_tmp_644 = 0;

		// read output stream size: "matrix_o[118]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_643 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[119]"
		std::vector<short > aesl_tmp_645;
		int aesl_tmp_646;
		int aesl_tmp_647 = 0;

		// read output stream size: "matrix_o[119]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_646 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[120]"
		std::vector<short > aesl_tmp_648;
		int aesl_tmp_649;
		int aesl_tmp_650 = 0;

		// read output stream size: "matrix_o[120]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_649 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[121]"
		std::vector<short > aesl_tmp_651;
		int aesl_tmp_652;
		int aesl_tmp_653 = 0;

		// read output stream size: "matrix_o[121]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_652 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[122]"
		std::vector<short > aesl_tmp_654;
		int aesl_tmp_655;
		int aesl_tmp_656 = 0;

		// read output stream size: "matrix_o[122]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_655 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[123]"
		std::vector<short > aesl_tmp_657;
		int aesl_tmp_658;
		int aesl_tmp_659 = 0;

		// read output stream size: "matrix_o[123]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_658 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[124]"
		std::vector<short > aesl_tmp_660;
		int aesl_tmp_661;
		int aesl_tmp_662 = 0;

		// read output stream size: "matrix_o[124]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_661 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[125]"
		std::vector<short > aesl_tmp_663;
		int aesl_tmp_664;
		int aesl_tmp_665 = 0;

		// read output stream size: "matrix_o[125]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_664 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[126]"
		std::vector<short > aesl_tmp_666;
		int aesl_tmp_667;
		int aesl_tmp_668 = 0;

		// read output stream size: "matrix_o[126]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_667 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// define output stream variables: "matrix_o[127]"
		std::vector<short > aesl_tmp_669;
		int aesl_tmp_670;
		int aesl_tmp_671 = 0;

		// read output stream size: "matrix_o[127]"
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[transaction]]
		aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // pop_size
			aesl_tmp_670 = atoi(AESL_token.c_str());
			aesl_fh.read(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, AESL_token); // [[/transaction]]
		}

		// output port post check: "matrix_o_0_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_0_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_0_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_0_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_0_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_0_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_0_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_0_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_0_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_0_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_289)
			{
				aesl_tmp_289 = i;
			}

			if (aesl_tmp_289 > 0 && aesl_tmp_288.size() < aesl_tmp_289)
			{
				int aesl_tmp_288_size = aesl_tmp_288.size();

				for (int tmp_aesl_tmp_288 = 0; tmp_aesl_tmp_288 < aesl_tmp_289 - aesl_tmp_288_size; tmp_aesl_tmp_288++)
				{
					short tmp;
					aesl_tmp_288.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_0_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_0_0_2 = new sc_lv<16>[aesl_tmp_289 - aesl_tmp_290];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_290) => (aesl_tmp_289 - 1) @ (1)
							for (int i_0 = aesl_tmp_290; i_0 <= aesl_tmp_289 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_288[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_0_0_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_0_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_290) => (aesl_tmp_289 - 1) @ (1)
							for (int i_0 = aesl_tmp_290; i_0 <= aesl_tmp_289 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_288[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_288[0]
								// output_left_conversion : aesl_tmp_288[i_0]
								// output_type_conversion : (matrix_o_V_lv0_0_0_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_288[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_288[i_0] = (matrix_o_V_lv0_0_0_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_1_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_1_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_1_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_1_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_1_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_1_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_1_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_1_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_1_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_1_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_292)
			{
				aesl_tmp_292 = i;
			}

			if (aesl_tmp_292 > 0 && aesl_tmp_291.size() < aesl_tmp_292)
			{
				int aesl_tmp_291_size = aesl_tmp_291.size();

				for (int tmp_aesl_tmp_291 = 0; tmp_aesl_tmp_291 < aesl_tmp_292 - aesl_tmp_291_size; tmp_aesl_tmp_291++)
				{
					short tmp;
					aesl_tmp_291.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_1_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_1_1_2 = new sc_lv<16>[aesl_tmp_292 - aesl_tmp_293];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_293) => (aesl_tmp_292 - 1) @ (1)
							for (int i_0 = aesl_tmp_293; i_0 <= aesl_tmp_292 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_291[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_1_1_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_1_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_293) => (aesl_tmp_292 - 1) @ (1)
							for (int i_0 = aesl_tmp_293; i_0 <= aesl_tmp_292 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_291[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_291[0]
								// output_left_conversion : aesl_tmp_291[i_0]
								// output_type_conversion : (matrix_o_V_lv0_1_1_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_291[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_291[i_0] = (matrix_o_V_lv0_1_1_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_2_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_2_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_2_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_2_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_2_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_2_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_2_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_2_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_2_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_2_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_295)
			{
				aesl_tmp_295 = i;
			}

			if (aesl_tmp_295 > 0 && aesl_tmp_294.size() < aesl_tmp_295)
			{
				int aesl_tmp_294_size = aesl_tmp_294.size();

				for (int tmp_aesl_tmp_294 = 0; tmp_aesl_tmp_294 < aesl_tmp_295 - aesl_tmp_294_size; tmp_aesl_tmp_294++)
				{
					short tmp;
					aesl_tmp_294.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_2_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_2_2_2 = new sc_lv<16>[aesl_tmp_295 - aesl_tmp_296];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_296) => (aesl_tmp_295 - 1) @ (1)
							for (int i_0 = aesl_tmp_296; i_0 <= aesl_tmp_295 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_294[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_2_2_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_2_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_296) => (aesl_tmp_295 - 1) @ (1)
							for (int i_0 = aesl_tmp_296; i_0 <= aesl_tmp_295 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_294[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_294[0]
								// output_left_conversion : aesl_tmp_294[i_0]
								// output_type_conversion : (matrix_o_V_lv0_2_2_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_294[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_294[i_0] = (matrix_o_V_lv0_2_2_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_3_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_3_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_3_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_3_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_3_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_3_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_3_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_3_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_3_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_3_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_298)
			{
				aesl_tmp_298 = i;
			}

			if (aesl_tmp_298 > 0 && aesl_tmp_297.size() < aesl_tmp_298)
			{
				int aesl_tmp_297_size = aesl_tmp_297.size();

				for (int tmp_aesl_tmp_297 = 0; tmp_aesl_tmp_297 < aesl_tmp_298 - aesl_tmp_297_size; tmp_aesl_tmp_297++)
				{
					short tmp;
					aesl_tmp_297.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_3_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_3_3_2 = new sc_lv<16>[aesl_tmp_298 - aesl_tmp_299];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_299) => (aesl_tmp_298 - 1) @ (1)
							for (int i_0 = aesl_tmp_299; i_0 <= aesl_tmp_298 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_297[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_3_3_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_3_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_299) => (aesl_tmp_298 - 1) @ (1)
							for (int i_0 = aesl_tmp_299; i_0 <= aesl_tmp_298 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_297[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_297[0]
								// output_left_conversion : aesl_tmp_297[i_0]
								// output_type_conversion : (matrix_o_V_lv0_3_3_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_297[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_297[i_0] = (matrix_o_V_lv0_3_3_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_4_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_4_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_4_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_4_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_4_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_4_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_4_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_4_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_4_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_4_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_301)
			{
				aesl_tmp_301 = i;
			}

			if (aesl_tmp_301 > 0 && aesl_tmp_300.size() < aesl_tmp_301)
			{
				int aesl_tmp_300_size = aesl_tmp_300.size();

				for (int tmp_aesl_tmp_300 = 0; tmp_aesl_tmp_300 < aesl_tmp_301 - aesl_tmp_300_size; tmp_aesl_tmp_300++)
				{
					short tmp;
					aesl_tmp_300.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_4_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_4_4_2 = new sc_lv<16>[aesl_tmp_301 - aesl_tmp_302];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_302) => (aesl_tmp_301 - 1) @ (1)
							for (int i_0 = aesl_tmp_302; i_0 <= aesl_tmp_301 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_300[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_4_4_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_4_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_302) => (aesl_tmp_301 - 1) @ (1)
							for (int i_0 = aesl_tmp_302; i_0 <= aesl_tmp_301 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_300[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_300[0]
								// output_left_conversion : aesl_tmp_300[i_0]
								// output_type_conversion : (matrix_o_V_lv0_4_4_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_300[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_300[i_0] = (matrix_o_V_lv0_4_4_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_5_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_5_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_5_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_5_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_5_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_5_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_5_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_5_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_5_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_5_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_304)
			{
				aesl_tmp_304 = i;
			}

			if (aesl_tmp_304 > 0 && aesl_tmp_303.size() < aesl_tmp_304)
			{
				int aesl_tmp_303_size = aesl_tmp_303.size();

				for (int tmp_aesl_tmp_303 = 0; tmp_aesl_tmp_303 < aesl_tmp_304 - aesl_tmp_303_size; tmp_aesl_tmp_303++)
				{
					short tmp;
					aesl_tmp_303.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_5_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_5_5_2 = new sc_lv<16>[aesl_tmp_304 - aesl_tmp_305];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_305) => (aesl_tmp_304 - 1) @ (1)
							for (int i_0 = aesl_tmp_305; i_0 <= aesl_tmp_304 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_303[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_5_5_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_5_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_305) => (aesl_tmp_304 - 1) @ (1)
							for (int i_0 = aesl_tmp_305; i_0 <= aesl_tmp_304 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_303[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_303[0]
								// output_left_conversion : aesl_tmp_303[i_0]
								// output_type_conversion : (matrix_o_V_lv0_5_5_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_303[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_303[i_0] = (matrix_o_V_lv0_5_5_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_6_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_6_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_6_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_6_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_6_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_6_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_6_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_6_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_6_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_6_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_307)
			{
				aesl_tmp_307 = i;
			}

			if (aesl_tmp_307 > 0 && aesl_tmp_306.size() < aesl_tmp_307)
			{
				int aesl_tmp_306_size = aesl_tmp_306.size();

				for (int tmp_aesl_tmp_306 = 0; tmp_aesl_tmp_306 < aesl_tmp_307 - aesl_tmp_306_size; tmp_aesl_tmp_306++)
				{
					short tmp;
					aesl_tmp_306.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_6_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_6_6_2 = new sc_lv<16>[aesl_tmp_307 - aesl_tmp_308];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_308) => (aesl_tmp_307 - 1) @ (1)
							for (int i_0 = aesl_tmp_308; i_0 <= aesl_tmp_307 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_306[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_6_6_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_6_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_308) => (aesl_tmp_307 - 1) @ (1)
							for (int i_0 = aesl_tmp_308; i_0 <= aesl_tmp_307 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_306[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_306[0]
								// output_left_conversion : aesl_tmp_306[i_0]
								// output_type_conversion : (matrix_o_V_lv0_6_6_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_306[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_306[i_0] = (matrix_o_V_lv0_6_6_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_7_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_7_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_7_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_7_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_7_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_7_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_7_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_7_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_7_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_7_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_310)
			{
				aesl_tmp_310 = i;
			}

			if (aesl_tmp_310 > 0 && aesl_tmp_309.size() < aesl_tmp_310)
			{
				int aesl_tmp_309_size = aesl_tmp_309.size();

				for (int tmp_aesl_tmp_309 = 0; tmp_aesl_tmp_309 < aesl_tmp_310 - aesl_tmp_309_size; tmp_aesl_tmp_309++)
				{
					short tmp;
					aesl_tmp_309.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_7_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_7_7_2 = new sc_lv<16>[aesl_tmp_310 - aesl_tmp_311];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_311) => (aesl_tmp_310 - 1) @ (1)
							for (int i_0 = aesl_tmp_311; i_0 <= aesl_tmp_310 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_309[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_7_7_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_7_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_311) => (aesl_tmp_310 - 1) @ (1)
							for (int i_0 = aesl_tmp_311; i_0 <= aesl_tmp_310 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_309[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_309[0]
								// output_left_conversion : aesl_tmp_309[i_0]
								// output_type_conversion : (matrix_o_V_lv0_7_7_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_309[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_309[i_0] = (matrix_o_V_lv0_7_7_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_8_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_8_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_8_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_8_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_8_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_8_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_8_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_8_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_8_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_8_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_313)
			{
				aesl_tmp_313 = i;
			}

			if (aesl_tmp_313 > 0 && aesl_tmp_312.size() < aesl_tmp_313)
			{
				int aesl_tmp_312_size = aesl_tmp_312.size();

				for (int tmp_aesl_tmp_312 = 0; tmp_aesl_tmp_312 < aesl_tmp_313 - aesl_tmp_312_size; tmp_aesl_tmp_312++)
				{
					short tmp;
					aesl_tmp_312.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_8_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_8_8_2 = new sc_lv<16>[aesl_tmp_313 - aesl_tmp_314];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_314) => (aesl_tmp_313 - 1) @ (1)
							for (int i_0 = aesl_tmp_314; i_0 <= aesl_tmp_313 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_312[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_8_8_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_8_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_314) => (aesl_tmp_313 - 1) @ (1)
							for (int i_0 = aesl_tmp_314; i_0 <= aesl_tmp_313 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_312[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_312[0]
								// output_left_conversion : aesl_tmp_312[i_0]
								// output_type_conversion : (matrix_o_V_lv0_8_8_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_312[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_312[i_0] = (matrix_o_V_lv0_8_8_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_9_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_9_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_9_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_9_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_9_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_9_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_9_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_9_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_9_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_9_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_316)
			{
				aesl_tmp_316 = i;
			}

			if (aesl_tmp_316 > 0 && aesl_tmp_315.size() < aesl_tmp_316)
			{
				int aesl_tmp_315_size = aesl_tmp_315.size();

				for (int tmp_aesl_tmp_315 = 0; tmp_aesl_tmp_315 < aesl_tmp_316 - aesl_tmp_315_size; tmp_aesl_tmp_315++)
				{
					short tmp;
					aesl_tmp_315.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_9_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_9_9_2 = new sc_lv<16>[aesl_tmp_316 - aesl_tmp_317];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_317) => (aesl_tmp_316 - 1) @ (1)
							for (int i_0 = aesl_tmp_317; i_0 <= aesl_tmp_316 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_315[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_9_9_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_9_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_317) => (aesl_tmp_316 - 1) @ (1)
							for (int i_0 = aesl_tmp_317; i_0 <= aesl_tmp_316 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_315[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_315[0]
								// output_left_conversion : aesl_tmp_315[i_0]
								// output_type_conversion : (matrix_o_V_lv0_9_9_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_315[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_315[i_0] = (matrix_o_V_lv0_9_9_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_10_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_10_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_10_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_10_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_10_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_10_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_10_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_10_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_10_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_10_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_319)
			{
				aesl_tmp_319 = i;
			}

			if (aesl_tmp_319 > 0 && aesl_tmp_318.size() < aesl_tmp_319)
			{
				int aesl_tmp_318_size = aesl_tmp_318.size();

				for (int tmp_aesl_tmp_318 = 0; tmp_aesl_tmp_318 < aesl_tmp_319 - aesl_tmp_318_size; tmp_aesl_tmp_318++)
				{
					short tmp;
					aesl_tmp_318.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_10_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_10_10_2 = new sc_lv<16>[aesl_tmp_319 - aesl_tmp_320];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_320) => (aesl_tmp_319 - 1) @ (1)
							for (int i_0 = aesl_tmp_320; i_0 <= aesl_tmp_319 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_318[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_10_10_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_10_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_320) => (aesl_tmp_319 - 1) @ (1)
							for (int i_0 = aesl_tmp_320; i_0 <= aesl_tmp_319 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_318[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_318[0]
								// output_left_conversion : aesl_tmp_318[i_0]
								// output_type_conversion : (matrix_o_V_lv0_10_10_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_318[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_318[i_0] = (matrix_o_V_lv0_10_10_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_11_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_11_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_11_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_11_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_11_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_11_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_11_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_11_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_11_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_11_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_322)
			{
				aesl_tmp_322 = i;
			}

			if (aesl_tmp_322 > 0 && aesl_tmp_321.size() < aesl_tmp_322)
			{
				int aesl_tmp_321_size = aesl_tmp_321.size();

				for (int tmp_aesl_tmp_321 = 0; tmp_aesl_tmp_321 < aesl_tmp_322 - aesl_tmp_321_size; tmp_aesl_tmp_321++)
				{
					short tmp;
					aesl_tmp_321.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_11_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_11_11_2 = new sc_lv<16>[aesl_tmp_322 - aesl_tmp_323];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_323) => (aesl_tmp_322 - 1) @ (1)
							for (int i_0 = aesl_tmp_323; i_0 <= aesl_tmp_322 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_321[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_11_11_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_11_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_323) => (aesl_tmp_322 - 1) @ (1)
							for (int i_0 = aesl_tmp_323; i_0 <= aesl_tmp_322 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_321[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_321[0]
								// output_left_conversion : aesl_tmp_321[i_0]
								// output_type_conversion : (matrix_o_V_lv0_11_11_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_321[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_321[i_0] = (matrix_o_V_lv0_11_11_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_12_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_12_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_12_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_12_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_12_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_12_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_12_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_12_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_12_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_12_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_325)
			{
				aesl_tmp_325 = i;
			}

			if (aesl_tmp_325 > 0 && aesl_tmp_324.size() < aesl_tmp_325)
			{
				int aesl_tmp_324_size = aesl_tmp_324.size();

				for (int tmp_aesl_tmp_324 = 0; tmp_aesl_tmp_324 < aesl_tmp_325 - aesl_tmp_324_size; tmp_aesl_tmp_324++)
				{
					short tmp;
					aesl_tmp_324.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_12_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_12_12_2 = new sc_lv<16>[aesl_tmp_325 - aesl_tmp_326];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_326) => (aesl_tmp_325 - 1) @ (1)
							for (int i_0 = aesl_tmp_326; i_0 <= aesl_tmp_325 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_324[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_12_12_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_12_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_326) => (aesl_tmp_325 - 1) @ (1)
							for (int i_0 = aesl_tmp_326; i_0 <= aesl_tmp_325 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_324[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_324[0]
								// output_left_conversion : aesl_tmp_324[i_0]
								// output_type_conversion : (matrix_o_V_lv0_12_12_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_324[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_324[i_0] = (matrix_o_V_lv0_12_12_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_13_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_13_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_13_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_13_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_13_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_13_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_13_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_13_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_13_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_13_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_328)
			{
				aesl_tmp_328 = i;
			}

			if (aesl_tmp_328 > 0 && aesl_tmp_327.size() < aesl_tmp_328)
			{
				int aesl_tmp_327_size = aesl_tmp_327.size();

				for (int tmp_aesl_tmp_327 = 0; tmp_aesl_tmp_327 < aesl_tmp_328 - aesl_tmp_327_size; tmp_aesl_tmp_327++)
				{
					short tmp;
					aesl_tmp_327.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_13_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_13_13_2 = new sc_lv<16>[aesl_tmp_328 - aesl_tmp_329];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_329) => (aesl_tmp_328 - 1) @ (1)
							for (int i_0 = aesl_tmp_329; i_0 <= aesl_tmp_328 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_327[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_13_13_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_13_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_329) => (aesl_tmp_328 - 1) @ (1)
							for (int i_0 = aesl_tmp_329; i_0 <= aesl_tmp_328 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_327[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_327[0]
								// output_left_conversion : aesl_tmp_327[i_0]
								// output_type_conversion : (matrix_o_V_lv0_13_13_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_327[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_327[i_0] = (matrix_o_V_lv0_13_13_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_14_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_14_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_14_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_14_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_14_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_14_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_14_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_14_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_14_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_14_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_331)
			{
				aesl_tmp_331 = i;
			}

			if (aesl_tmp_331 > 0 && aesl_tmp_330.size() < aesl_tmp_331)
			{
				int aesl_tmp_330_size = aesl_tmp_330.size();

				for (int tmp_aesl_tmp_330 = 0; tmp_aesl_tmp_330 < aesl_tmp_331 - aesl_tmp_330_size; tmp_aesl_tmp_330++)
				{
					short tmp;
					aesl_tmp_330.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_14_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_14_14_2 = new sc_lv<16>[aesl_tmp_331 - aesl_tmp_332];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_332) => (aesl_tmp_331 - 1) @ (1)
							for (int i_0 = aesl_tmp_332; i_0 <= aesl_tmp_331 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_330[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_14_14_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_14_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_332) => (aesl_tmp_331 - 1) @ (1)
							for (int i_0 = aesl_tmp_332; i_0 <= aesl_tmp_331 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_330[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_330[0]
								// output_left_conversion : aesl_tmp_330[i_0]
								// output_type_conversion : (matrix_o_V_lv0_14_14_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_330[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_330[i_0] = (matrix_o_V_lv0_14_14_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_15_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_15_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_15_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_15_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_15_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_15_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_15_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_15_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_15_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_15_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_334)
			{
				aesl_tmp_334 = i;
			}

			if (aesl_tmp_334 > 0 && aesl_tmp_333.size() < aesl_tmp_334)
			{
				int aesl_tmp_333_size = aesl_tmp_333.size();

				for (int tmp_aesl_tmp_333 = 0; tmp_aesl_tmp_333 < aesl_tmp_334 - aesl_tmp_333_size; tmp_aesl_tmp_333++)
				{
					short tmp;
					aesl_tmp_333.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_15_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_15_15_2 = new sc_lv<16>[aesl_tmp_334 - aesl_tmp_335];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_335) => (aesl_tmp_334 - 1) @ (1)
							for (int i_0 = aesl_tmp_335; i_0 <= aesl_tmp_334 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_333[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_15_15_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_15_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_335) => (aesl_tmp_334 - 1) @ (1)
							for (int i_0 = aesl_tmp_335; i_0 <= aesl_tmp_334 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_333[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_333[0]
								// output_left_conversion : aesl_tmp_333[i_0]
								// output_type_conversion : (matrix_o_V_lv0_15_15_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_333[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_333[i_0] = (matrix_o_V_lv0_15_15_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_16_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_16_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_16_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_16_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_16_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_16_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_16_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_16_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_16_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_16_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_337)
			{
				aesl_tmp_337 = i;
			}

			if (aesl_tmp_337 > 0 && aesl_tmp_336.size() < aesl_tmp_337)
			{
				int aesl_tmp_336_size = aesl_tmp_336.size();

				for (int tmp_aesl_tmp_336 = 0; tmp_aesl_tmp_336 < aesl_tmp_337 - aesl_tmp_336_size; tmp_aesl_tmp_336++)
				{
					short tmp;
					aesl_tmp_336.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_16_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_16_16_2 = new sc_lv<16>[aesl_tmp_337 - aesl_tmp_338];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_338) => (aesl_tmp_337 - 1) @ (1)
							for (int i_0 = aesl_tmp_338; i_0 <= aesl_tmp_337 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_336[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_16_16_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_16_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_338) => (aesl_tmp_337 - 1) @ (1)
							for (int i_0 = aesl_tmp_338; i_0 <= aesl_tmp_337 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_336[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_336[0]
								// output_left_conversion : aesl_tmp_336[i_0]
								// output_type_conversion : (matrix_o_V_lv0_16_16_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_336[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_336[i_0] = (matrix_o_V_lv0_16_16_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_17_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_17_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_17_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_17_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_17_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_17_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_17_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_17_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_17_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_17_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_340)
			{
				aesl_tmp_340 = i;
			}

			if (aesl_tmp_340 > 0 && aesl_tmp_339.size() < aesl_tmp_340)
			{
				int aesl_tmp_339_size = aesl_tmp_339.size();

				for (int tmp_aesl_tmp_339 = 0; tmp_aesl_tmp_339 < aesl_tmp_340 - aesl_tmp_339_size; tmp_aesl_tmp_339++)
				{
					short tmp;
					aesl_tmp_339.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_17_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_17_17_2 = new sc_lv<16>[aesl_tmp_340 - aesl_tmp_341];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_341) => (aesl_tmp_340 - 1) @ (1)
							for (int i_0 = aesl_tmp_341; i_0 <= aesl_tmp_340 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_339[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_17_17_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_17_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_341) => (aesl_tmp_340 - 1) @ (1)
							for (int i_0 = aesl_tmp_341; i_0 <= aesl_tmp_340 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_339[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_339[0]
								// output_left_conversion : aesl_tmp_339[i_0]
								// output_type_conversion : (matrix_o_V_lv0_17_17_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_339[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_339[i_0] = (matrix_o_V_lv0_17_17_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_18_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_18_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_18_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_18_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_18_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_18_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_18_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_18_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_18_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_18_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_343)
			{
				aesl_tmp_343 = i;
			}

			if (aesl_tmp_343 > 0 && aesl_tmp_342.size() < aesl_tmp_343)
			{
				int aesl_tmp_342_size = aesl_tmp_342.size();

				for (int tmp_aesl_tmp_342 = 0; tmp_aesl_tmp_342 < aesl_tmp_343 - aesl_tmp_342_size; tmp_aesl_tmp_342++)
				{
					short tmp;
					aesl_tmp_342.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_18_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_18_18_2 = new sc_lv<16>[aesl_tmp_343 - aesl_tmp_344];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_344) => (aesl_tmp_343 - 1) @ (1)
							for (int i_0 = aesl_tmp_344; i_0 <= aesl_tmp_343 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_342[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_18_18_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_18_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_344) => (aesl_tmp_343 - 1) @ (1)
							for (int i_0 = aesl_tmp_344; i_0 <= aesl_tmp_343 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_342[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_342[0]
								// output_left_conversion : aesl_tmp_342[i_0]
								// output_type_conversion : (matrix_o_V_lv0_18_18_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_342[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_342[i_0] = (matrix_o_V_lv0_18_18_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_19_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_19_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_19_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_19_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_19_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_19_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_19_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_19_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_19_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_19_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_346)
			{
				aesl_tmp_346 = i;
			}

			if (aesl_tmp_346 > 0 && aesl_tmp_345.size() < aesl_tmp_346)
			{
				int aesl_tmp_345_size = aesl_tmp_345.size();

				for (int tmp_aesl_tmp_345 = 0; tmp_aesl_tmp_345 < aesl_tmp_346 - aesl_tmp_345_size; tmp_aesl_tmp_345++)
				{
					short tmp;
					aesl_tmp_345.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_19_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_19_19_2 = new sc_lv<16>[aesl_tmp_346 - aesl_tmp_347];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_347) => (aesl_tmp_346 - 1) @ (1)
							for (int i_0 = aesl_tmp_347; i_0 <= aesl_tmp_346 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_345[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_19_19_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_19_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_347) => (aesl_tmp_346 - 1) @ (1)
							for (int i_0 = aesl_tmp_347; i_0 <= aesl_tmp_346 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_345[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_345[0]
								// output_left_conversion : aesl_tmp_345[i_0]
								// output_type_conversion : (matrix_o_V_lv0_19_19_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_345[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_345[i_0] = (matrix_o_V_lv0_19_19_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_20_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_20_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_20_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_20_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_20_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_20_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_20_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_20_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_20_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_20_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_349)
			{
				aesl_tmp_349 = i;
			}

			if (aesl_tmp_349 > 0 && aesl_tmp_348.size() < aesl_tmp_349)
			{
				int aesl_tmp_348_size = aesl_tmp_348.size();

				for (int tmp_aesl_tmp_348 = 0; tmp_aesl_tmp_348 < aesl_tmp_349 - aesl_tmp_348_size; tmp_aesl_tmp_348++)
				{
					short tmp;
					aesl_tmp_348.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_20_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_20_20_2 = new sc_lv<16>[aesl_tmp_349 - aesl_tmp_350];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_350) => (aesl_tmp_349 - 1) @ (1)
							for (int i_0 = aesl_tmp_350; i_0 <= aesl_tmp_349 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_348[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_20_20_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_20_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_350) => (aesl_tmp_349 - 1) @ (1)
							for (int i_0 = aesl_tmp_350; i_0 <= aesl_tmp_349 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_348[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_348[0]
								// output_left_conversion : aesl_tmp_348[i_0]
								// output_type_conversion : (matrix_o_V_lv0_20_20_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_348[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_348[i_0] = (matrix_o_V_lv0_20_20_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_21_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_21_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_21_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_21_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_21_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_21_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_21_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_21_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_21_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_21_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_352)
			{
				aesl_tmp_352 = i;
			}

			if (aesl_tmp_352 > 0 && aesl_tmp_351.size() < aesl_tmp_352)
			{
				int aesl_tmp_351_size = aesl_tmp_351.size();

				for (int tmp_aesl_tmp_351 = 0; tmp_aesl_tmp_351 < aesl_tmp_352 - aesl_tmp_351_size; tmp_aesl_tmp_351++)
				{
					short tmp;
					aesl_tmp_351.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_21_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_21_21_2 = new sc_lv<16>[aesl_tmp_352 - aesl_tmp_353];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_353) => (aesl_tmp_352 - 1) @ (1)
							for (int i_0 = aesl_tmp_353; i_0 <= aesl_tmp_352 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_351[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_21_21_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_21_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_353) => (aesl_tmp_352 - 1) @ (1)
							for (int i_0 = aesl_tmp_353; i_0 <= aesl_tmp_352 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_351[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_351[0]
								// output_left_conversion : aesl_tmp_351[i_0]
								// output_type_conversion : (matrix_o_V_lv0_21_21_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_351[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_351[i_0] = (matrix_o_V_lv0_21_21_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_22_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_22_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_22_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_22_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_22_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_22_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_22_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_22_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_22_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_22_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_355)
			{
				aesl_tmp_355 = i;
			}

			if (aesl_tmp_355 > 0 && aesl_tmp_354.size() < aesl_tmp_355)
			{
				int aesl_tmp_354_size = aesl_tmp_354.size();

				for (int tmp_aesl_tmp_354 = 0; tmp_aesl_tmp_354 < aesl_tmp_355 - aesl_tmp_354_size; tmp_aesl_tmp_354++)
				{
					short tmp;
					aesl_tmp_354.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_22_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_22_22_2 = new sc_lv<16>[aesl_tmp_355 - aesl_tmp_356];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_356) => (aesl_tmp_355 - 1) @ (1)
							for (int i_0 = aesl_tmp_356; i_0 <= aesl_tmp_355 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_354[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_22_22_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_22_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_356) => (aesl_tmp_355 - 1) @ (1)
							for (int i_0 = aesl_tmp_356; i_0 <= aesl_tmp_355 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_354[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_354[0]
								// output_left_conversion : aesl_tmp_354[i_0]
								// output_type_conversion : (matrix_o_V_lv0_22_22_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_354[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_354[i_0] = (matrix_o_V_lv0_22_22_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_23_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_23_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_23_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_23_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_23_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_23_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_23_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_23_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_23_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_23_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_358)
			{
				aesl_tmp_358 = i;
			}

			if (aesl_tmp_358 > 0 && aesl_tmp_357.size() < aesl_tmp_358)
			{
				int aesl_tmp_357_size = aesl_tmp_357.size();

				for (int tmp_aesl_tmp_357 = 0; tmp_aesl_tmp_357 < aesl_tmp_358 - aesl_tmp_357_size; tmp_aesl_tmp_357++)
				{
					short tmp;
					aesl_tmp_357.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_23_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_23_23_2 = new sc_lv<16>[aesl_tmp_358 - aesl_tmp_359];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_359) => (aesl_tmp_358 - 1) @ (1)
							for (int i_0 = aesl_tmp_359; i_0 <= aesl_tmp_358 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_357[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_23_23_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_23_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_359) => (aesl_tmp_358 - 1) @ (1)
							for (int i_0 = aesl_tmp_359; i_0 <= aesl_tmp_358 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_357[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_357[0]
								// output_left_conversion : aesl_tmp_357[i_0]
								// output_type_conversion : (matrix_o_V_lv0_23_23_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_357[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_357[i_0] = (matrix_o_V_lv0_23_23_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_24_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_24_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_24_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_24_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_24_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_24_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_24_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_24_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_24_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_24_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_361)
			{
				aesl_tmp_361 = i;
			}

			if (aesl_tmp_361 > 0 && aesl_tmp_360.size() < aesl_tmp_361)
			{
				int aesl_tmp_360_size = aesl_tmp_360.size();

				for (int tmp_aesl_tmp_360 = 0; tmp_aesl_tmp_360 < aesl_tmp_361 - aesl_tmp_360_size; tmp_aesl_tmp_360++)
				{
					short tmp;
					aesl_tmp_360.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_24_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_24_24_2 = new sc_lv<16>[aesl_tmp_361 - aesl_tmp_362];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_362) => (aesl_tmp_361 - 1) @ (1)
							for (int i_0 = aesl_tmp_362; i_0 <= aesl_tmp_361 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_360[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_24_24_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_24_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_362) => (aesl_tmp_361 - 1) @ (1)
							for (int i_0 = aesl_tmp_362; i_0 <= aesl_tmp_361 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_360[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_360[0]
								// output_left_conversion : aesl_tmp_360[i_0]
								// output_type_conversion : (matrix_o_V_lv0_24_24_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_360[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_360[i_0] = (matrix_o_V_lv0_24_24_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_25_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_25_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_25_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_25_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_25_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_25_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_25_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_25_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_25_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_25_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_364)
			{
				aesl_tmp_364 = i;
			}

			if (aesl_tmp_364 > 0 && aesl_tmp_363.size() < aesl_tmp_364)
			{
				int aesl_tmp_363_size = aesl_tmp_363.size();

				for (int tmp_aesl_tmp_363 = 0; tmp_aesl_tmp_363 < aesl_tmp_364 - aesl_tmp_363_size; tmp_aesl_tmp_363++)
				{
					short tmp;
					aesl_tmp_363.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_25_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_25_25_2 = new sc_lv<16>[aesl_tmp_364 - aesl_tmp_365];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_365) => (aesl_tmp_364 - 1) @ (1)
							for (int i_0 = aesl_tmp_365; i_0 <= aesl_tmp_364 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_363[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_25_25_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_25_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_365) => (aesl_tmp_364 - 1) @ (1)
							for (int i_0 = aesl_tmp_365; i_0 <= aesl_tmp_364 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_363[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_363[0]
								// output_left_conversion : aesl_tmp_363[i_0]
								// output_type_conversion : (matrix_o_V_lv0_25_25_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_363[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_363[i_0] = (matrix_o_V_lv0_25_25_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_26_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_26_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_26_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_26_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_26_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_26_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_26_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_26_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_26_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_26_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_367)
			{
				aesl_tmp_367 = i;
			}

			if (aesl_tmp_367 > 0 && aesl_tmp_366.size() < aesl_tmp_367)
			{
				int aesl_tmp_366_size = aesl_tmp_366.size();

				for (int tmp_aesl_tmp_366 = 0; tmp_aesl_tmp_366 < aesl_tmp_367 - aesl_tmp_366_size; tmp_aesl_tmp_366++)
				{
					short tmp;
					aesl_tmp_366.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_26_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_26_26_2 = new sc_lv<16>[aesl_tmp_367 - aesl_tmp_368];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_368) => (aesl_tmp_367 - 1) @ (1)
							for (int i_0 = aesl_tmp_368; i_0 <= aesl_tmp_367 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_366[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_26_26_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_26_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_368) => (aesl_tmp_367 - 1) @ (1)
							for (int i_0 = aesl_tmp_368; i_0 <= aesl_tmp_367 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_366[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_366[0]
								// output_left_conversion : aesl_tmp_366[i_0]
								// output_type_conversion : (matrix_o_V_lv0_26_26_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_366[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_366[i_0] = (matrix_o_V_lv0_26_26_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_27_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_27_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_27_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_27_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_27_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_27_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_27_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_27_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_27_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_27_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_370)
			{
				aesl_tmp_370 = i;
			}

			if (aesl_tmp_370 > 0 && aesl_tmp_369.size() < aesl_tmp_370)
			{
				int aesl_tmp_369_size = aesl_tmp_369.size();

				for (int tmp_aesl_tmp_369 = 0; tmp_aesl_tmp_369 < aesl_tmp_370 - aesl_tmp_369_size; tmp_aesl_tmp_369++)
				{
					short tmp;
					aesl_tmp_369.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_27_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_27_27_2 = new sc_lv<16>[aesl_tmp_370 - aesl_tmp_371];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_371) => (aesl_tmp_370 - 1) @ (1)
							for (int i_0 = aesl_tmp_371; i_0 <= aesl_tmp_370 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_369[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_27_27_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_27_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_371) => (aesl_tmp_370 - 1) @ (1)
							for (int i_0 = aesl_tmp_371; i_0 <= aesl_tmp_370 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_369[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_369[0]
								// output_left_conversion : aesl_tmp_369[i_0]
								// output_type_conversion : (matrix_o_V_lv0_27_27_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_369[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_369[i_0] = (matrix_o_V_lv0_27_27_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_28_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_28_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_28_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_28_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_28_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_28_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_28_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_28_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_28_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_28_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_373)
			{
				aesl_tmp_373 = i;
			}

			if (aesl_tmp_373 > 0 && aesl_tmp_372.size() < aesl_tmp_373)
			{
				int aesl_tmp_372_size = aesl_tmp_372.size();

				for (int tmp_aesl_tmp_372 = 0; tmp_aesl_tmp_372 < aesl_tmp_373 - aesl_tmp_372_size; tmp_aesl_tmp_372++)
				{
					short tmp;
					aesl_tmp_372.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_28_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_28_28_2 = new sc_lv<16>[aesl_tmp_373 - aesl_tmp_374];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_374) => (aesl_tmp_373 - 1) @ (1)
							for (int i_0 = aesl_tmp_374; i_0 <= aesl_tmp_373 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_372[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_28_28_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_28_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_374) => (aesl_tmp_373 - 1) @ (1)
							for (int i_0 = aesl_tmp_374; i_0 <= aesl_tmp_373 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_372[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_372[0]
								// output_left_conversion : aesl_tmp_372[i_0]
								// output_type_conversion : (matrix_o_V_lv0_28_28_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_372[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_372[i_0] = (matrix_o_V_lv0_28_28_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_29_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_29_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_29_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_29_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_29_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_29_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_29_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_29_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_29_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_29_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_376)
			{
				aesl_tmp_376 = i;
			}

			if (aesl_tmp_376 > 0 && aesl_tmp_375.size() < aesl_tmp_376)
			{
				int aesl_tmp_375_size = aesl_tmp_375.size();

				for (int tmp_aesl_tmp_375 = 0; tmp_aesl_tmp_375 < aesl_tmp_376 - aesl_tmp_375_size; tmp_aesl_tmp_375++)
				{
					short tmp;
					aesl_tmp_375.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_29_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_29_29_2 = new sc_lv<16>[aesl_tmp_376 - aesl_tmp_377];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_377) => (aesl_tmp_376 - 1) @ (1)
							for (int i_0 = aesl_tmp_377; i_0 <= aesl_tmp_376 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_375[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_29_29_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_29_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_377) => (aesl_tmp_376 - 1) @ (1)
							for (int i_0 = aesl_tmp_377; i_0 <= aesl_tmp_376 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_375[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_375[0]
								// output_left_conversion : aesl_tmp_375[i_0]
								// output_type_conversion : (matrix_o_V_lv0_29_29_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_375[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_375[i_0] = (matrix_o_V_lv0_29_29_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_30_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_30_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_30_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_30_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_30_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_30_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_30_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_30_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_30_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_30_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_379)
			{
				aesl_tmp_379 = i;
			}

			if (aesl_tmp_379 > 0 && aesl_tmp_378.size() < aesl_tmp_379)
			{
				int aesl_tmp_378_size = aesl_tmp_378.size();

				for (int tmp_aesl_tmp_378 = 0; tmp_aesl_tmp_378 < aesl_tmp_379 - aesl_tmp_378_size; tmp_aesl_tmp_378++)
				{
					short tmp;
					aesl_tmp_378.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_30_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_30_30_2 = new sc_lv<16>[aesl_tmp_379 - aesl_tmp_380];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_380) => (aesl_tmp_379 - 1) @ (1)
							for (int i_0 = aesl_tmp_380; i_0 <= aesl_tmp_379 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_378[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_30_30_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_30_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_380) => (aesl_tmp_379 - 1) @ (1)
							for (int i_0 = aesl_tmp_380; i_0 <= aesl_tmp_379 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_378[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_378[0]
								// output_left_conversion : aesl_tmp_378[i_0]
								// output_type_conversion : (matrix_o_V_lv0_30_30_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_378[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_378[i_0] = (matrix_o_V_lv0_30_30_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_31_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_31_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_31_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_31_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_31_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_31_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_31_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_31_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_31_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_31_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_382)
			{
				aesl_tmp_382 = i;
			}

			if (aesl_tmp_382 > 0 && aesl_tmp_381.size() < aesl_tmp_382)
			{
				int aesl_tmp_381_size = aesl_tmp_381.size();

				for (int tmp_aesl_tmp_381 = 0; tmp_aesl_tmp_381 < aesl_tmp_382 - aesl_tmp_381_size; tmp_aesl_tmp_381++)
				{
					short tmp;
					aesl_tmp_381.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_31_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_31_31_2 = new sc_lv<16>[aesl_tmp_382 - aesl_tmp_383];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_383) => (aesl_tmp_382 - 1) @ (1)
							for (int i_0 = aesl_tmp_383; i_0 <= aesl_tmp_382 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_381[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_31_31_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_31_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_383) => (aesl_tmp_382 - 1) @ (1)
							for (int i_0 = aesl_tmp_383; i_0 <= aesl_tmp_382 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_381[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_381[0]
								// output_left_conversion : aesl_tmp_381[i_0]
								// output_type_conversion : (matrix_o_V_lv0_31_31_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_381[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_381[i_0] = (matrix_o_V_lv0_31_31_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_32_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_32_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_32_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_32_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_32_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_32_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_32_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_32_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_32_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_32_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_385)
			{
				aesl_tmp_385 = i;
			}

			if (aesl_tmp_385 > 0 && aesl_tmp_384.size() < aesl_tmp_385)
			{
				int aesl_tmp_384_size = aesl_tmp_384.size();

				for (int tmp_aesl_tmp_384 = 0; tmp_aesl_tmp_384 < aesl_tmp_385 - aesl_tmp_384_size; tmp_aesl_tmp_384++)
				{
					short tmp;
					aesl_tmp_384.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_32_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_32_32_2 = new sc_lv<16>[aesl_tmp_385 - aesl_tmp_386];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_386) => (aesl_tmp_385 - 1) @ (1)
							for (int i_0 = aesl_tmp_386; i_0 <= aesl_tmp_385 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_384[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_32_32_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_32_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_386) => (aesl_tmp_385 - 1) @ (1)
							for (int i_0 = aesl_tmp_386; i_0 <= aesl_tmp_385 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_384[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_384[0]
								// output_left_conversion : aesl_tmp_384[i_0]
								// output_type_conversion : (matrix_o_V_lv0_32_32_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_384[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_384[i_0] = (matrix_o_V_lv0_32_32_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_33_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_33_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_33_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_33_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_33_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_33_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_33_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_33_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_33_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_33_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_388)
			{
				aesl_tmp_388 = i;
			}

			if (aesl_tmp_388 > 0 && aesl_tmp_387.size() < aesl_tmp_388)
			{
				int aesl_tmp_387_size = aesl_tmp_387.size();

				for (int tmp_aesl_tmp_387 = 0; tmp_aesl_tmp_387 < aesl_tmp_388 - aesl_tmp_387_size; tmp_aesl_tmp_387++)
				{
					short tmp;
					aesl_tmp_387.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_33_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_33_33_2 = new sc_lv<16>[aesl_tmp_388 - aesl_tmp_389];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_389) => (aesl_tmp_388 - 1) @ (1)
							for (int i_0 = aesl_tmp_389; i_0 <= aesl_tmp_388 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_387[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_33_33_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_33_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_389) => (aesl_tmp_388 - 1) @ (1)
							for (int i_0 = aesl_tmp_389; i_0 <= aesl_tmp_388 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_387[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_387[0]
								// output_left_conversion : aesl_tmp_387[i_0]
								// output_type_conversion : (matrix_o_V_lv0_33_33_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_387[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_387[i_0] = (matrix_o_V_lv0_33_33_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_34_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_34_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_34_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_34_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_34_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_34_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_34_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_34_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_34_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_34_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_391)
			{
				aesl_tmp_391 = i;
			}

			if (aesl_tmp_391 > 0 && aesl_tmp_390.size() < aesl_tmp_391)
			{
				int aesl_tmp_390_size = aesl_tmp_390.size();

				for (int tmp_aesl_tmp_390 = 0; tmp_aesl_tmp_390 < aesl_tmp_391 - aesl_tmp_390_size; tmp_aesl_tmp_390++)
				{
					short tmp;
					aesl_tmp_390.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_34_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_34_34_2 = new sc_lv<16>[aesl_tmp_391 - aesl_tmp_392];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_392) => (aesl_tmp_391 - 1) @ (1)
							for (int i_0 = aesl_tmp_392; i_0 <= aesl_tmp_391 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_390[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_34_34_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_34_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_392) => (aesl_tmp_391 - 1) @ (1)
							for (int i_0 = aesl_tmp_392; i_0 <= aesl_tmp_391 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_390[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_390[0]
								// output_left_conversion : aesl_tmp_390[i_0]
								// output_type_conversion : (matrix_o_V_lv0_34_34_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_390[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_390[i_0] = (matrix_o_V_lv0_34_34_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_35_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_35_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_35_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_35_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_35_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_35_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_35_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_35_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_35_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_35_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_394)
			{
				aesl_tmp_394 = i;
			}

			if (aesl_tmp_394 > 0 && aesl_tmp_393.size() < aesl_tmp_394)
			{
				int aesl_tmp_393_size = aesl_tmp_393.size();

				for (int tmp_aesl_tmp_393 = 0; tmp_aesl_tmp_393 < aesl_tmp_394 - aesl_tmp_393_size; tmp_aesl_tmp_393++)
				{
					short tmp;
					aesl_tmp_393.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_35_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_35_35_2 = new sc_lv<16>[aesl_tmp_394 - aesl_tmp_395];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_395) => (aesl_tmp_394 - 1) @ (1)
							for (int i_0 = aesl_tmp_395; i_0 <= aesl_tmp_394 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_393[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_35_35_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_35_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_395) => (aesl_tmp_394 - 1) @ (1)
							for (int i_0 = aesl_tmp_395; i_0 <= aesl_tmp_394 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_393[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_393[0]
								// output_left_conversion : aesl_tmp_393[i_0]
								// output_type_conversion : (matrix_o_V_lv0_35_35_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_393[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_393[i_0] = (matrix_o_V_lv0_35_35_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_36_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_36_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_36_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_36_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_36_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_36_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_36_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_36_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_36_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_36_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_397)
			{
				aesl_tmp_397 = i;
			}

			if (aesl_tmp_397 > 0 && aesl_tmp_396.size() < aesl_tmp_397)
			{
				int aesl_tmp_396_size = aesl_tmp_396.size();

				for (int tmp_aesl_tmp_396 = 0; tmp_aesl_tmp_396 < aesl_tmp_397 - aesl_tmp_396_size; tmp_aesl_tmp_396++)
				{
					short tmp;
					aesl_tmp_396.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_36_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_36_36_2 = new sc_lv<16>[aesl_tmp_397 - aesl_tmp_398];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_398) => (aesl_tmp_397 - 1) @ (1)
							for (int i_0 = aesl_tmp_398; i_0 <= aesl_tmp_397 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_396[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_36_36_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_36_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_398) => (aesl_tmp_397 - 1) @ (1)
							for (int i_0 = aesl_tmp_398; i_0 <= aesl_tmp_397 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_396[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_396[0]
								// output_left_conversion : aesl_tmp_396[i_0]
								// output_type_conversion : (matrix_o_V_lv0_36_36_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_396[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_396[i_0] = (matrix_o_V_lv0_36_36_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_37_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_37_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_37_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_37_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_37_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_37_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_37_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_37_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_37_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_37_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_400)
			{
				aesl_tmp_400 = i;
			}

			if (aesl_tmp_400 > 0 && aesl_tmp_399.size() < aesl_tmp_400)
			{
				int aesl_tmp_399_size = aesl_tmp_399.size();

				for (int tmp_aesl_tmp_399 = 0; tmp_aesl_tmp_399 < aesl_tmp_400 - aesl_tmp_399_size; tmp_aesl_tmp_399++)
				{
					short tmp;
					aesl_tmp_399.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_37_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_37_37_2 = new sc_lv<16>[aesl_tmp_400 - aesl_tmp_401];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_401) => (aesl_tmp_400 - 1) @ (1)
							for (int i_0 = aesl_tmp_401; i_0 <= aesl_tmp_400 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_399[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_37_37_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_37_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_401) => (aesl_tmp_400 - 1) @ (1)
							for (int i_0 = aesl_tmp_401; i_0 <= aesl_tmp_400 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_399[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_399[0]
								// output_left_conversion : aesl_tmp_399[i_0]
								// output_type_conversion : (matrix_o_V_lv0_37_37_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_399[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_399[i_0] = (matrix_o_V_lv0_37_37_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_38_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_38_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_38_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_38_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_38_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_38_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_38_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_38_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_38_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_38_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_403)
			{
				aesl_tmp_403 = i;
			}

			if (aesl_tmp_403 > 0 && aesl_tmp_402.size() < aesl_tmp_403)
			{
				int aesl_tmp_402_size = aesl_tmp_402.size();

				for (int tmp_aesl_tmp_402 = 0; tmp_aesl_tmp_402 < aesl_tmp_403 - aesl_tmp_402_size; tmp_aesl_tmp_402++)
				{
					short tmp;
					aesl_tmp_402.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_38_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_38_38_2 = new sc_lv<16>[aesl_tmp_403 - aesl_tmp_404];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_404) => (aesl_tmp_403 - 1) @ (1)
							for (int i_0 = aesl_tmp_404; i_0 <= aesl_tmp_403 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_402[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_38_38_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_38_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_404) => (aesl_tmp_403 - 1) @ (1)
							for (int i_0 = aesl_tmp_404; i_0 <= aesl_tmp_403 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_402[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_402[0]
								// output_left_conversion : aesl_tmp_402[i_0]
								// output_type_conversion : (matrix_o_V_lv0_38_38_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_402[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_402[i_0] = (matrix_o_V_lv0_38_38_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_39_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_39_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_39_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_39_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_39_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_39_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_39_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_39_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_39_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_39_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_406)
			{
				aesl_tmp_406 = i;
			}

			if (aesl_tmp_406 > 0 && aesl_tmp_405.size() < aesl_tmp_406)
			{
				int aesl_tmp_405_size = aesl_tmp_405.size();

				for (int tmp_aesl_tmp_405 = 0; tmp_aesl_tmp_405 < aesl_tmp_406 - aesl_tmp_405_size; tmp_aesl_tmp_405++)
				{
					short tmp;
					aesl_tmp_405.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_39_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_39_39_2 = new sc_lv<16>[aesl_tmp_406 - aesl_tmp_407];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_407) => (aesl_tmp_406 - 1) @ (1)
							for (int i_0 = aesl_tmp_407; i_0 <= aesl_tmp_406 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_405[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_39_39_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_39_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_407) => (aesl_tmp_406 - 1) @ (1)
							for (int i_0 = aesl_tmp_407; i_0 <= aesl_tmp_406 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_405[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_405[0]
								// output_left_conversion : aesl_tmp_405[i_0]
								// output_type_conversion : (matrix_o_V_lv0_39_39_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_405[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_405[i_0] = (matrix_o_V_lv0_39_39_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_40_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_40_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_40_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_40_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_40_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_40_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_40_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_40_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_40_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_40_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_409)
			{
				aesl_tmp_409 = i;
			}

			if (aesl_tmp_409 > 0 && aesl_tmp_408.size() < aesl_tmp_409)
			{
				int aesl_tmp_408_size = aesl_tmp_408.size();

				for (int tmp_aesl_tmp_408 = 0; tmp_aesl_tmp_408 < aesl_tmp_409 - aesl_tmp_408_size; tmp_aesl_tmp_408++)
				{
					short tmp;
					aesl_tmp_408.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_40_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_40_40_2 = new sc_lv<16>[aesl_tmp_409 - aesl_tmp_410];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_410) => (aesl_tmp_409 - 1) @ (1)
							for (int i_0 = aesl_tmp_410; i_0 <= aesl_tmp_409 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_408[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_40_40_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_40_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_410) => (aesl_tmp_409 - 1) @ (1)
							for (int i_0 = aesl_tmp_410; i_0 <= aesl_tmp_409 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_408[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_408[0]
								// output_left_conversion : aesl_tmp_408[i_0]
								// output_type_conversion : (matrix_o_V_lv0_40_40_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_408[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_408[i_0] = (matrix_o_V_lv0_40_40_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_41_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_41_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_41_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_41_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_41_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_41_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_41_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_41_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_41_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_41_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_412)
			{
				aesl_tmp_412 = i;
			}

			if (aesl_tmp_412 > 0 && aesl_tmp_411.size() < aesl_tmp_412)
			{
				int aesl_tmp_411_size = aesl_tmp_411.size();

				for (int tmp_aesl_tmp_411 = 0; tmp_aesl_tmp_411 < aesl_tmp_412 - aesl_tmp_411_size; tmp_aesl_tmp_411++)
				{
					short tmp;
					aesl_tmp_411.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_41_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_41_41_2 = new sc_lv<16>[aesl_tmp_412 - aesl_tmp_413];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_413) => (aesl_tmp_412 - 1) @ (1)
							for (int i_0 = aesl_tmp_413; i_0 <= aesl_tmp_412 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_411[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_41_41_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_41_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_413) => (aesl_tmp_412 - 1) @ (1)
							for (int i_0 = aesl_tmp_413; i_0 <= aesl_tmp_412 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_411[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_411[0]
								// output_left_conversion : aesl_tmp_411[i_0]
								// output_type_conversion : (matrix_o_V_lv0_41_41_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_411[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_411[i_0] = (matrix_o_V_lv0_41_41_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_42_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_42_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_42_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_42_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_42_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_42_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_42_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_42_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_42_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_42_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_415)
			{
				aesl_tmp_415 = i;
			}

			if (aesl_tmp_415 > 0 && aesl_tmp_414.size() < aesl_tmp_415)
			{
				int aesl_tmp_414_size = aesl_tmp_414.size();

				for (int tmp_aesl_tmp_414 = 0; tmp_aesl_tmp_414 < aesl_tmp_415 - aesl_tmp_414_size; tmp_aesl_tmp_414++)
				{
					short tmp;
					aesl_tmp_414.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_42_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_42_42_2 = new sc_lv<16>[aesl_tmp_415 - aesl_tmp_416];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_416) => (aesl_tmp_415 - 1) @ (1)
							for (int i_0 = aesl_tmp_416; i_0 <= aesl_tmp_415 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_414[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_42_42_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_42_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_416) => (aesl_tmp_415 - 1) @ (1)
							for (int i_0 = aesl_tmp_416; i_0 <= aesl_tmp_415 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_414[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_414[0]
								// output_left_conversion : aesl_tmp_414[i_0]
								// output_type_conversion : (matrix_o_V_lv0_42_42_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_414[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_414[i_0] = (matrix_o_V_lv0_42_42_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_43_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_43_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_43_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_43_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_43_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_43_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_43_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_43_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_43_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_43_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_418)
			{
				aesl_tmp_418 = i;
			}

			if (aesl_tmp_418 > 0 && aesl_tmp_417.size() < aesl_tmp_418)
			{
				int aesl_tmp_417_size = aesl_tmp_417.size();

				for (int tmp_aesl_tmp_417 = 0; tmp_aesl_tmp_417 < aesl_tmp_418 - aesl_tmp_417_size; tmp_aesl_tmp_417++)
				{
					short tmp;
					aesl_tmp_417.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_43_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_43_43_2 = new sc_lv<16>[aesl_tmp_418 - aesl_tmp_419];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_419) => (aesl_tmp_418 - 1) @ (1)
							for (int i_0 = aesl_tmp_419; i_0 <= aesl_tmp_418 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_417[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_43_43_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_43_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_419) => (aesl_tmp_418 - 1) @ (1)
							for (int i_0 = aesl_tmp_419; i_0 <= aesl_tmp_418 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_417[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_417[0]
								// output_left_conversion : aesl_tmp_417[i_0]
								// output_type_conversion : (matrix_o_V_lv0_43_43_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_417[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_417[i_0] = (matrix_o_V_lv0_43_43_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_44_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_44_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_44_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_44_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_44_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_44_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_44_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_44_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_44_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_44_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_421)
			{
				aesl_tmp_421 = i;
			}

			if (aesl_tmp_421 > 0 && aesl_tmp_420.size() < aesl_tmp_421)
			{
				int aesl_tmp_420_size = aesl_tmp_420.size();

				for (int tmp_aesl_tmp_420 = 0; tmp_aesl_tmp_420 < aesl_tmp_421 - aesl_tmp_420_size; tmp_aesl_tmp_420++)
				{
					short tmp;
					aesl_tmp_420.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_44_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_44_44_2 = new sc_lv<16>[aesl_tmp_421 - aesl_tmp_422];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_422) => (aesl_tmp_421 - 1) @ (1)
							for (int i_0 = aesl_tmp_422; i_0 <= aesl_tmp_421 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_420[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_44_44_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_44_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_422) => (aesl_tmp_421 - 1) @ (1)
							for (int i_0 = aesl_tmp_422; i_0 <= aesl_tmp_421 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_420[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_420[0]
								// output_left_conversion : aesl_tmp_420[i_0]
								// output_type_conversion : (matrix_o_V_lv0_44_44_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_420[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_420[i_0] = (matrix_o_V_lv0_44_44_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_45_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_45_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_45_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_45_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_45_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_45_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_45_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_45_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_45_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_45_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_424)
			{
				aesl_tmp_424 = i;
			}

			if (aesl_tmp_424 > 0 && aesl_tmp_423.size() < aesl_tmp_424)
			{
				int aesl_tmp_423_size = aesl_tmp_423.size();

				for (int tmp_aesl_tmp_423 = 0; tmp_aesl_tmp_423 < aesl_tmp_424 - aesl_tmp_423_size; tmp_aesl_tmp_423++)
				{
					short tmp;
					aesl_tmp_423.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_45_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_45_45_2 = new sc_lv<16>[aesl_tmp_424 - aesl_tmp_425];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_425) => (aesl_tmp_424 - 1) @ (1)
							for (int i_0 = aesl_tmp_425; i_0 <= aesl_tmp_424 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_423[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_45_45_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_45_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_425) => (aesl_tmp_424 - 1) @ (1)
							for (int i_0 = aesl_tmp_425; i_0 <= aesl_tmp_424 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_423[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_423[0]
								// output_left_conversion : aesl_tmp_423[i_0]
								// output_type_conversion : (matrix_o_V_lv0_45_45_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_423[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_423[i_0] = (matrix_o_V_lv0_45_45_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_46_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_46_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_46_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_46_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_46_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_46_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_46_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_46_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_46_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_46_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_427)
			{
				aesl_tmp_427 = i;
			}

			if (aesl_tmp_427 > 0 && aesl_tmp_426.size() < aesl_tmp_427)
			{
				int aesl_tmp_426_size = aesl_tmp_426.size();

				for (int tmp_aesl_tmp_426 = 0; tmp_aesl_tmp_426 < aesl_tmp_427 - aesl_tmp_426_size; tmp_aesl_tmp_426++)
				{
					short tmp;
					aesl_tmp_426.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_46_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_46_46_2 = new sc_lv<16>[aesl_tmp_427 - aesl_tmp_428];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_428) => (aesl_tmp_427 - 1) @ (1)
							for (int i_0 = aesl_tmp_428; i_0 <= aesl_tmp_427 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_426[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_46_46_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_46_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_428) => (aesl_tmp_427 - 1) @ (1)
							for (int i_0 = aesl_tmp_428; i_0 <= aesl_tmp_427 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_426[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_426[0]
								// output_left_conversion : aesl_tmp_426[i_0]
								// output_type_conversion : (matrix_o_V_lv0_46_46_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_426[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_426[i_0] = (matrix_o_V_lv0_46_46_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_47_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_47_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_47_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_47_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_47_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_47_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_47_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_47_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_47_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_47_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_430)
			{
				aesl_tmp_430 = i;
			}

			if (aesl_tmp_430 > 0 && aesl_tmp_429.size() < aesl_tmp_430)
			{
				int aesl_tmp_429_size = aesl_tmp_429.size();

				for (int tmp_aesl_tmp_429 = 0; tmp_aesl_tmp_429 < aesl_tmp_430 - aesl_tmp_429_size; tmp_aesl_tmp_429++)
				{
					short tmp;
					aesl_tmp_429.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_47_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_47_47_2 = new sc_lv<16>[aesl_tmp_430 - aesl_tmp_431];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_431) => (aesl_tmp_430 - 1) @ (1)
							for (int i_0 = aesl_tmp_431; i_0 <= aesl_tmp_430 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_429[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_47_47_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_47_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_431) => (aesl_tmp_430 - 1) @ (1)
							for (int i_0 = aesl_tmp_431; i_0 <= aesl_tmp_430 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_429[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_429[0]
								// output_left_conversion : aesl_tmp_429[i_0]
								// output_type_conversion : (matrix_o_V_lv0_47_47_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_429[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_429[i_0] = (matrix_o_V_lv0_47_47_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_48_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_48_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_48_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_48_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_48_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_48_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_48_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_48_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_48_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_48_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_433)
			{
				aesl_tmp_433 = i;
			}

			if (aesl_tmp_433 > 0 && aesl_tmp_432.size() < aesl_tmp_433)
			{
				int aesl_tmp_432_size = aesl_tmp_432.size();

				for (int tmp_aesl_tmp_432 = 0; tmp_aesl_tmp_432 < aesl_tmp_433 - aesl_tmp_432_size; tmp_aesl_tmp_432++)
				{
					short tmp;
					aesl_tmp_432.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_48_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_48_48_2 = new sc_lv<16>[aesl_tmp_433 - aesl_tmp_434];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_434) => (aesl_tmp_433 - 1) @ (1)
							for (int i_0 = aesl_tmp_434; i_0 <= aesl_tmp_433 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_432[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_48_48_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_48_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_434) => (aesl_tmp_433 - 1) @ (1)
							for (int i_0 = aesl_tmp_434; i_0 <= aesl_tmp_433 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_432[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_432[0]
								// output_left_conversion : aesl_tmp_432[i_0]
								// output_type_conversion : (matrix_o_V_lv0_48_48_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_432[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_432[i_0] = (matrix_o_V_lv0_48_48_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_49_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_49_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_49_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_49_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_49_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_49_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_49_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_49_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_49_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_49_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_436)
			{
				aesl_tmp_436 = i;
			}

			if (aesl_tmp_436 > 0 && aesl_tmp_435.size() < aesl_tmp_436)
			{
				int aesl_tmp_435_size = aesl_tmp_435.size();

				for (int tmp_aesl_tmp_435 = 0; tmp_aesl_tmp_435 < aesl_tmp_436 - aesl_tmp_435_size; tmp_aesl_tmp_435++)
				{
					short tmp;
					aesl_tmp_435.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_49_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_49_49_2 = new sc_lv<16>[aesl_tmp_436 - aesl_tmp_437];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_437) => (aesl_tmp_436 - 1) @ (1)
							for (int i_0 = aesl_tmp_437; i_0 <= aesl_tmp_436 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_435[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_49_49_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_49_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_437) => (aesl_tmp_436 - 1) @ (1)
							for (int i_0 = aesl_tmp_437; i_0 <= aesl_tmp_436 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_435[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_435[0]
								// output_left_conversion : aesl_tmp_435[i_0]
								// output_type_conversion : (matrix_o_V_lv0_49_49_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_435[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_435[i_0] = (matrix_o_V_lv0_49_49_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_50_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_50_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_50_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_50_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_50_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_50_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_50_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_50_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_50_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_50_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_439)
			{
				aesl_tmp_439 = i;
			}

			if (aesl_tmp_439 > 0 && aesl_tmp_438.size() < aesl_tmp_439)
			{
				int aesl_tmp_438_size = aesl_tmp_438.size();

				for (int tmp_aesl_tmp_438 = 0; tmp_aesl_tmp_438 < aesl_tmp_439 - aesl_tmp_438_size; tmp_aesl_tmp_438++)
				{
					short tmp;
					aesl_tmp_438.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_50_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_50_50_2 = new sc_lv<16>[aesl_tmp_439 - aesl_tmp_440];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_440) => (aesl_tmp_439 - 1) @ (1)
							for (int i_0 = aesl_tmp_440; i_0 <= aesl_tmp_439 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_438[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_50_50_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_50_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_440) => (aesl_tmp_439 - 1) @ (1)
							for (int i_0 = aesl_tmp_440; i_0 <= aesl_tmp_439 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_438[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_438[0]
								// output_left_conversion : aesl_tmp_438[i_0]
								// output_type_conversion : (matrix_o_V_lv0_50_50_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_438[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_438[i_0] = (matrix_o_V_lv0_50_50_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_51_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_51_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_51_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_51_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_51_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_51_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_51_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_51_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_51_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_51_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_442)
			{
				aesl_tmp_442 = i;
			}

			if (aesl_tmp_442 > 0 && aesl_tmp_441.size() < aesl_tmp_442)
			{
				int aesl_tmp_441_size = aesl_tmp_441.size();

				for (int tmp_aesl_tmp_441 = 0; tmp_aesl_tmp_441 < aesl_tmp_442 - aesl_tmp_441_size; tmp_aesl_tmp_441++)
				{
					short tmp;
					aesl_tmp_441.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_51_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_51_51_2 = new sc_lv<16>[aesl_tmp_442 - aesl_tmp_443];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_443) => (aesl_tmp_442 - 1) @ (1)
							for (int i_0 = aesl_tmp_443; i_0 <= aesl_tmp_442 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_441[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_51_51_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_51_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_443) => (aesl_tmp_442 - 1) @ (1)
							for (int i_0 = aesl_tmp_443; i_0 <= aesl_tmp_442 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_441[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_441[0]
								// output_left_conversion : aesl_tmp_441[i_0]
								// output_type_conversion : (matrix_o_V_lv0_51_51_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_441[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_441[i_0] = (matrix_o_V_lv0_51_51_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_52_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_52_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_52_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_52_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_52_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_52_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_52_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_52_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_52_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_52_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_445)
			{
				aesl_tmp_445 = i;
			}

			if (aesl_tmp_445 > 0 && aesl_tmp_444.size() < aesl_tmp_445)
			{
				int aesl_tmp_444_size = aesl_tmp_444.size();

				for (int tmp_aesl_tmp_444 = 0; tmp_aesl_tmp_444 < aesl_tmp_445 - aesl_tmp_444_size; tmp_aesl_tmp_444++)
				{
					short tmp;
					aesl_tmp_444.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_52_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_52_52_2 = new sc_lv<16>[aesl_tmp_445 - aesl_tmp_446];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_446) => (aesl_tmp_445 - 1) @ (1)
							for (int i_0 = aesl_tmp_446; i_0 <= aesl_tmp_445 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_444[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_52_52_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_52_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_446) => (aesl_tmp_445 - 1) @ (1)
							for (int i_0 = aesl_tmp_446; i_0 <= aesl_tmp_445 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_444[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_444[0]
								// output_left_conversion : aesl_tmp_444[i_0]
								// output_type_conversion : (matrix_o_V_lv0_52_52_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_444[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_444[i_0] = (matrix_o_V_lv0_52_52_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_53_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_53_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_53_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_53_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_53_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_53_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_53_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_53_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_53_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_53_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_448)
			{
				aesl_tmp_448 = i;
			}

			if (aesl_tmp_448 > 0 && aesl_tmp_447.size() < aesl_tmp_448)
			{
				int aesl_tmp_447_size = aesl_tmp_447.size();

				for (int tmp_aesl_tmp_447 = 0; tmp_aesl_tmp_447 < aesl_tmp_448 - aesl_tmp_447_size; tmp_aesl_tmp_447++)
				{
					short tmp;
					aesl_tmp_447.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_53_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_53_53_2 = new sc_lv<16>[aesl_tmp_448 - aesl_tmp_449];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_449) => (aesl_tmp_448 - 1) @ (1)
							for (int i_0 = aesl_tmp_449; i_0 <= aesl_tmp_448 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_447[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_53_53_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_53_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_449) => (aesl_tmp_448 - 1) @ (1)
							for (int i_0 = aesl_tmp_449; i_0 <= aesl_tmp_448 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_447[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_447[0]
								// output_left_conversion : aesl_tmp_447[i_0]
								// output_type_conversion : (matrix_o_V_lv0_53_53_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_447[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_447[i_0] = (matrix_o_V_lv0_53_53_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_54_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_54_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_54_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_54_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_54_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_54_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_54_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_54_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_54_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_54_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_451)
			{
				aesl_tmp_451 = i;
			}

			if (aesl_tmp_451 > 0 && aesl_tmp_450.size() < aesl_tmp_451)
			{
				int aesl_tmp_450_size = aesl_tmp_450.size();

				for (int tmp_aesl_tmp_450 = 0; tmp_aesl_tmp_450 < aesl_tmp_451 - aesl_tmp_450_size; tmp_aesl_tmp_450++)
				{
					short tmp;
					aesl_tmp_450.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_54_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_54_54_2 = new sc_lv<16>[aesl_tmp_451 - aesl_tmp_452];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_452) => (aesl_tmp_451 - 1) @ (1)
							for (int i_0 = aesl_tmp_452; i_0 <= aesl_tmp_451 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_450[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_54_54_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_54_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_452) => (aesl_tmp_451 - 1) @ (1)
							for (int i_0 = aesl_tmp_452; i_0 <= aesl_tmp_451 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_450[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_450[0]
								// output_left_conversion : aesl_tmp_450[i_0]
								// output_type_conversion : (matrix_o_V_lv0_54_54_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_450[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_450[i_0] = (matrix_o_V_lv0_54_54_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_55_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_55_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_55_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_55_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_55_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_55_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_55_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_55_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_55_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_55_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_454)
			{
				aesl_tmp_454 = i;
			}

			if (aesl_tmp_454 > 0 && aesl_tmp_453.size() < aesl_tmp_454)
			{
				int aesl_tmp_453_size = aesl_tmp_453.size();

				for (int tmp_aesl_tmp_453 = 0; tmp_aesl_tmp_453 < aesl_tmp_454 - aesl_tmp_453_size; tmp_aesl_tmp_453++)
				{
					short tmp;
					aesl_tmp_453.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_55_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_55_55_2 = new sc_lv<16>[aesl_tmp_454 - aesl_tmp_455];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_455) => (aesl_tmp_454 - 1) @ (1)
							for (int i_0 = aesl_tmp_455; i_0 <= aesl_tmp_454 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_453[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_55_55_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_55_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_455) => (aesl_tmp_454 - 1) @ (1)
							for (int i_0 = aesl_tmp_455; i_0 <= aesl_tmp_454 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_453[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_453[0]
								// output_left_conversion : aesl_tmp_453[i_0]
								// output_type_conversion : (matrix_o_V_lv0_55_55_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_453[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_453[i_0] = (matrix_o_V_lv0_55_55_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_56_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_56_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_56_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_56_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_56_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_56_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_56_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_56_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_56_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_56_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_457)
			{
				aesl_tmp_457 = i;
			}

			if (aesl_tmp_457 > 0 && aesl_tmp_456.size() < aesl_tmp_457)
			{
				int aesl_tmp_456_size = aesl_tmp_456.size();

				for (int tmp_aesl_tmp_456 = 0; tmp_aesl_tmp_456 < aesl_tmp_457 - aesl_tmp_456_size; tmp_aesl_tmp_456++)
				{
					short tmp;
					aesl_tmp_456.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_56_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_56_56_2 = new sc_lv<16>[aesl_tmp_457 - aesl_tmp_458];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_458) => (aesl_tmp_457 - 1) @ (1)
							for (int i_0 = aesl_tmp_458; i_0 <= aesl_tmp_457 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_456[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_56_56_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_56_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_458) => (aesl_tmp_457 - 1) @ (1)
							for (int i_0 = aesl_tmp_458; i_0 <= aesl_tmp_457 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_456[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_456[0]
								// output_left_conversion : aesl_tmp_456[i_0]
								// output_type_conversion : (matrix_o_V_lv0_56_56_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_456[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_456[i_0] = (matrix_o_V_lv0_56_56_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_57_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_57_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_57_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_57_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_57_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_57_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_57_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_57_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_57_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_57_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_460)
			{
				aesl_tmp_460 = i;
			}

			if (aesl_tmp_460 > 0 && aesl_tmp_459.size() < aesl_tmp_460)
			{
				int aesl_tmp_459_size = aesl_tmp_459.size();

				for (int tmp_aesl_tmp_459 = 0; tmp_aesl_tmp_459 < aesl_tmp_460 - aesl_tmp_459_size; tmp_aesl_tmp_459++)
				{
					short tmp;
					aesl_tmp_459.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_57_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_57_57_2 = new sc_lv<16>[aesl_tmp_460 - aesl_tmp_461];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_461) => (aesl_tmp_460 - 1) @ (1)
							for (int i_0 = aesl_tmp_461; i_0 <= aesl_tmp_460 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_459[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_57_57_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_57_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_461) => (aesl_tmp_460 - 1) @ (1)
							for (int i_0 = aesl_tmp_461; i_0 <= aesl_tmp_460 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_459[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_459[0]
								// output_left_conversion : aesl_tmp_459[i_0]
								// output_type_conversion : (matrix_o_V_lv0_57_57_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_459[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_459[i_0] = (matrix_o_V_lv0_57_57_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_58_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_58_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_58_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_58_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_58_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_58_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_58_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_58_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_58_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_58_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_463)
			{
				aesl_tmp_463 = i;
			}

			if (aesl_tmp_463 > 0 && aesl_tmp_462.size() < aesl_tmp_463)
			{
				int aesl_tmp_462_size = aesl_tmp_462.size();

				for (int tmp_aesl_tmp_462 = 0; tmp_aesl_tmp_462 < aesl_tmp_463 - aesl_tmp_462_size; tmp_aesl_tmp_462++)
				{
					short tmp;
					aesl_tmp_462.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_58_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_58_58_2 = new sc_lv<16>[aesl_tmp_463 - aesl_tmp_464];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_464) => (aesl_tmp_463 - 1) @ (1)
							for (int i_0 = aesl_tmp_464; i_0 <= aesl_tmp_463 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_462[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_58_58_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_58_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_464) => (aesl_tmp_463 - 1) @ (1)
							for (int i_0 = aesl_tmp_464; i_0 <= aesl_tmp_463 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_462[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_462[0]
								// output_left_conversion : aesl_tmp_462[i_0]
								// output_type_conversion : (matrix_o_V_lv0_58_58_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_462[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_462[i_0] = (matrix_o_V_lv0_58_58_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_59_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_59_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_59_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_59_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_59_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_59_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_59_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_59_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_59_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_59_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_466)
			{
				aesl_tmp_466 = i;
			}

			if (aesl_tmp_466 > 0 && aesl_tmp_465.size() < aesl_tmp_466)
			{
				int aesl_tmp_465_size = aesl_tmp_465.size();

				for (int tmp_aesl_tmp_465 = 0; tmp_aesl_tmp_465 < aesl_tmp_466 - aesl_tmp_465_size; tmp_aesl_tmp_465++)
				{
					short tmp;
					aesl_tmp_465.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_59_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_59_59_2 = new sc_lv<16>[aesl_tmp_466 - aesl_tmp_467];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_467) => (aesl_tmp_466 - 1) @ (1)
							for (int i_0 = aesl_tmp_467; i_0 <= aesl_tmp_466 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_465[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_59_59_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_59_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_467) => (aesl_tmp_466 - 1) @ (1)
							for (int i_0 = aesl_tmp_467; i_0 <= aesl_tmp_466 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_465[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_465[0]
								// output_left_conversion : aesl_tmp_465[i_0]
								// output_type_conversion : (matrix_o_V_lv0_59_59_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_465[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_465[i_0] = (matrix_o_V_lv0_59_59_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_60_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_60_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_60_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_60_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_60_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_60_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_60_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_60_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_60_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_60_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_469)
			{
				aesl_tmp_469 = i;
			}

			if (aesl_tmp_469 > 0 && aesl_tmp_468.size() < aesl_tmp_469)
			{
				int aesl_tmp_468_size = aesl_tmp_468.size();

				for (int tmp_aesl_tmp_468 = 0; tmp_aesl_tmp_468 < aesl_tmp_469 - aesl_tmp_468_size; tmp_aesl_tmp_468++)
				{
					short tmp;
					aesl_tmp_468.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_60_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_60_60_2 = new sc_lv<16>[aesl_tmp_469 - aesl_tmp_470];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_470) => (aesl_tmp_469 - 1) @ (1)
							for (int i_0 = aesl_tmp_470; i_0 <= aesl_tmp_469 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_468[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_60_60_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_60_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_470) => (aesl_tmp_469 - 1) @ (1)
							for (int i_0 = aesl_tmp_470; i_0 <= aesl_tmp_469 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_468[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_468[0]
								// output_left_conversion : aesl_tmp_468[i_0]
								// output_type_conversion : (matrix_o_V_lv0_60_60_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_468[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_468[i_0] = (matrix_o_V_lv0_60_60_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_61_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_61_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_61_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_61_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_61_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_61_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_61_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_61_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_61_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_61_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_472)
			{
				aesl_tmp_472 = i;
			}

			if (aesl_tmp_472 > 0 && aesl_tmp_471.size() < aesl_tmp_472)
			{
				int aesl_tmp_471_size = aesl_tmp_471.size();

				for (int tmp_aesl_tmp_471 = 0; tmp_aesl_tmp_471 < aesl_tmp_472 - aesl_tmp_471_size; tmp_aesl_tmp_471++)
				{
					short tmp;
					aesl_tmp_471.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_61_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_61_61_2 = new sc_lv<16>[aesl_tmp_472 - aesl_tmp_473];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_473) => (aesl_tmp_472 - 1) @ (1)
							for (int i_0 = aesl_tmp_473; i_0 <= aesl_tmp_472 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_471[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_61_61_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_61_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_473) => (aesl_tmp_472 - 1) @ (1)
							for (int i_0 = aesl_tmp_473; i_0 <= aesl_tmp_472 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_471[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_471[0]
								// output_left_conversion : aesl_tmp_471[i_0]
								// output_type_conversion : (matrix_o_V_lv0_61_61_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_471[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_471[i_0] = (matrix_o_V_lv0_61_61_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_62_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_62_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_62_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_62_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_62_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_62_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_62_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_62_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_62_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_62_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_475)
			{
				aesl_tmp_475 = i;
			}

			if (aesl_tmp_475 > 0 && aesl_tmp_474.size() < aesl_tmp_475)
			{
				int aesl_tmp_474_size = aesl_tmp_474.size();

				for (int tmp_aesl_tmp_474 = 0; tmp_aesl_tmp_474 < aesl_tmp_475 - aesl_tmp_474_size; tmp_aesl_tmp_474++)
				{
					short tmp;
					aesl_tmp_474.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_62_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_62_62_2 = new sc_lv<16>[aesl_tmp_475 - aesl_tmp_476];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_476) => (aesl_tmp_475 - 1) @ (1)
							for (int i_0 = aesl_tmp_476; i_0 <= aesl_tmp_475 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_474[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_62_62_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_62_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_476) => (aesl_tmp_475 - 1) @ (1)
							for (int i_0 = aesl_tmp_476; i_0 <= aesl_tmp_475 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_474[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_474[0]
								// output_left_conversion : aesl_tmp_474[i_0]
								// output_type_conversion : (matrix_o_V_lv0_62_62_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_474[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_474[i_0] = (matrix_o_V_lv0_62_62_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_63_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_63_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_63_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_63_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_63_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_63_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_63_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_63_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_63_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_63_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_478)
			{
				aesl_tmp_478 = i;
			}

			if (aesl_tmp_478 > 0 && aesl_tmp_477.size() < aesl_tmp_478)
			{
				int aesl_tmp_477_size = aesl_tmp_477.size();

				for (int tmp_aesl_tmp_477 = 0; tmp_aesl_tmp_477 < aesl_tmp_478 - aesl_tmp_477_size; tmp_aesl_tmp_477++)
				{
					short tmp;
					aesl_tmp_477.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_63_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_63_63_2 = new sc_lv<16>[aesl_tmp_478 - aesl_tmp_479];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_479) => (aesl_tmp_478 - 1) @ (1)
							for (int i_0 = aesl_tmp_479; i_0 <= aesl_tmp_478 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_477[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_63_63_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_63_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_479) => (aesl_tmp_478 - 1) @ (1)
							for (int i_0 = aesl_tmp_479; i_0 <= aesl_tmp_478 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_477[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_477[0]
								// output_left_conversion : aesl_tmp_477[i_0]
								// output_type_conversion : (matrix_o_V_lv0_63_63_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_477[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_477[i_0] = (matrix_o_V_lv0_63_63_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_64_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_64_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_64_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_64_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_64_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_64_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_64_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_64_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_64_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_64_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_481)
			{
				aesl_tmp_481 = i;
			}

			if (aesl_tmp_481 > 0 && aesl_tmp_480.size() < aesl_tmp_481)
			{
				int aesl_tmp_480_size = aesl_tmp_480.size();

				for (int tmp_aesl_tmp_480 = 0; tmp_aesl_tmp_480 < aesl_tmp_481 - aesl_tmp_480_size; tmp_aesl_tmp_480++)
				{
					short tmp;
					aesl_tmp_480.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_64_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_64_64_2 = new sc_lv<16>[aesl_tmp_481 - aesl_tmp_482];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_482) => (aesl_tmp_481 - 1) @ (1)
							for (int i_0 = aesl_tmp_482; i_0 <= aesl_tmp_481 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_480[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_64_64_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_64_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_482) => (aesl_tmp_481 - 1) @ (1)
							for (int i_0 = aesl_tmp_482; i_0 <= aesl_tmp_481 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_480[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_480[0]
								// output_left_conversion : aesl_tmp_480[i_0]
								// output_type_conversion : (matrix_o_V_lv0_64_64_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_480[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_480[i_0] = (matrix_o_V_lv0_64_64_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_65_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_65_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_65_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_65_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_65_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_65_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_65_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_65_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_65_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_65_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_484)
			{
				aesl_tmp_484 = i;
			}

			if (aesl_tmp_484 > 0 && aesl_tmp_483.size() < aesl_tmp_484)
			{
				int aesl_tmp_483_size = aesl_tmp_483.size();

				for (int tmp_aesl_tmp_483 = 0; tmp_aesl_tmp_483 < aesl_tmp_484 - aesl_tmp_483_size; tmp_aesl_tmp_483++)
				{
					short tmp;
					aesl_tmp_483.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_65_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_65_65_2 = new sc_lv<16>[aesl_tmp_484 - aesl_tmp_485];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_485) => (aesl_tmp_484 - 1) @ (1)
							for (int i_0 = aesl_tmp_485; i_0 <= aesl_tmp_484 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_483[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_65_65_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_65_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_485) => (aesl_tmp_484 - 1) @ (1)
							for (int i_0 = aesl_tmp_485; i_0 <= aesl_tmp_484 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_483[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_483[0]
								// output_left_conversion : aesl_tmp_483[i_0]
								// output_type_conversion : (matrix_o_V_lv0_65_65_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_483[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_483[i_0] = (matrix_o_V_lv0_65_65_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_66_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_66_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_66_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_66_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_66_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_66_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_66_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_66_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_66_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_66_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_487)
			{
				aesl_tmp_487 = i;
			}

			if (aesl_tmp_487 > 0 && aesl_tmp_486.size() < aesl_tmp_487)
			{
				int aesl_tmp_486_size = aesl_tmp_486.size();

				for (int tmp_aesl_tmp_486 = 0; tmp_aesl_tmp_486 < aesl_tmp_487 - aesl_tmp_486_size; tmp_aesl_tmp_486++)
				{
					short tmp;
					aesl_tmp_486.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_66_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_66_66_2 = new sc_lv<16>[aesl_tmp_487 - aesl_tmp_488];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_488) => (aesl_tmp_487 - 1) @ (1)
							for (int i_0 = aesl_tmp_488; i_0 <= aesl_tmp_487 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_486[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_66_66_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_66_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_488) => (aesl_tmp_487 - 1) @ (1)
							for (int i_0 = aesl_tmp_488; i_0 <= aesl_tmp_487 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_486[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_486[0]
								// output_left_conversion : aesl_tmp_486[i_0]
								// output_type_conversion : (matrix_o_V_lv0_66_66_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_486[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_486[i_0] = (matrix_o_V_lv0_66_66_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_67_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_67_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_67_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_67_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_67_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_67_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_67_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_67_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_67_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_67_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_490)
			{
				aesl_tmp_490 = i;
			}

			if (aesl_tmp_490 > 0 && aesl_tmp_489.size() < aesl_tmp_490)
			{
				int aesl_tmp_489_size = aesl_tmp_489.size();

				for (int tmp_aesl_tmp_489 = 0; tmp_aesl_tmp_489 < aesl_tmp_490 - aesl_tmp_489_size; tmp_aesl_tmp_489++)
				{
					short tmp;
					aesl_tmp_489.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_67_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_67_67_2 = new sc_lv<16>[aesl_tmp_490 - aesl_tmp_491];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_491) => (aesl_tmp_490 - 1) @ (1)
							for (int i_0 = aesl_tmp_491; i_0 <= aesl_tmp_490 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_489[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_67_67_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_67_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_491) => (aesl_tmp_490 - 1) @ (1)
							for (int i_0 = aesl_tmp_491; i_0 <= aesl_tmp_490 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_489[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_489[0]
								// output_left_conversion : aesl_tmp_489[i_0]
								// output_type_conversion : (matrix_o_V_lv0_67_67_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_489[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_489[i_0] = (matrix_o_V_lv0_67_67_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_68_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_68_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_68_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_68_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_68_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_68_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_68_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_68_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_68_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_68_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_493)
			{
				aesl_tmp_493 = i;
			}

			if (aesl_tmp_493 > 0 && aesl_tmp_492.size() < aesl_tmp_493)
			{
				int aesl_tmp_492_size = aesl_tmp_492.size();

				for (int tmp_aesl_tmp_492 = 0; tmp_aesl_tmp_492 < aesl_tmp_493 - aesl_tmp_492_size; tmp_aesl_tmp_492++)
				{
					short tmp;
					aesl_tmp_492.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_68_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_68_68_2 = new sc_lv<16>[aesl_tmp_493 - aesl_tmp_494];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_494) => (aesl_tmp_493 - 1) @ (1)
							for (int i_0 = aesl_tmp_494; i_0 <= aesl_tmp_493 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_492[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_68_68_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_68_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_494) => (aesl_tmp_493 - 1) @ (1)
							for (int i_0 = aesl_tmp_494; i_0 <= aesl_tmp_493 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_492[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_492[0]
								// output_left_conversion : aesl_tmp_492[i_0]
								// output_type_conversion : (matrix_o_V_lv0_68_68_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_492[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_492[i_0] = (matrix_o_V_lv0_68_68_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_69_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_69_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_69_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_69_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_69_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_69_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_69_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_69_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_69_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_69_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_496)
			{
				aesl_tmp_496 = i;
			}

			if (aesl_tmp_496 > 0 && aesl_tmp_495.size() < aesl_tmp_496)
			{
				int aesl_tmp_495_size = aesl_tmp_495.size();

				for (int tmp_aesl_tmp_495 = 0; tmp_aesl_tmp_495 < aesl_tmp_496 - aesl_tmp_495_size; tmp_aesl_tmp_495++)
				{
					short tmp;
					aesl_tmp_495.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_69_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_69_69_2 = new sc_lv<16>[aesl_tmp_496 - aesl_tmp_497];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_497) => (aesl_tmp_496 - 1) @ (1)
							for (int i_0 = aesl_tmp_497; i_0 <= aesl_tmp_496 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_495[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_69_69_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_69_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_497) => (aesl_tmp_496 - 1) @ (1)
							for (int i_0 = aesl_tmp_497; i_0 <= aesl_tmp_496 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_495[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_495[0]
								// output_left_conversion : aesl_tmp_495[i_0]
								// output_type_conversion : (matrix_o_V_lv0_69_69_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_495[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_495[i_0] = (matrix_o_V_lv0_69_69_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_70_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_70_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_70_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_70_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_70_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_70_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_70_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_70_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_70_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_70_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_499)
			{
				aesl_tmp_499 = i;
			}

			if (aesl_tmp_499 > 0 && aesl_tmp_498.size() < aesl_tmp_499)
			{
				int aesl_tmp_498_size = aesl_tmp_498.size();

				for (int tmp_aesl_tmp_498 = 0; tmp_aesl_tmp_498 < aesl_tmp_499 - aesl_tmp_498_size; tmp_aesl_tmp_498++)
				{
					short tmp;
					aesl_tmp_498.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_70_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_70_70_2 = new sc_lv<16>[aesl_tmp_499 - aesl_tmp_500];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_500) => (aesl_tmp_499 - 1) @ (1)
							for (int i_0 = aesl_tmp_500; i_0 <= aesl_tmp_499 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_498[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_70_70_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_70_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_500) => (aesl_tmp_499 - 1) @ (1)
							for (int i_0 = aesl_tmp_500; i_0 <= aesl_tmp_499 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_498[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_498[0]
								// output_left_conversion : aesl_tmp_498[i_0]
								// output_type_conversion : (matrix_o_V_lv0_70_70_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_498[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_498[i_0] = (matrix_o_V_lv0_70_70_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_71_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_71_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_71_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_71_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_71_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_71_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_71_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_71_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_71_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_71_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_502)
			{
				aesl_tmp_502 = i;
			}

			if (aesl_tmp_502 > 0 && aesl_tmp_501.size() < aesl_tmp_502)
			{
				int aesl_tmp_501_size = aesl_tmp_501.size();

				for (int tmp_aesl_tmp_501 = 0; tmp_aesl_tmp_501 < aesl_tmp_502 - aesl_tmp_501_size; tmp_aesl_tmp_501++)
				{
					short tmp;
					aesl_tmp_501.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_71_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_71_71_2 = new sc_lv<16>[aesl_tmp_502 - aesl_tmp_503];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_503) => (aesl_tmp_502 - 1) @ (1)
							for (int i_0 = aesl_tmp_503; i_0 <= aesl_tmp_502 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_501[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_71_71_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_71_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_503) => (aesl_tmp_502 - 1) @ (1)
							for (int i_0 = aesl_tmp_503; i_0 <= aesl_tmp_502 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_501[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_501[0]
								// output_left_conversion : aesl_tmp_501[i_0]
								// output_type_conversion : (matrix_o_V_lv0_71_71_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_501[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_501[i_0] = (matrix_o_V_lv0_71_71_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_72_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_72_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_72_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_72_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_72_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_72_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_72_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_72_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_72_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_72_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_505)
			{
				aesl_tmp_505 = i;
			}

			if (aesl_tmp_505 > 0 && aesl_tmp_504.size() < aesl_tmp_505)
			{
				int aesl_tmp_504_size = aesl_tmp_504.size();

				for (int tmp_aesl_tmp_504 = 0; tmp_aesl_tmp_504 < aesl_tmp_505 - aesl_tmp_504_size; tmp_aesl_tmp_504++)
				{
					short tmp;
					aesl_tmp_504.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_72_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_72_72_2 = new sc_lv<16>[aesl_tmp_505 - aesl_tmp_506];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_506) => (aesl_tmp_505 - 1) @ (1)
							for (int i_0 = aesl_tmp_506; i_0 <= aesl_tmp_505 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_504[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_72_72_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_72_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_506) => (aesl_tmp_505 - 1) @ (1)
							for (int i_0 = aesl_tmp_506; i_0 <= aesl_tmp_505 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_504[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_504[0]
								// output_left_conversion : aesl_tmp_504[i_0]
								// output_type_conversion : (matrix_o_V_lv0_72_72_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_504[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_504[i_0] = (matrix_o_V_lv0_72_72_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_73_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_73_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_73_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_73_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_73_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_73_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_73_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_73_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_73_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_73_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_508)
			{
				aesl_tmp_508 = i;
			}

			if (aesl_tmp_508 > 0 && aesl_tmp_507.size() < aesl_tmp_508)
			{
				int aesl_tmp_507_size = aesl_tmp_507.size();

				for (int tmp_aesl_tmp_507 = 0; tmp_aesl_tmp_507 < aesl_tmp_508 - aesl_tmp_507_size; tmp_aesl_tmp_507++)
				{
					short tmp;
					aesl_tmp_507.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_73_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_73_73_2 = new sc_lv<16>[aesl_tmp_508 - aesl_tmp_509];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_509) => (aesl_tmp_508 - 1) @ (1)
							for (int i_0 = aesl_tmp_509; i_0 <= aesl_tmp_508 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_507[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_73_73_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_73_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_509) => (aesl_tmp_508 - 1) @ (1)
							for (int i_0 = aesl_tmp_509; i_0 <= aesl_tmp_508 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_507[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_507[0]
								// output_left_conversion : aesl_tmp_507[i_0]
								// output_type_conversion : (matrix_o_V_lv0_73_73_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_507[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_507[i_0] = (matrix_o_V_lv0_73_73_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_74_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_74_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_74_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_74_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_74_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_74_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_74_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_74_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_74_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_74_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_511)
			{
				aesl_tmp_511 = i;
			}

			if (aesl_tmp_511 > 0 && aesl_tmp_510.size() < aesl_tmp_511)
			{
				int aesl_tmp_510_size = aesl_tmp_510.size();

				for (int tmp_aesl_tmp_510 = 0; tmp_aesl_tmp_510 < aesl_tmp_511 - aesl_tmp_510_size; tmp_aesl_tmp_510++)
				{
					short tmp;
					aesl_tmp_510.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_74_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_74_74_2 = new sc_lv<16>[aesl_tmp_511 - aesl_tmp_512];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_512) => (aesl_tmp_511 - 1) @ (1)
							for (int i_0 = aesl_tmp_512; i_0 <= aesl_tmp_511 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_510[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_74_74_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_74_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_512) => (aesl_tmp_511 - 1) @ (1)
							for (int i_0 = aesl_tmp_512; i_0 <= aesl_tmp_511 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_510[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_510[0]
								// output_left_conversion : aesl_tmp_510[i_0]
								// output_type_conversion : (matrix_o_V_lv0_74_74_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_510[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_510[i_0] = (matrix_o_V_lv0_74_74_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_75_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_75_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_75_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_75_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_75_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_75_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_75_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_75_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_75_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_75_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_514)
			{
				aesl_tmp_514 = i;
			}

			if (aesl_tmp_514 > 0 && aesl_tmp_513.size() < aesl_tmp_514)
			{
				int aesl_tmp_513_size = aesl_tmp_513.size();

				for (int tmp_aesl_tmp_513 = 0; tmp_aesl_tmp_513 < aesl_tmp_514 - aesl_tmp_513_size; tmp_aesl_tmp_513++)
				{
					short tmp;
					aesl_tmp_513.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_75_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_75_75_2 = new sc_lv<16>[aesl_tmp_514 - aesl_tmp_515];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_515) => (aesl_tmp_514 - 1) @ (1)
							for (int i_0 = aesl_tmp_515; i_0 <= aesl_tmp_514 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_513[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_75_75_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_75_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_515) => (aesl_tmp_514 - 1) @ (1)
							for (int i_0 = aesl_tmp_515; i_0 <= aesl_tmp_514 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_513[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_513[0]
								// output_left_conversion : aesl_tmp_513[i_0]
								// output_type_conversion : (matrix_o_V_lv0_75_75_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_513[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_513[i_0] = (matrix_o_V_lv0_75_75_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_76_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_76_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_76_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_76_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_76_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_76_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_76_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_76_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_76_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_76_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_517)
			{
				aesl_tmp_517 = i;
			}

			if (aesl_tmp_517 > 0 && aesl_tmp_516.size() < aesl_tmp_517)
			{
				int aesl_tmp_516_size = aesl_tmp_516.size();

				for (int tmp_aesl_tmp_516 = 0; tmp_aesl_tmp_516 < aesl_tmp_517 - aesl_tmp_516_size; tmp_aesl_tmp_516++)
				{
					short tmp;
					aesl_tmp_516.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_76_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_76_76_2 = new sc_lv<16>[aesl_tmp_517 - aesl_tmp_518];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_518) => (aesl_tmp_517 - 1) @ (1)
							for (int i_0 = aesl_tmp_518; i_0 <= aesl_tmp_517 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_516[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_76_76_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_76_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_518) => (aesl_tmp_517 - 1) @ (1)
							for (int i_0 = aesl_tmp_518; i_0 <= aesl_tmp_517 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_516[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_516[0]
								// output_left_conversion : aesl_tmp_516[i_0]
								// output_type_conversion : (matrix_o_V_lv0_76_76_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_516[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_516[i_0] = (matrix_o_V_lv0_76_76_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_77_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_77_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_77_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_77_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_77_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_77_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_77_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_77_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_77_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_77_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_520)
			{
				aesl_tmp_520 = i;
			}

			if (aesl_tmp_520 > 0 && aesl_tmp_519.size() < aesl_tmp_520)
			{
				int aesl_tmp_519_size = aesl_tmp_519.size();

				for (int tmp_aesl_tmp_519 = 0; tmp_aesl_tmp_519 < aesl_tmp_520 - aesl_tmp_519_size; tmp_aesl_tmp_519++)
				{
					short tmp;
					aesl_tmp_519.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_77_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_77_77_2 = new sc_lv<16>[aesl_tmp_520 - aesl_tmp_521];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_521) => (aesl_tmp_520 - 1) @ (1)
							for (int i_0 = aesl_tmp_521; i_0 <= aesl_tmp_520 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_519[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_77_77_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_77_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_521) => (aesl_tmp_520 - 1) @ (1)
							for (int i_0 = aesl_tmp_521; i_0 <= aesl_tmp_520 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_519[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_519[0]
								// output_left_conversion : aesl_tmp_519[i_0]
								// output_type_conversion : (matrix_o_V_lv0_77_77_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_519[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_519[i_0] = (matrix_o_V_lv0_77_77_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_78_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_78_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_78_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_78_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_78_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_78_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_78_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_78_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_78_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_78_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_523)
			{
				aesl_tmp_523 = i;
			}

			if (aesl_tmp_523 > 0 && aesl_tmp_522.size() < aesl_tmp_523)
			{
				int aesl_tmp_522_size = aesl_tmp_522.size();

				for (int tmp_aesl_tmp_522 = 0; tmp_aesl_tmp_522 < aesl_tmp_523 - aesl_tmp_522_size; tmp_aesl_tmp_522++)
				{
					short tmp;
					aesl_tmp_522.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_78_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_78_78_2 = new sc_lv<16>[aesl_tmp_523 - aesl_tmp_524];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_524) => (aesl_tmp_523 - 1) @ (1)
							for (int i_0 = aesl_tmp_524; i_0 <= aesl_tmp_523 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_522[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_78_78_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_78_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_524) => (aesl_tmp_523 - 1) @ (1)
							for (int i_0 = aesl_tmp_524; i_0 <= aesl_tmp_523 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_522[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_522[0]
								// output_left_conversion : aesl_tmp_522[i_0]
								// output_type_conversion : (matrix_o_V_lv0_78_78_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_522[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_522[i_0] = (matrix_o_V_lv0_78_78_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_79_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_79_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_79_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_79_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_79_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_79_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_79_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_79_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_79_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_79_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_526)
			{
				aesl_tmp_526 = i;
			}

			if (aesl_tmp_526 > 0 && aesl_tmp_525.size() < aesl_tmp_526)
			{
				int aesl_tmp_525_size = aesl_tmp_525.size();

				for (int tmp_aesl_tmp_525 = 0; tmp_aesl_tmp_525 < aesl_tmp_526 - aesl_tmp_525_size; tmp_aesl_tmp_525++)
				{
					short tmp;
					aesl_tmp_525.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_79_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_79_79_2 = new sc_lv<16>[aesl_tmp_526 - aesl_tmp_527];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_527) => (aesl_tmp_526 - 1) @ (1)
							for (int i_0 = aesl_tmp_527; i_0 <= aesl_tmp_526 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_525[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_79_79_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_79_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_527) => (aesl_tmp_526 - 1) @ (1)
							for (int i_0 = aesl_tmp_527; i_0 <= aesl_tmp_526 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_525[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_525[0]
								// output_left_conversion : aesl_tmp_525[i_0]
								// output_type_conversion : (matrix_o_V_lv0_79_79_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_525[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_525[i_0] = (matrix_o_V_lv0_79_79_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_80_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_80_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_80_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_80_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_80_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_80_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_80_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_80_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_80_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_80_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_529)
			{
				aesl_tmp_529 = i;
			}

			if (aesl_tmp_529 > 0 && aesl_tmp_528.size() < aesl_tmp_529)
			{
				int aesl_tmp_528_size = aesl_tmp_528.size();

				for (int tmp_aesl_tmp_528 = 0; tmp_aesl_tmp_528 < aesl_tmp_529 - aesl_tmp_528_size; tmp_aesl_tmp_528++)
				{
					short tmp;
					aesl_tmp_528.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_80_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_80_80_2 = new sc_lv<16>[aesl_tmp_529 - aesl_tmp_530];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_530) => (aesl_tmp_529 - 1) @ (1)
							for (int i_0 = aesl_tmp_530; i_0 <= aesl_tmp_529 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_528[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_80_80_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_80_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_530) => (aesl_tmp_529 - 1) @ (1)
							for (int i_0 = aesl_tmp_530; i_0 <= aesl_tmp_529 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_528[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_528[0]
								// output_left_conversion : aesl_tmp_528[i_0]
								// output_type_conversion : (matrix_o_V_lv0_80_80_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_528[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_528[i_0] = (matrix_o_V_lv0_80_80_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_81_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_81_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_81_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_81_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_81_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_81_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_81_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_81_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_81_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_81_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_532)
			{
				aesl_tmp_532 = i;
			}

			if (aesl_tmp_532 > 0 && aesl_tmp_531.size() < aesl_tmp_532)
			{
				int aesl_tmp_531_size = aesl_tmp_531.size();

				for (int tmp_aesl_tmp_531 = 0; tmp_aesl_tmp_531 < aesl_tmp_532 - aesl_tmp_531_size; tmp_aesl_tmp_531++)
				{
					short tmp;
					aesl_tmp_531.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_81_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_81_81_2 = new sc_lv<16>[aesl_tmp_532 - aesl_tmp_533];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_533) => (aesl_tmp_532 - 1) @ (1)
							for (int i_0 = aesl_tmp_533; i_0 <= aesl_tmp_532 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_531[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_81_81_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_81_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_533) => (aesl_tmp_532 - 1) @ (1)
							for (int i_0 = aesl_tmp_533; i_0 <= aesl_tmp_532 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_531[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_531[0]
								// output_left_conversion : aesl_tmp_531[i_0]
								// output_type_conversion : (matrix_o_V_lv0_81_81_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_531[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_531[i_0] = (matrix_o_V_lv0_81_81_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_82_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_82_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_82_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_82_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_82_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_82_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_82_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_82_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_82_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_82_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_535)
			{
				aesl_tmp_535 = i;
			}

			if (aesl_tmp_535 > 0 && aesl_tmp_534.size() < aesl_tmp_535)
			{
				int aesl_tmp_534_size = aesl_tmp_534.size();

				for (int tmp_aesl_tmp_534 = 0; tmp_aesl_tmp_534 < aesl_tmp_535 - aesl_tmp_534_size; tmp_aesl_tmp_534++)
				{
					short tmp;
					aesl_tmp_534.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_82_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_82_82_2 = new sc_lv<16>[aesl_tmp_535 - aesl_tmp_536];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_536) => (aesl_tmp_535 - 1) @ (1)
							for (int i_0 = aesl_tmp_536; i_0 <= aesl_tmp_535 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_534[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_82_82_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_82_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_536) => (aesl_tmp_535 - 1) @ (1)
							for (int i_0 = aesl_tmp_536; i_0 <= aesl_tmp_535 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_534[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_534[0]
								// output_left_conversion : aesl_tmp_534[i_0]
								// output_type_conversion : (matrix_o_V_lv0_82_82_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_534[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_534[i_0] = (matrix_o_V_lv0_82_82_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_83_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_83_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_83_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_83_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_83_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_83_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_83_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_83_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_83_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_83_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_538)
			{
				aesl_tmp_538 = i;
			}

			if (aesl_tmp_538 > 0 && aesl_tmp_537.size() < aesl_tmp_538)
			{
				int aesl_tmp_537_size = aesl_tmp_537.size();

				for (int tmp_aesl_tmp_537 = 0; tmp_aesl_tmp_537 < aesl_tmp_538 - aesl_tmp_537_size; tmp_aesl_tmp_537++)
				{
					short tmp;
					aesl_tmp_537.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_83_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_83_83_2 = new sc_lv<16>[aesl_tmp_538 - aesl_tmp_539];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_539) => (aesl_tmp_538 - 1) @ (1)
							for (int i_0 = aesl_tmp_539; i_0 <= aesl_tmp_538 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_537[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_83_83_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_83_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_539) => (aesl_tmp_538 - 1) @ (1)
							for (int i_0 = aesl_tmp_539; i_0 <= aesl_tmp_538 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_537[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_537[0]
								// output_left_conversion : aesl_tmp_537[i_0]
								// output_type_conversion : (matrix_o_V_lv0_83_83_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_537[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_537[i_0] = (matrix_o_V_lv0_83_83_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_84_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_84_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_84_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_84_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_84_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_84_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_84_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_84_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_84_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_84_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_541)
			{
				aesl_tmp_541 = i;
			}

			if (aesl_tmp_541 > 0 && aesl_tmp_540.size() < aesl_tmp_541)
			{
				int aesl_tmp_540_size = aesl_tmp_540.size();

				for (int tmp_aesl_tmp_540 = 0; tmp_aesl_tmp_540 < aesl_tmp_541 - aesl_tmp_540_size; tmp_aesl_tmp_540++)
				{
					short tmp;
					aesl_tmp_540.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_84_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_84_84_2 = new sc_lv<16>[aesl_tmp_541 - aesl_tmp_542];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_542) => (aesl_tmp_541 - 1) @ (1)
							for (int i_0 = aesl_tmp_542; i_0 <= aesl_tmp_541 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_540[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_84_84_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_84_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_542) => (aesl_tmp_541 - 1) @ (1)
							for (int i_0 = aesl_tmp_542; i_0 <= aesl_tmp_541 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_540[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_540[0]
								// output_left_conversion : aesl_tmp_540[i_0]
								// output_type_conversion : (matrix_o_V_lv0_84_84_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_540[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_540[i_0] = (matrix_o_V_lv0_84_84_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_85_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_85_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_85_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_85_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_85_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_85_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_85_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_85_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_85_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_85_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_544)
			{
				aesl_tmp_544 = i;
			}

			if (aesl_tmp_544 > 0 && aesl_tmp_543.size() < aesl_tmp_544)
			{
				int aesl_tmp_543_size = aesl_tmp_543.size();

				for (int tmp_aesl_tmp_543 = 0; tmp_aesl_tmp_543 < aesl_tmp_544 - aesl_tmp_543_size; tmp_aesl_tmp_543++)
				{
					short tmp;
					aesl_tmp_543.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_85_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_85_85_2 = new sc_lv<16>[aesl_tmp_544 - aesl_tmp_545];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_545) => (aesl_tmp_544 - 1) @ (1)
							for (int i_0 = aesl_tmp_545; i_0 <= aesl_tmp_544 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_543[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_85_85_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_85_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_545) => (aesl_tmp_544 - 1) @ (1)
							for (int i_0 = aesl_tmp_545; i_0 <= aesl_tmp_544 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_543[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_543[0]
								// output_left_conversion : aesl_tmp_543[i_0]
								// output_type_conversion : (matrix_o_V_lv0_85_85_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_543[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_543[i_0] = (matrix_o_V_lv0_85_85_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_86_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_86_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_86_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_86_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_86_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_86_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_86_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_86_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_86_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_86_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_547)
			{
				aesl_tmp_547 = i;
			}

			if (aesl_tmp_547 > 0 && aesl_tmp_546.size() < aesl_tmp_547)
			{
				int aesl_tmp_546_size = aesl_tmp_546.size();

				for (int tmp_aesl_tmp_546 = 0; tmp_aesl_tmp_546 < aesl_tmp_547 - aesl_tmp_546_size; tmp_aesl_tmp_546++)
				{
					short tmp;
					aesl_tmp_546.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_86_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_86_86_2 = new sc_lv<16>[aesl_tmp_547 - aesl_tmp_548];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_548) => (aesl_tmp_547 - 1) @ (1)
							for (int i_0 = aesl_tmp_548; i_0 <= aesl_tmp_547 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_546[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_86_86_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_86_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_548) => (aesl_tmp_547 - 1) @ (1)
							for (int i_0 = aesl_tmp_548; i_0 <= aesl_tmp_547 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_546[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_546[0]
								// output_left_conversion : aesl_tmp_546[i_0]
								// output_type_conversion : (matrix_o_V_lv0_86_86_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_546[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_546[i_0] = (matrix_o_V_lv0_86_86_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_87_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_87_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_87_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_87_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_87_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_87_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_87_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_87_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_87_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_87_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_550)
			{
				aesl_tmp_550 = i;
			}

			if (aesl_tmp_550 > 0 && aesl_tmp_549.size() < aesl_tmp_550)
			{
				int aesl_tmp_549_size = aesl_tmp_549.size();

				for (int tmp_aesl_tmp_549 = 0; tmp_aesl_tmp_549 < aesl_tmp_550 - aesl_tmp_549_size; tmp_aesl_tmp_549++)
				{
					short tmp;
					aesl_tmp_549.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_87_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_87_87_2 = new sc_lv<16>[aesl_tmp_550 - aesl_tmp_551];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_551) => (aesl_tmp_550 - 1) @ (1)
							for (int i_0 = aesl_tmp_551; i_0 <= aesl_tmp_550 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_549[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_87_87_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_87_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_551) => (aesl_tmp_550 - 1) @ (1)
							for (int i_0 = aesl_tmp_551; i_0 <= aesl_tmp_550 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_549[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_549[0]
								// output_left_conversion : aesl_tmp_549[i_0]
								// output_type_conversion : (matrix_o_V_lv0_87_87_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_549[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_549[i_0] = (matrix_o_V_lv0_87_87_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_88_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_88_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_88_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_88_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_88_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_88_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_88_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_88_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_88_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_88_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_553)
			{
				aesl_tmp_553 = i;
			}

			if (aesl_tmp_553 > 0 && aesl_tmp_552.size() < aesl_tmp_553)
			{
				int aesl_tmp_552_size = aesl_tmp_552.size();

				for (int tmp_aesl_tmp_552 = 0; tmp_aesl_tmp_552 < aesl_tmp_553 - aesl_tmp_552_size; tmp_aesl_tmp_552++)
				{
					short tmp;
					aesl_tmp_552.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_88_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_88_88_2 = new sc_lv<16>[aesl_tmp_553 - aesl_tmp_554];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_554) => (aesl_tmp_553 - 1) @ (1)
							for (int i_0 = aesl_tmp_554; i_0 <= aesl_tmp_553 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_552[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_88_88_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_88_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_554) => (aesl_tmp_553 - 1) @ (1)
							for (int i_0 = aesl_tmp_554; i_0 <= aesl_tmp_553 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_552[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_552[0]
								// output_left_conversion : aesl_tmp_552[i_0]
								// output_type_conversion : (matrix_o_V_lv0_88_88_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_552[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_552[i_0] = (matrix_o_V_lv0_88_88_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_89_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_89_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_89_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_89_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_89_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_89_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_89_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_89_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_89_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_89_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_556)
			{
				aesl_tmp_556 = i;
			}

			if (aesl_tmp_556 > 0 && aesl_tmp_555.size() < aesl_tmp_556)
			{
				int aesl_tmp_555_size = aesl_tmp_555.size();

				for (int tmp_aesl_tmp_555 = 0; tmp_aesl_tmp_555 < aesl_tmp_556 - aesl_tmp_555_size; tmp_aesl_tmp_555++)
				{
					short tmp;
					aesl_tmp_555.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_89_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_89_89_2 = new sc_lv<16>[aesl_tmp_556 - aesl_tmp_557];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_557) => (aesl_tmp_556 - 1) @ (1)
							for (int i_0 = aesl_tmp_557; i_0 <= aesl_tmp_556 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_555[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_89_89_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_89_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_557) => (aesl_tmp_556 - 1) @ (1)
							for (int i_0 = aesl_tmp_557; i_0 <= aesl_tmp_556 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_555[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_555[0]
								// output_left_conversion : aesl_tmp_555[i_0]
								// output_type_conversion : (matrix_o_V_lv0_89_89_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_555[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_555[i_0] = (matrix_o_V_lv0_89_89_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_90_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_90_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_90_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_90_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_90_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_90_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_90_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_90_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_90_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_90_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_559)
			{
				aesl_tmp_559 = i;
			}

			if (aesl_tmp_559 > 0 && aesl_tmp_558.size() < aesl_tmp_559)
			{
				int aesl_tmp_558_size = aesl_tmp_558.size();

				for (int tmp_aesl_tmp_558 = 0; tmp_aesl_tmp_558 < aesl_tmp_559 - aesl_tmp_558_size; tmp_aesl_tmp_558++)
				{
					short tmp;
					aesl_tmp_558.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_90_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_90_90_2 = new sc_lv<16>[aesl_tmp_559 - aesl_tmp_560];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_560) => (aesl_tmp_559 - 1) @ (1)
							for (int i_0 = aesl_tmp_560; i_0 <= aesl_tmp_559 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_558[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_90_90_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_90_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_560) => (aesl_tmp_559 - 1) @ (1)
							for (int i_0 = aesl_tmp_560; i_0 <= aesl_tmp_559 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_558[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_558[0]
								// output_left_conversion : aesl_tmp_558[i_0]
								// output_type_conversion : (matrix_o_V_lv0_90_90_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_558[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_558[i_0] = (matrix_o_V_lv0_90_90_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_91_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_91_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_91_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_91_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_91_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_91_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_91_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_91_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_91_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_91_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_562)
			{
				aesl_tmp_562 = i;
			}

			if (aesl_tmp_562 > 0 && aesl_tmp_561.size() < aesl_tmp_562)
			{
				int aesl_tmp_561_size = aesl_tmp_561.size();

				for (int tmp_aesl_tmp_561 = 0; tmp_aesl_tmp_561 < aesl_tmp_562 - aesl_tmp_561_size; tmp_aesl_tmp_561++)
				{
					short tmp;
					aesl_tmp_561.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_91_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_91_91_2 = new sc_lv<16>[aesl_tmp_562 - aesl_tmp_563];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_563) => (aesl_tmp_562 - 1) @ (1)
							for (int i_0 = aesl_tmp_563; i_0 <= aesl_tmp_562 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_561[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_91_91_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_91_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_563) => (aesl_tmp_562 - 1) @ (1)
							for (int i_0 = aesl_tmp_563; i_0 <= aesl_tmp_562 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_561[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_561[0]
								// output_left_conversion : aesl_tmp_561[i_0]
								// output_type_conversion : (matrix_o_V_lv0_91_91_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_561[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_561[i_0] = (matrix_o_V_lv0_91_91_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_92_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_92_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_92_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_92_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_92_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_92_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_92_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_92_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_92_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_92_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_565)
			{
				aesl_tmp_565 = i;
			}

			if (aesl_tmp_565 > 0 && aesl_tmp_564.size() < aesl_tmp_565)
			{
				int aesl_tmp_564_size = aesl_tmp_564.size();

				for (int tmp_aesl_tmp_564 = 0; tmp_aesl_tmp_564 < aesl_tmp_565 - aesl_tmp_564_size; tmp_aesl_tmp_564++)
				{
					short tmp;
					aesl_tmp_564.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_92_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_92_92_2 = new sc_lv<16>[aesl_tmp_565 - aesl_tmp_566];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_566) => (aesl_tmp_565 - 1) @ (1)
							for (int i_0 = aesl_tmp_566; i_0 <= aesl_tmp_565 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_564[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_92_92_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_92_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_566) => (aesl_tmp_565 - 1) @ (1)
							for (int i_0 = aesl_tmp_566; i_0 <= aesl_tmp_565 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_564[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_564[0]
								// output_left_conversion : aesl_tmp_564[i_0]
								// output_type_conversion : (matrix_o_V_lv0_92_92_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_564[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_564[i_0] = (matrix_o_V_lv0_92_92_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_93_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_93_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_93_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_93_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_93_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_93_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_93_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_93_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_93_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_93_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_568)
			{
				aesl_tmp_568 = i;
			}

			if (aesl_tmp_568 > 0 && aesl_tmp_567.size() < aesl_tmp_568)
			{
				int aesl_tmp_567_size = aesl_tmp_567.size();

				for (int tmp_aesl_tmp_567 = 0; tmp_aesl_tmp_567 < aesl_tmp_568 - aesl_tmp_567_size; tmp_aesl_tmp_567++)
				{
					short tmp;
					aesl_tmp_567.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_93_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_93_93_2 = new sc_lv<16>[aesl_tmp_568 - aesl_tmp_569];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_569) => (aesl_tmp_568 - 1) @ (1)
							for (int i_0 = aesl_tmp_569; i_0 <= aesl_tmp_568 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_567[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_93_93_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_93_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_569) => (aesl_tmp_568 - 1) @ (1)
							for (int i_0 = aesl_tmp_569; i_0 <= aesl_tmp_568 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_567[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_567[0]
								// output_left_conversion : aesl_tmp_567[i_0]
								// output_type_conversion : (matrix_o_V_lv0_93_93_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_567[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_567[i_0] = (matrix_o_V_lv0_93_93_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_94_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_94_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_94_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_94_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_94_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_94_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_94_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_94_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_94_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_94_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_571)
			{
				aesl_tmp_571 = i;
			}

			if (aesl_tmp_571 > 0 && aesl_tmp_570.size() < aesl_tmp_571)
			{
				int aesl_tmp_570_size = aesl_tmp_570.size();

				for (int tmp_aesl_tmp_570 = 0; tmp_aesl_tmp_570 < aesl_tmp_571 - aesl_tmp_570_size; tmp_aesl_tmp_570++)
				{
					short tmp;
					aesl_tmp_570.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_94_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_94_94_2 = new sc_lv<16>[aesl_tmp_571 - aesl_tmp_572];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_572) => (aesl_tmp_571 - 1) @ (1)
							for (int i_0 = aesl_tmp_572; i_0 <= aesl_tmp_571 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_570[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_94_94_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_94_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_572) => (aesl_tmp_571 - 1) @ (1)
							for (int i_0 = aesl_tmp_572; i_0 <= aesl_tmp_571 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_570[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_570[0]
								// output_left_conversion : aesl_tmp_570[i_0]
								// output_type_conversion : (matrix_o_V_lv0_94_94_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_570[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_570[i_0] = (matrix_o_V_lv0_94_94_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_95_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_95_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_95_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_95_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_95_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_95_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_95_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_95_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_95_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_95_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_574)
			{
				aesl_tmp_574 = i;
			}

			if (aesl_tmp_574 > 0 && aesl_tmp_573.size() < aesl_tmp_574)
			{
				int aesl_tmp_573_size = aesl_tmp_573.size();

				for (int tmp_aesl_tmp_573 = 0; tmp_aesl_tmp_573 < aesl_tmp_574 - aesl_tmp_573_size; tmp_aesl_tmp_573++)
				{
					short tmp;
					aesl_tmp_573.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_95_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_95_95_2 = new sc_lv<16>[aesl_tmp_574 - aesl_tmp_575];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_575) => (aesl_tmp_574 - 1) @ (1)
							for (int i_0 = aesl_tmp_575; i_0 <= aesl_tmp_574 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_573[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_95_95_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_95_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_575) => (aesl_tmp_574 - 1) @ (1)
							for (int i_0 = aesl_tmp_575; i_0 <= aesl_tmp_574 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_573[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_573[0]
								// output_left_conversion : aesl_tmp_573[i_0]
								// output_type_conversion : (matrix_o_V_lv0_95_95_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_573[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_573[i_0] = (matrix_o_V_lv0_95_95_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_96_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_96_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_96_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_96_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_96_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_96_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_96_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_96_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_96_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_96_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_577)
			{
				aesl_tmp_577 = i;
			}

			if (aesl_tmp_577 > 0 && aesl_tmp_576.size() < aesl_tmp_577)
			{
				int aesl_tmp_576_size = aesl_tmp_576.size();

				for (int tmp_aesl_tmp_576 = 0; tmp_aesl_tmp_576 < aesl_tmp_577 - aesl_tmp_576_size; tmp_aesl_tmp_576++)
				{
					short tmp;
					aesl_tmp_576.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_96_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_96_96_2 = new sc_lv<16>[aesl_tmp_577 - aesl_tmp_578];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_578) => (aesl_tmp_577 - 1) @ (1)
							for (int i_0 = aesl_tmp_578; i_0 <= aesl_tmp_577 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_576[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_96_96_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_96_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_578) => (aesl_tmp_577 - 1) @ (1)
							for (int i_0 = aesl_tmp_578; i_0 <= aesl_tmp_577 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_576[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_576[0]
								// output_left_conversion : aesl_tmp_576[i_0]
								// output_type_conversion : (matrix_o_V_lv0_96_96_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_576[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_576[i_0] = (matrix_o_V_lv0_96_96_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_97_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_97_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_97_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_97_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_97_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_97_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_97_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_97_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_97_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_97_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_580)
			{
				aesl_tmp_580 = i;
			}

			if (aesl_tmp_580 > 0 && aesl_tmp_579.size() < aesl_tmp_580)
			{
				int aesl_tmp_579_size = aesl_tmp_579.size();

				for (int tmp_aesl_tmp_579 = 0; tmp_aesl_tmp_579 < aesl_tmp_580 - aesl_tmp_579_size; tmp_aesl_tmp_579++)
				{
					short tmp;
					aesl_tmp_579.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_97_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_97_97_2 = new sc_lv<16>[aesl_tmp_580 - aesl_tmp_581];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_581) => (aesl_tmp_580 - 1) @ (1)
							for (int i_0 = aesl_tmp_581; i_0 <= aesl_tmp_580 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_579[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_97_97_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_97_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_581) => (aesl_tmp_580 - 1) @ (1)
							for (int i_0 = aesl_tmp_581; i_0 <= aesl_tmp_580 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_579[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_579[0]
								// output_left_conversion : aesl_tmp_579[i_0]
								// output_type_conversion : (matrix_o_V_lv0_97_97_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_579[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_579[i_0] = (matrix_o_V_lv0_97_97_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_98_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_98_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_98_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_98_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_98_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_98_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_98_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_98_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_98_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_98_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_583)
			{
				aesl_tmp_583 = i;
			}

			if (aesl_tmp_583 > 0 && aesl_tmp_582.size() < aesl_tmp_583)
			{
				int aesl_tmp_582_size = aesl_tmp_582.size();

				for (int tmp_aesl_tmp_582 = 0; tmp_aesl_tmp_582 < aesl_tmp_583 - aesl_tmp_582_size; tmp_aesl_tmp_582++)
				{
					short tmp;
					aesl_tmp_582.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_98_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_98_98_2 = new sc_lv<16>[aesl_tmp_583 - aesl_tmp_584];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_584) => (aesl_tmp_583 - 1) @ (1)
							for (int i_0 = aesl_tmp_584; i_0 <= aesl_tmp_583 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_582[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_98_98_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_98_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_584) => (aesl_tmp_583 - 1) @ (1)
							for (int i_0 = aesl_tmp_584; i_0 <= aesl_tmp_583 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_582[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_582[0]
								// output_left_conversion : aesl_tmp_582[i_0]
								// output_type_conversion : (matrix_o_V_lv0_98_98_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_582[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_582[i_0] = (matrix_o_V_lv0_98_98_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_99_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_99_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_99_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_99_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_99_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_99_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_99_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_99_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_99_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_99_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_586)
			{
				aesl_tmp_586 = i;
			}

			if (aesl_tmp_586 > 0 && aesl_tmp_585.size() < aesl_tmp_586)
			{
				int aesl_tmp_585_size = aesl_tmp_585.size();

				for (int tmp_aesl_tmp_585 = 0; tmp_aesl_tmp_585 < aesl_tmp_586 - aesl_tmp_585_size; tmp_aesl_tmp_585++)
				{
					short tmp;
					aesl_tmp_585.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_99_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_99_99_2 = new sc_lv<16>[aesl_tmp_586 - aesl_tmp_587];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_587) => (aesl_tmp_586 - 1) @ (1)
							for (int i_0 = aesl_tmp_587; i_0 <= aesl_tmp_586 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_585[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_99_99_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_99_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_587) => (aesl_tmp_586 - 1) @ (1)
							for (int i_0 = aesl_tmp_587; i_0 <= aesl_tmp_586 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_585[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_585[0]
								// output_left_conversion : aesl_tmp_585[i_0]
								// output_type_conversion : (matrix_o_V_lv0_99_99_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_585[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_585[i_0] = (matrix_o_V_lv0_99_99_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_100_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_100_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_100_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_100_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_100_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_100_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_100_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_100_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_100_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_100_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_589)
			{
				aesl_tmp_589 = i;
			}

			if (aesl_tmp_589 > 0 && aesl_tmp_588.size() < aesl_tmp_589)
			{
				int aesl_tmp_588_size = aesl_tmp_588.size();

				for (int tmp_aesl_tmp_588 = 0; tmp_aesl_tmp_588 < aesl_tmp_589 - aesl_tmp_588_size; tmp_aesl_tmp_588++)
				{
					short tmp;
					aesl_tmp_588.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_100_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_100_100_2 = new sc_lv<16>[aesl_tmp_589 - aesl_tmp_590];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_590) => (aesl_tmp_589 - 1) @ (1)
							for (int i_0 = aesl_tmp_590; i_0 <= aesl_tmp_589 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_588[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_100_100_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_100_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_590) => (aesl_tmp_589 - 1) @ (1)
							for (int i_0 = aesl_tmp_590; i_0 <= aesl_tmp_589 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_588[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_588[0]
								// output_left_conversion : aesl_tmp_588[i_0]
								// output_type_conversion : (matrix_o_V_lv0_100_100_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_588[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_588[i_0] = (matrix_o_V_lv0_100_100_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_101_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_101_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_101_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_101_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_101_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_101_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_101_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_101_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_101_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_101_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_592)
			{
				aesl_tmp_592 = i;
			}

			if (aesl_tmp_592 > 0 && aesl_tmp_591.size() < aesl_tmp_592)
			{
				int aesl_tmp_591_size = aesl_tmp_591.size();

				for (int tmp_aesl_tmp_591 = 0; tmp_aesl_tmp_591 < aesl_tmp_592 - aesl_tmp_591_size; tmp_aesl_tmp_591++)
				{
					short tmp;
					aesl_tmp_591.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_101_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_101_101_2 = new sc_lv<16>[aesl_tmp_592 - aesl_tmp_593];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_593) => (aesl_tmp_592 - 1) @ (1)
							for (int i_0 = aesl_tmp_593; i_0 <= aesl_tmp_592 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_591[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_101_101_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_101_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_593) => (aesl_tmp_592 - 1) @ (1)
							for (int i_0 = aesl_tmp_593; i_0 <= aesl_tmp_592 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_591[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_591[0]
								// output_left_conversion : aesl_tmp_591[i_0]
								// output_type_conversion : (matrix_o_V_lv0_101_101_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_591[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_591[i_0] = (matrix_o_V_lv0_101_101_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_102_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_102_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_102_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_102_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_102_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_102_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_102_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_102_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_102_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_102_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_595)
			{
				aesl_tmp_595 = i;
			}

			if (aesl_tmp_595 > 0 && aesl_tmp_594.size() < aesl_tmp_595)
			{
				int aesl_tmp_594_size = aesl_tmp_594.size();

				for (int tmp_aesl_tmp_594 = 0; tmp_aesl_tmp_594 < aesl_tmp_595 - aesl_tmp_594_size; tmp_aesl_tmp_594++)
				{
					short tmp;
					aesl_tmp_594.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_102_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_102_102_2 = new sc_lv<16>[aesl_tmp_595 - aesl_tmp_596];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_596) => (aesl_tmp_595 - 1) @ (1)
							for (int i_0 = aesl_tmp_596; i_0 <= aesl_tmp_595 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_594[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_102_102_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_102_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_596) => (aesl_tmp_595 - 1) @ (1)
							for (int i_0 = aesl_tmp_596; i_0 <= aesl_tmp_595 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_594[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_594[0]
								// output_left_conversion : aesl_tmp_594[i_0]
								// output_type_conversion : (matrix_o_V_lv0_102_102_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_594[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_594[i_0] = (matrix_o_V_lv0_102_102_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_103_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_103_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_103_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_103_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_103_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_103_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_103_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_103_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_103_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_103_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_598)
			{
				aesl_tmp_598 = i;
			}

			if (aesl_tmp_598 > 0 && aesl_tmp_597.size() < aesl_tmp_598)
			{
				int aesl_tmp_597_size = aesl_tmp_597.size();

				for (int tmp_aesl_tmp_597 = 0; tmp_aesl_tmp_597 < aesl_tmp_598 - aesl_tmp_597_size; tmp_aesl_tmp_597++)
				{
					short tmp;
					aesl_tmp_597.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_103_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_103_103_2 = new sc_lv<16>[aesl_tmp_598 - aesl_tmp_599];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_599) => (aesl_tmp_598 - 1) @ (1)
							for (int i_0 = aesl_tmp_599; i_0 <= aesl_tmp_598 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_597[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_103_103_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_103_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_599) => (aesl_tmp_598 - 1) @ (1)
							for (int i_0 = aesl_tmp_599; i_0 <= aesl_tmp_598 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_597[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_597[0]
								// output_left_conversion : aesl_tmp_597[i_0]
								// output_type_conversion : (matrix_o_V_lv0_103_103_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_597[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_597[i_0] = (matrix_o_V_lv0_103_103_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_104_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_104_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_104_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_104_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_104_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_104_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_104_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_104_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_104_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_104_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_601)
			{
				aesl_tmp_601 = i;
			}

			if (aesl_tmp_601 > 0 && aesl_tmp_600.size() < aesl_tmp_601)
			{
				int aesl_tmp_600_size = aesl_tmp_600.size();

				for (int tmp_aesl_tmp_600 = 0; tmp_aesl_tmp_600 < aesl_tmp_601 - aesl_tmp_600_size; tmp_aesl_tmp_600++)
				{
					short tmp;
					aesl_tmp_600.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_104_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_104_104_2 = new sc_lv<16>[aesl_tmp_601 - aesl_tmp_602];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_602) => (aesl_tmp_601 - 1) @ (1)
							for (int i_0 = aesl_tmp_602; i_0 <= aesl_tmp_601 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_600[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_104_104_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_104_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_602) => (aesl_tmp_601 - 1) @ (1)
							for (int i_0 = aesl_tmp_602; i_0 <= aesl_tmp_601 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_600[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_600[0]
								// output_left_conversion : aesl_tmp_600[i_0]
								// output_type_conversion : (matrix_o_V_lv0_104_104_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_600[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_600[i_0] = (matrix_o_V_lv0_104_104_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_105_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_105_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_105_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_105_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_105_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_105_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_105_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_105_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_105_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_105_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_604)
			{
				aesl_tmp_604 = i;
			}

			if (aesl_tmp_604 > 0 && aesl_tmp_603.size() < aesl_tmp_604)
			{
				int aesl_tmp_603_size = aesl_tmp_603.size();

				for (int tmp_aesl_tmp_603 = 0; tmp_aesl_tmp_603 < aesl_tmp_604 - aesl_tmp_603_size; tmp_aesl_tmp_603++)
				{
					short tmp;
					aesl_tmp_603.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_105_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_105_105_2 = new sc_lv<16>[aesl_tmp_604 - aesl_tmp_605];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_605) => (aesl_tmp_604 - 1) @ (1)
							for (int i_0 = aesl_tmp_605; i_0 <= aesl_tmp_604 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_603[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_105_105_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_105_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_605) => (aesl_tmp_604 - 1) @ (1)
							for (int i_0 = aesl_tmp_605; i_0 <= aesl_tmp_604 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_603[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_603[0]
								// output_left_conversion : aesl_tmp_603[i_0]
								// output_type_conversion : (matrix_o_V_lv0_105_105_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_603[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_603[i_0] = (matrix_o_V_lv0_105_105_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_106_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_106_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_106_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_106_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_106_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_106_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_106_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_106_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_106_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_106_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_607)
			{
				aesl_tmp_607 = i;
			}

			if (aesl_tmp_607 > 0 && aesl_tmp_606.size() < aesl_tmp_607)
			{
				int aesl_tmp_606_size = aesl_tmp_606.size();

				for (int tmp_aesl_tmp_606 = 0; tmp_aesl_tmp_606 < aesl_tmp_607 - aesl_tmp_606_size; tmp_aesl_tmp_606++)
				{
					short tmp;
					aesl_tmp_606.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_106_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_106_106_2 = new sc_lv<16>[aesl_tmp_607 - aesl_tmp_608];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_608) => (aesl_tmp_607 - 1) @ (1)
							for (int i_0 = aesl_tmp_608; i_0 <= aesl_tmp_607 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_606[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_106_106_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_106_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_608) => (aesl_tmp_607 - 1) @ (1)
							for (int i_0 = aesl_tmp_608; i_0 <= aesl_tmp_607 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_606[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_606[0]
								// output_left_conversion : aesl_tmp_606[i_0]
								// output_type_conversion : (matrix_o_V_lv0_106_106_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_606[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_606[i_0] = (matrix_o_V_lv0_106_106_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_107_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_107_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_107_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_107_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_107_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_107_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_107_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_107_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_107_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_107_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_610)
			{
				aesl_tmp_610 = i;
			}

			if (aesl_tmp_610 > 0 && aesl_tmp_609.size() < aesl_tmp_610)
			{
				int aesl_tmp_609_size = aesl_tmp_609.size();

				for (int tmp_aesl_tmp_609 = 0; tmp_aesl_tmp_609 < aesl_tmp_610 - aesl_tmp_609_size; tmp_aesl_tmp_609++)
				{
					short tmp;
					aesl_tmp_609.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_107_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_107_107_2 = new sc_lv<16>[aesl_tmp_610 - aesl_tmp_611];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_611) => (aesl_tmp_610 - 1) @ (1)
							for (int i_0 = aesl_tmp_611; i_0 <= aesl_tmp_610 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_609[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_107_107_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_107_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_611) => (aesl_tmp_610 - 1) @ (1)
							for (int i_0 = aesl_tmp_611; i_0 <= aesl_tmp_610 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_609[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_609[0]
								// output_left_conversion : aesl_tmp_609[i_0]
								// output_type_conversion : (matrix_o_V_lv0_107_107_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_609[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_609[i_0] = (matrix_o_V_lv0_107_107_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_108_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_108_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_108_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_108_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_108_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_108_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_108_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_108_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_108_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_108_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_613)
			{
				aesl_tmp_613 = i;
			}

			if (aesl_tmp_613 > 0 && aesl_tmp_612.size() < aesl_tmp_613)
			{
				int aesl_tmp_612_size = aesl_tmp_612.size();

				for (int tmp_aesl_tmp_612 = 0; tmp_aesl_tmp_612 < aesl_tmp_613 - aesl_tmp_612_size; tmp_aesl_tmp_612++)
				{
					short tmp;
					aesl_tmp_612.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_108_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_108_108_2 = new sc_lv<16>[aesl_tmp_613 - aesl_tmp_614];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_614) => (aesl_tmp_613 - 1) @ (1)
							for (int i_0 = aesl_tmp_614; i_0 <= aesl_tmp_613 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_612[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_108_108_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_108_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_614) => (aesl_tmp_613 - 1) @ (1)
							for (int i_0 = aesl_tmp_614; i_0 <= aesl_tmp_613 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_612[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_612[0]
								// output_left_conversion : aesl_tmp_612[i_0]
								// output_type_conversion : (matrix_o_V_lv0_108_108_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_612[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_612[i_0] = (matrix_o_V_lv0_108_108_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_109_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_109_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_109_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_109_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_109_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_109_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_109_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_109_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_109_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_109_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_616)
			{
				aesl_tmp_616 = i;
			}

			if (aesl_tmp_616 > 0 && aesl_tmp_615.size() < aesl_tmp_616)
			{
				int aesl_tmp_615_size = aesl_tmp_615.size();

				for (int tmp_aesl_tmp_615 = 0; tmp_aesl_tmp_615 < aesl_tmp_616 - aesl_tmp_615_size; tmp_aesl_tmp_615++)
				{
					short tmp;
					aesl_tmp_615.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_109_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_109_109_2 = new sc_lv<16>[aesl_tmp_616 - aesl_tmp_617];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_617) => (aesl_tmp_616 - 1) @ (1)
							for (int i_0 = aesl_tmp_617; i_0 <= aesl_tmp_616 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_615[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_109_109_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_109_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_617) => (aesl_tmp_616 - 1) @ (1)
							for (int i_0 = aesl_tmp_617; i_0 <= aesl_tmp_616 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_615[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_615[0]
								// output_left_conversion : aesl_tmp_615[i_0]
								// output_type_conversion : (matrix_o_V_lv0_109_109_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_615[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_615[i_0] = (matrix_o_V_lv0_109_109_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_110_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_110_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_110_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_110_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_110_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_110_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_110_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_110_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_110_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_110_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_619)
			{
				aesl_tmp_619 = i;
			}

			if (aesl_tmp_619 > 0 && aesl_tmp_618.size() < aesl_tmp_619)
			{
				int aesl_tmp_618_size = aesl_tmp_618.size();

				for (int tmp_aesl_tmp_618 = 0; tmp_aesl_tmp_618 < aesl_tmp_619 - aesl_tmp_618_size; tmp_aesl_tmp_618++)
				{
					short tmp;
					aesl_tmp_618.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_110_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_110_110_2 = new sc_lv<16>[aesl_tmp_619 - aesl_tmp_620];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_620) => (aesl_tmp_619 - 1) @ (1)
							for (int i_0 = aesl_tmp_620; i_0 <= aesl_tmp_619 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_618[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_110_110_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_110_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_620) => (aesl_tmp_619 - 1) @ (1)
							for (int i_0 = aesl_tmp_620; i_0 <= aesl_tmp_619 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_618[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_618[0]
								// output_left_conversion : aesl_tmp_618[i_0]
								// output_type_conversion : (matrix_o_V_lv0_110_110_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_618[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_618[i_0] = (matrix_o_V_lv0_110_110_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_111_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_111_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_111_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_111_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_111_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_111_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_111_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_111_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_111_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_111_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_622)
			{
				aesl_tmp_622 = i;
			}

			if (aesl_tmp_622 > 0 && aesl_tmp_621.size() < aesl_tmp_622)
			{
				int aesl_tmp_621_size = aesl_tmp_621.size();

				for (int tmp_aesl_tmp_621 = 0; tmp_aesl_tmp_621 < aesl_tmp_622 - aesl_tmp_621_size; tmp_aesl_tmp_621++)
				{
					short tmp;
					aesl_tmp_621.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_111_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_111_111_2 = new sc_lv<16>[aesl_tmp_622 - aesl_tmp_623];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_623) => (aesl_tmp_622 - 1) @ (1)
							for (int i_0 = aesl_tmp_623; i_0 <= aesl_tmp_622 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_621[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_111_111_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_111_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_623) => (aesl_tmp_622 - 1) @ (1)
							for (int i_0 = aesl_tmp_623; i_0 <= aesl_tmp_622 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_621[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_621[0]
								// output_left_conversion : aesl_tmp_621[i_0]
								// output_type_conversion : (matrix_o_V_lv0_111_111_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_621[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_621[i_0] = (matrix_o_V_lv0_111_111_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_112_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_112_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_112_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_112_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_112_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_112_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_112_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_112_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_112_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_112_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_625)
			{
				aesl_tmp_625 = i;
			}

			if (aesl_tmp_625 > 0 && aesl_tmp_624.size() < aesl_tmp_625)
			{
				int aesl_tmp_624_size = aesl_tmp_624.size();

				for (int tmp_aesl_tmp_624 = 0; tmp_aesl_tmp_624 < aesl_tmp_625 - aesl_tmp_624_size; tmp_aesl_tmp_624++)
				{
					short tmp;
					aesl_tmp_624.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_112_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_112_112_2 = new sc_lv<16>[aesl_tmp_625 - aesl_tmp_626];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_626) => (aesl_tmp_625 - 1) @ (1)
							for (int i_0 = aesl_tmp_626; i_0 <= aesl_tmp_625 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_624[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_112_112_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_112_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_626) => (aesl_tmp_625 - 1) @ (1)
							for (int i_0 = aesl_tmp_626; i_0 <= aesl_tmp_625 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_624[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_624[0]
								// output_left_conversion : aesl_tmp_624[i_0]
								// output_type_conversion : (matrix_o_V_lv0_112_112_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_624[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_624[i_0] = (matrix_o_V_lv0_112_112_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_113_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_113_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_113_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_113_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_113_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_113_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_113_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_113_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_113_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_113_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_628)
			{
				aesl_tmp_628 = i;
			}

			if (aesl_tmp_628 > 0 && aesl_tmp_627.size() < aesl_tmp_628)
			{
				int aesl_tmp_627_size = aesl_tmp_627.size();

				for (int tmp_aesl_tmp_627 = 0; tmp_aesl_tmp_627 < aesl_tmp_628 - aesl_tmp_627_size; tmp_aesl_tmp_627++)
				{
					short tmp;
					aesl_tmp_627.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_113_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_113_113_2 = new sc_lv<16>[aesl_tmp_628 - aesl_tmp_629];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_629) => (aesl_tmp_628 - 1) @ (1)
							for (int i_0 = aesl_tmp_629; i_0 <= aesl_tmp_628 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_627[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_113_113_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_113_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_629) => (aesl_tmp_628 - 1) @ (1)
							for (int i_0 = aesl_tmp_629; i_0 <= aesl_tmp_628 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_627[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_627[0]
								// output_left_conversion : aesl_tmp_627[i_0]
								// output_type_conversion : (matrix_o_V_lv0_113_113_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_627[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_627[i_0] = (matrix_o_V_lv0_113_113_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_114_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_114_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_114_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_114_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_114_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_114_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_114_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_114_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_114_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_114_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_631)
			{
				aesl_tmp_631 = i;
			}

			if (aesl_tmp_631 > 0 && aesl_tmp_630.size() < aesl_tmp_631)
			{
				int aesl_tmp_630_size = aesl_tmp_630.size();

				for (int tmp_aesl_tmp_630 = 0; tmp_aesl_tmp_630 < aesl_tmp_631 - aesl_tmp_630_size; tmp_aesl_tmp_630++)
				{
					short tmp;
					aesl_tmp_630.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_114_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_114_114_2 = new sc_lv<16>[aesl_tmp_631 - aesl_tmp_632];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_632) => (aesl_tmp_631 - 1) @ (1)
							for (int i_0 = aesl_tmp_632; i_0 <= aesl_tmp_631 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_630[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_114_114_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_114_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_632) => (aesl_tmp_631 - 1) @ (1)
							for (int i_0 = aesl_tmp_632; i_0 <= aesl_tmp_631 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_630[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_630[0]
								// output_left_conversion : aesl_tmp_630[i_0]
								// output_type_conversion : (matrix_o_V_lv0_114_114_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_630[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_630[i_0] = (matrix_o_V_lv0_114_114_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_115_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_115_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_115_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_115_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_115_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_115_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_115_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_115_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_115_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_115_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_634)
			{
				aesl_tmp_634 = i;
			}

			if (aesl_tmp_634 > 0 && aesl_tmp_633.size() < aesl_tmp_634)
			{
				int aesl_tmp_633_size = aesl_tmp_633.size();

				for (int tmp_aesl_tmp_633 = 0; tmp_aesl_tmp_633 < aesl_tmp_634 - aesl_tmp_633_size; tmp_aesl_tmp_633++)
				{
					short tmp;
					aesl_tmp_633.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_115_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_115_115_2 = new sc_lv<16>[aesl_tmp_634 - aesl_tmp_635];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_635) => (aesl_tmp_634 - 1) @ (1)
							for (int i_0 = aesl_tmp_635; i_0 <= aesl_tmp_634 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_633[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_115_115_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_115_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_635) => (aesl_tmp_634 - 1) @ (1)
							for (int i_0 = aesl_tmp_635; i_0 <= aesl_tmp_634 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_633[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_633[0]
								// output_left_conversion : aesl_tmp_633[i_0]
								// output_type_conversion : (matrix_o_V_lv0_115_115_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_633[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_633[i_0] = (matrix_o_V_lv0_115_115_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_116_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_116_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_116_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_116_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_116_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_116_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_116_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_116_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_116_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_116_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_637)
			{
				aesl_tmp_637 = i;
			}

			if (aesl_tmp_637 > 0 && aesl_tmp_636.size() < aesl_tmp_637)
			{
				int aesl_tmp_636_size = aesl_tmp_636.size();

				for (int tmp_aesl_tmp_636 = 0; tmp_aesl_tmp_636 < aesl_tmp_637 - aesl_tmp_636_size; tmp_aesl_tmp_636++)
				{
					short tmp;
					aesl_tmp_636.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_116_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_116_116_2 = new sc_lv<16>[aesl_tmp_637 - aesl_tmp_638];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_638) => (aesl_tmp_637 - 1) @ (1)
							for (int i_0 = aesl_tmp_638; i_0 <= aesl_tmp_637 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_636[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_116_116_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_116_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_638) => (aesl_tmp_637 - 1) @ (1)
							for (int i_0 = aesl_tmp_638; i_0 <= aesl_tmp_637 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_636[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_636[0]
								// output_left_conversion : aesl_tmp_636[i_0]
								// output_type_conversion : (matrix_o_V_lv0_116_116_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_636[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_636[i_0] = (matrix_o_V_lv0_116_116_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_117_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_117_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_117_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_117_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_117_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_117_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_117_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_117_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_117_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_117_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_640)
			{
				aesl_tmp_640 = i;
			}

			if (aesl_tmp_640 > 0 && aesl_tmp_639.size() < aesl_tmp_640)
			{
				int aesl_tmp_639_size = aesl_tmp_639.size();

				for (int tmp_aesl_tmp_639 = 0; tmp_aesl_tmp_639 < aesl_tmp_640 - aesl_tmp_639_size; tmp_aesl_tmp_639++)
				{
					short tmp;
					aesl_tmp_639.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_117_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_117_117_2 = new sc_lv<16>[aesl_tmp_640 - aesl_tmp_641];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_641) => (aesl_tmp_640 - 1) @ (1)
							for (int i_0 = aesl_tmp_641; i_0 <= aesl_tmp_640 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_639[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_117_117_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_117_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_641) => (aesl_tmp_640 - 1) @ (1)
							for (int i_0 = aesl_tmp_641; i_0 <= aesl_tmp_640 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_639[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_639[0]
								// output_left_conversion : aesl_tmp_639[i_0]
								// output_type_conversion : (matrix_o_V_lv0_117_117_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_639[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_639[i_0] = (matrix_o_V_lv0_117_117_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_118_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_118_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_118_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_118_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_118_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_118_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_118_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_118_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_118_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_118_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_643)
			{
				aesl_tmp_643 = i;
			}

			if (aesl_tmp_643 > 0 && aesl_tmp_642.size() < aesl_tmp_643)
			{
				int aesl_tmp_642_size = aesl_tmp_642.size();

				for (int tmp_aesl_tmp_642 = 0; tmp_aesl_tmp_642 < aesl_tmp_643 - aesl_tmp_642_size; tmp_aesl_tmp_642++)
				{
					short tmp;
					aesl_tmp_642.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_118_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_118_118_2 = new sc_lv<16>[aesl_tmp_643 - aesl_tmp_644];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_644) => (aesl_tmp_643 - 1) @ (1)
							for (int i_0 = aesl_tmp_644; i_0 <= aesl_tmp_643 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_642[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_118_118_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_118_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_644) => (aesl_tmp_643 - 1) @ (1)
							for (int i_0 = aesl_tmp_644; i_0 <= aesl_tmp_643 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_642[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_642[0]
								// output_left_conversion : aesl_tmp_642[i_0]
								// output_type_conversion : (matrix_o_V_lv0_118_118_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_642[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_642[i_0] = (matrix_o_V_lv0_118_118_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_119_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_119_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_119_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_119_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_119_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_119_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_119_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_119_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_119_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_119_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_646)
			{
				aesl_tmp_646 = i;
			}

			if (aesl_tmp_646 > 0 && aesl_tmp_645.size() < aesl_tmp_646)
			{
				int aesl_tmp_645_size = aesl_tmp_645.size();

				for (int tmp_aesl_tmp_645 = 0; tmp_aesl_tmp_645 < aesl_tmp_646 - aesl_tmp_645_size; tmp_aesl_tmp_645++)
				{
					short tmp;
					aesl_tmp_645.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_119_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_119_119_2 = new sc_lv<16>[aesl_tmp_646 - aesl_tmp_647];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_647) => (aesl_tmp_646 - 1) @ (1)
							for (int i_0 = aesl_tmp_647; i_0 <= aesl_tmp_646 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_645[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_119_119_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_119_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_647) => (aesl_tmp_646 - 1) @ (1)
							for (int i_0 = aesl_tmp_647; i_0 <= aesl_tmp_646 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_645[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_645[0]
								// output_left_conversion : aesl_tmp_645[i_0]
								// output_type_conversion : (matrix_o_V_lv0_119_119_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_645[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_645[i_0] = (matrix_o_V_lv0_119_119_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_120_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_120_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_120_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_120_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_120_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_120_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_120_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_120_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_120_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_120_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_649)
			{
				aesl_tmp_649 = i;
			}

			if (aesl_tmp_649 > 0 && aesl_tmp_648.size() < aesl_tmp_649)
			{
				int aesl_tmp_648_size = aesl_tmp_648.size();

				for (int tmp_aesl_tmp_648 = 0; tmp_aesl_tmp_648 < aesl_tmp_649 - aesl_tmp_648_size; tmp_aesl_tmp_648++)
				{
					short tmp;
					aesl_tmp_648.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_120_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_120_120_2 = new sc_lv<16>[aesl_tmp_649 - aesl_tmp_650];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_650) => (aesl_tmp_649 - 1) @ (1)
							for (int i_0 = aesl_tmp_650; i_0 <= aesl_tmp_649 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_648[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_120_120_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_120_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_650) => (aesl_tmp_649 - 1) @ (1)
							for (int i_0 = aesl_tmp_650; i_0 <= aesl_tmp_649 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_648[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_648[0]
								// output_left_conversion : aesl_tmp_648[i_0]
								// output_type_conversion : (matrix_o_V_lv0_120_120_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_648[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_648[i_0] = (matrix_o_V_lv0_120_120_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_121_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_121_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_121_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_121_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_121_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_121_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_121_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_121_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_121_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_121_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_652)
			{
				aesl_tmp_652 = i;
			}

			if (aesl_tmp_652 > 0 && aesl_tmp_651.size() < aesl_tmp_652)
			{
				int aesl_tmp_651_size = aesl_tmp_651.size();

				for (int tmp_aesl_tmp_651 = 0; tmp_aesl_tmp_651 < aesl_tmp_652 - aesl_tmp_651_size; tmp_aesl_tmp_651++)
				{
					short tmp;
					aesl_tmp_651.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_121_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_121_121_2 = new sc_lv<16>[aesl_tmp_652 - aesl_tmp_653];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_653) => (aesl_tmp_652 - 1) @ (1)
							for (int i_0 = aesl_tmp_653; i_0 <= aesl_tmp_652 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_651[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_121_121_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_121_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_653) => (aesl_tmp_652 - 1) @ (1)
							for (int i_0 = aesl_tmp_653; i_0 <= aesl_tmp_652 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_651[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_651[0]
								// output_left_conversion : aesl_tmp_651[i_0]
								// output_type_conversion : (matrix_o_V_lv0_121_121_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_651[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_651[i_0] = (matrix_o_V_lv0_121_121_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_122_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_122_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_122_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_122_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_122_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_122_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_122_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_122_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_122_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_122_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_655)
			{
				aesl_tmp_655 = i;
			}

			if (aesl_tmp_655 > 0 && aesl_tmp_654.size() < aesl_tmp_655)
			{
				int aesl_tmp_654_size = aesl_tmp_654.size();

				for (int tmp_aesl_tmp_654 = 0; tmp_aesl_tmp_654 < aesl_tmp_655 - aesl_tmp_654_size; tmp_aesl_tmp_654++)
				{
					short tmp;
					aesl_tmp_654.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_122_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_122_122_2 = new sc_lv<16>[aesl_tmp_655 - aesl_tmp_656];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_656) => (aesl_tmp_655 - 1) @ (1)
							for (int i_0 = aesl_tmp_656; i_0 <= aesl_tmp_655 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_654[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_122_122_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_122_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_656) => (aesl_tmp_655 - 1) @ (1)
							for (int i_0 = aesl_tmp_656; i_0 <= aesl_tmp_655 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_654[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_654[0]
								// output_left_conversion : aesl_tmp_654[i_0]
								// output_type_conversion : (matrix_o_V_lv0_122_122_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_654[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_654[i_0] = (matrix_o_V_lv0_122_122_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_123_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_123_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_123_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_123_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_123_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_123_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_123_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_123_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_123_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_123_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_658)
			{
				aesl_tmp_658 = i;
			}

			if (aesl_tmp_658 > 0 && aesl_tmp_657.size() < aesl_tmp_658)
			{
				int aesl_tmp_657_size = aesl_tmp_657.size();

				for (int tmp_aesl_tmp_657 = 0; tmp_aesl_tmp_657 < aesl_tmp_658 - aesl_tmp_657_size; tmp_aesl_tmp_657++)
				{
					short tmp;
					aesl_tmp_657.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_123_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_123_123_2 = new sc_lv<16>[aesl_tmp_658 - aesl_tmp_659];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_659) => (aesl_tmp_658 - 1) @ (1)
							for (int i_0 = aesl_tmp_659; i_0 <= aesl_tmp_658 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_657[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_123_123_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_123_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_659) => (aesl_tmp_658 - 1) @ (1)
							for (int i_0 = aesl_tmp_659; i_0 <= aesl_tmp_658 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_657[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_657[0]
								// output_left_conversion : aesl_tmp_657[i_0]
								// output_type_conversion : (matrix_o_V_lv0_123_123_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_657[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_657[i_0] = (matrix_o_V_lv0_123_123_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_124_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_124_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_124_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_124_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_124_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_124_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_124_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_124_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_124_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_124_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_661)
			{
				aesl_tmp_661 = i;
			}

			if (aesl_tmp_661 > 0 && aesl_tmp_660.size() < aesl_tmp_661)
			{
				int aesl_tmp_660_size = aesl_tmp_660.size();

				for (int tmp_aesl_tmp_660 = 0; tmp_aesl_tmp_660 < aesl_tmp_661 - aesl_tmp_660_size; tmp_aesl_tmp_660++)
				{
					short tmp;
					aesl_tmp_660.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_124_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_124_124_2 = new sc_lv<16>[aesl_tmp_661 - aesl_tmp_662];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_662) => (aesl_tmp_661 - 1) @ (1)
							for (int i_0 = aesl_tmp_662; i_0 <= aesl_tmp_661 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_660[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_124_124_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_124_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_662) => (aesl_tmp_661 - 1) @ (1)
							for (int i_0 = aesl_tmp_662; i_0 <= aesl_tmp_661 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_660[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_660[0]
								// output_left_conversion : aesl_tmp_660[i_0]
								// output_type_conversion : (matrix_o_V_lv0_124_124_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_660[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_660[i_0] = (matrix_o_V_lv0_124_124_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_125_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_125_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_125_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_125_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_125_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_125_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_125_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_125_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_125_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_125_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_664)
			{
				aesl_tmp_664 = i;
			}

			if (aesl_tmp_664 > 0 && aesl_tmp_663.size() < aesl_tmp_664)
			{
				int aesl_tmp_663_size = aesl_tmp_663.size();

				for (int tmp_aesl_tmp_663 = 0; tmp_aesl_tmp_663 < aesl_tmp_664 - aesl_tmp_663_size; tmp_aesl_tmp_663++)
				{
					short tmp;
					aesl_tmp_663.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_125_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_125_125_2 = new sc_lv<16>[aesl_tmp_664 - aesl_tmp_665];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_665) => (aesl_tmp_664 - 1) @ (1)
							for (int i_0 = aesl_tmp_665; i_0 <= aesl_tmp_664 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_663[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_125_125_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_125_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_665) => (aesl_tmp_664 - 1) @ (1)
							for (int i_0 = aesl_tmp_665; i_0 <= aesl_tmp_664 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_663[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_663[0]
								// output_left_conversion : aesl_tmp_663[i_0]
								// output_type_conversion : (matrix_o_V_lv0_125_125_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_663[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_663[i_0] = (matrix_o_V_lv0_125_125_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_126_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_126_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_126_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_126_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_126_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_126_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_126_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_126_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_126_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_126_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_667)
			{
				aesl_tmp_667 = i;
			}

			if (aesl_tmp_667 > 0 && aesl_tmp_666.size() < aesl_tmp_667)
			{
				int aesl_tmp_666_size = aesl_tmp_666.size();

				for (int tmp_aesl_tmp_666 = 0; tmp_aesl_tmp_666 < aesl_tmp_667 - aesl_tmp_666_size; tmp_aesl_tmp_666++)
				{
					short tmp;
					aesl_tmp_666.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_126_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_126_126_2 = new sc_lv<16>[aesl_tmp_667 - aesl_tmp_668];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_668) => (aesl_tmp_667 - 1) @ (1)
							for (int i_0 = aesl_tmp_668; i_0 <= aesl_tmp_667 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_666[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_126_126_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_126_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_668) => (aesl_tmp_667 - 1) @ (1)
							for (int i_0 = aesl_tmp_668; i_0 <= aesl_tmp_667 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_666[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_666[0]
								// output_left_conversion : aesl_tmp_666[i_0]
								// output_type_conversion : (matrix_o_V_lv0_126_126_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_666[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_666[i_0] = (matrix_o_V_lv0_126_126_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// output port post check: "matrix_o_127_V"
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_127_V, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_127_V, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_127_V, AESL_token); // data

			std::vector<sc_bv<16> > matrix_o_127_V_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_127_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'matrix_o_127_V', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					matrix_o_127_V_pc_buffer.push_back(AESL_token.c_str());
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_matrix_o_127_V, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_matrix_o_127_V))
				{
					exit(1);
				}
			}

			// correct the buffer size the current transaction
			if (i != aesl_tmp_670)
			{
				aesl_tmp_670 = i;
			}

			if (aesl_tmp_670 > 0 && aesl_tmp_669.size() < aesl_tmp_670)
			{
				int aesl_tmp_669_size = aesl_tmp_669.size();

				for (int tmp_aesl_tmp_669 = 0; tmp_aesl_tmp_669 < aesl_tmp_670 - aesl_tmp_669_size; tmp_aesl_tmp_669++)
				{
					short tmp;
					aesl_tmp_669.push_back(tmp);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: matrix_o_127_V
				{
					// bitslice(15, 0)
					// {
						// celement: matrix_o.V(15, 0)
						// {
							sc_lv<16>* matrix_o_V_lv0_127_127_2 = new sc_lv<16>[aesl_tmp_670 - aesl_tmp_671];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_671) => (aesl_tmp_670 - 1) @ (1)
							for (int i_0 = aesl_tmp_671; i_0 <= aesl_tmp_670 - 1; i_0 += 1)
							{
								if (&(aesl_tmp_669[0]) != NULL) // check the null address if the c port is array or others
								{
									matrix_o_V_lv0_127_127_2[hls_map_index++].range(15, 0) = sc_bv<16>(matrix_o_127_V_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: matrix_o.V(15, 0)
						{
							// carray: (aesl_tmp_671) => (aesl_tmp_670 - 1) @ (1)
							for (int i_0 = aesl_tmp_671; i_0 <= aesl_tmp_670 - 1; i_0 += 1)
							{
								// sub                    : i_0
								// ori_name               : aesl_tmp_669[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : aesl_tmp_669[0]
								// output_left_conversion : aesl_tmp_669[i_0]
								// output_type_conversion : (matrix_o_V_lv0_127_127_2[hls_map_index++]).to_uint64()
								if (&(aesl_tmp_669[0]) != NULL) // check the null address if the c port is array or others
								{
									aesl_tmp_669[i_0] = (matrix_o_V_lv0_127_127_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}
		}

		// push back output stream: "matrix_o[0]"
		for (int i = 0; i < aesl_tmp_289; i++)
		{
			matrix_o[0].write(aesl_tmp_288[i]);
		}

		// push back output stream: "matrix_o[1]"
		for (int i = 0; i < aesl_tmp_292; i++)
		{
			matrix_o[1].write(aesl_tmp_291[i]);
		}

		// push back output stream: "matrix_o[2]"
		for (int i = 0; i < aesl_tmp_295; i++)
		{
			matrix_o[2].write(aesl_tmp_294[i]);
		}

		// push back output stream: "matrix_o[3]"
		for (int i = 0; i < aesl_tmp_298; i++)
		{
			matrix_o[3].write(aesl_tmp_297[i]);
		}

		// push back output stream: "matrix_o[4]"
		for (int i = 0; i < aesl_tmp_301; i++)
		{
			matrix_o[4].write(aesl_tmp_300[i]);
		}

		// push back output stream: "matrix_o[5]"
		for (int i = 0; i < aesl_tmp_304; i++)
		{
			matrix_o[5].write(aesl_tmp_303[i]);
		}

		// push back output stream: "matrix_o[6]"
		for (int i = 0; i < aesl_tmp_307; i++)
		{
			matrix_o[6].write(aesl_tmp_306[i]);
		}

		// push back output stream: "matrix_o[7]"
		for (int i = 0; i < aesl_tmp_310; i++)
		{
			matrix_o[7].write(aesl_tmp_309[i]);
		}

		// push back output stream: "matrix_o[8]"
		for (int i = 0; i < aesl_tmp_313; i++)
		{
			matrix_o[8].write(aesl_tmp_312[i]);
		}

		// push back output stream: "matrix_o[9]"
		for (int i = 0; i < aesl_tmp_316; i++)
		{
			matrix_o[9].write(aesl_tmp_315[i]);
		}

		// push back output stream: "matrix_o[10]"
		for (int i = 0; i < aesl_tmp_319; i++)
		{
			matrix_o[10].write(aesl_tmp_318[i]);
		}

		// push back output stream: "matrix_o[11]"
		for (int i = 0; i < aesl_tmp_322; i++)
		{
			matrix_o[11].write(aesl_tmp_321[i]);
		}

		// push back output stream: "matrix_o[12]"
		for (int i = 0; i < aesl_tmp_325; i++)
		{
			matrix_o[12].write(aesl_tmp_324[i]);
		}

		// push back output stream: "matrix_o[13]"
		for (int i = 0; i < aesl_tmp_328; i++)
		{
			matrix_o[13].write(aesl_tmp_327[i]);
		}

		// push back output stream: "matrix_o[14]"
		for (int i = 0; i < aesl_tmp_331; i++)
		{
			matrix_o[14].write(aesl_tmp_330[i]);
		}

		// push back output stream: "matrix_o[15]"
		for (int i = 0; i < aesl_tmp_334; i++)
		{
			matrix_o[15].write(aesl_tmp_333[i]);
		}

		// push back output stream: "matrix_o[16]"
		for (int i = 0; i < aesl_tmp_337; i++)
		{
			matrix_o[16].write(aesl_tmp_336[i]);
		}

		// push back output stream: "matrix_o[17]"
		for (int i = 0; i < aesl_tmp_340; i++)
		{
			matrix_o[17].write(aesl_tmp_339[i]);
		}

		// push back output stream: "matrix_o[18]"
		for (int i = 0; i < aesl_tmp_343; i++)
		{
			matrix_o[18].write(aesl_tmp_342[i]);
		}

		// push back output stream: "matrix_o[19]"
		for (int i = 0; i < aesl_tmp_346; i++)
		{
			matrix_o[19].write(aesl_tmp_345[i]);
		}

		// push back output stream: "matrix_o[20]"
		for (int i = 0; i < aesl_tmp_349; i++)
		{
			matrix_o[20].write(aesl_tmp_348[i]);
		}

		// push back output stream: "matrix_o[21]"
		for (int i = 0; i < aesl_tmp_352; i++)
		{
			matrix_o[21].write(aesl_tmp_351[i]);
		}

		// push back output stream: "matrix_o[22]"
		for (int i = 0; i < aesl_tmp_355; i++)
		{
			matrix_o[22].write(aesl_tmp_354[i]);
		}

		// push back output stream: "matrix_o[23]"
		for (int i = 0; i < aesl_tmp_358; i++)
		{
			matrix_o[23].write(aesl_tmp_357[i]);
		}

		// push back output stream: "matrix_o[24]"
		for (int i = 0; i < aesl_tmp_361; i++)
		{
			matrix_o[24].write(aesl_tmp_360[i]);
		}

		// push back output stream: "matrix_o[25]"
		for (int i = 0; i < aesl_tmp_364; i++)
		{
			matrix_o[25].write(aesl_tmp_363[i]);
		}

		// push back output stream: "matrix_o[26]"
		for (int i = 0; i < aesl_tmp_367; i++)
		{
			matrix_o[26].write(aesl_tmp_366[i]);
		}

		// push back output stream: "matrix_o[27]"
		for (int i = 0; i < aesl_tmp_370; i++)
		{
			matrix_o[27].write(aesl_tmp_369[i]);
		}

		// push back output stream: "matrix_o[28]"
		for (int i = 0; i < aesl_tmp_373; i++)
		{
			matrix_o[28].write(aesl_tmp_372[i]);
		}

		// push back output stream: "matrix_o[29]"
		for (int i = 0; i < aesl_tmp_376; i++)
		{
			matrix_o[29].write(aesl_tmp_375[i]);
		}

		// push back output stream: "matrix_o[30]"
		for (int i = 0; i < aesl_tmp_379; i++)
		{
			matrix_o[30].write(aesl_tmp_378[i]);
		}

		// push back output stream: "matrix_o[31]"
		for (int i = 0; i < aesl_tmp_382; i++)
		{
			matrix_o[31].write(aesl_tmp_381[i]);
		}

		// push back output stream: "matrix_o[32]"
		for (int i = 0; i < aesl_tmp_385; i++)
		{
			matrix_o[32].write(aesl_tmp_384[i]);
		}

		// push back output stream: "matrix_o[33]"
		for (int i = 0; i < aesl_tmp_388; i++)
		{
			matrix_o[33].write(aesl_tmp_387[i]);
		}

		// push back output stream: "matrix_o[34]"
		for (int i = 0; i < aesl_tmp_391; i++)
		{
			matrix_o[34].write(aesl_tmp_390[i]);
		}

		// push back output stream: "matrix_o[35]"
		for (int i = 0; i < aesl_tmp_394; i++)
		{
			matrix_o[35].write(aesl_tmp_393[i]);
		}

		// push back output stream: "matrix_o[36]"
		for (int i = 0; i < aesl_tmp_397; i++)
		{
			matrix_o[36].write(aesl_tmp_396[i]);
		}

		// push back output stream: "matrix_o[37]"
		for (int i = 0; i < aesl_tmp_400; i++)
		{
			matrix_o[37].write(aesl_tmp_399[i]);
		}

		// push back output stream: "matrix_o[38]"
		for (int i = 0; i < aesl_tmp_403; i++)
		{
			matrix_o[38].write(aesl_tmp_402[i]);
		}

		// push back output stream: "matrix_o[39]"
		for (int i = 0; i < aesl_tmp_406; i++)
		{
			matrix_o[39].write(aesl_tmp_405[i]);
		}

		// push back output stream: "matrix_o[40]"
		for (int i = 0; i < aesl_tmp_409; i++)
		{
			matrix_o[40].write(aesl_tmp_408[i]);
		}

		// push back output stream: "matrix_o[41]"
		for (int i = 0; i < aesl_tmp_412; i++)
		{
			matrix_o[41].write(aesl_tmp_411[i]);
		}

		// push back output stream: "matrix_o[42]"
		for (int i = 0; i < aesl_tmp_415; i++)
		{
			matrix_o[42].write(aesl_tmp_414[i]);
		}

		// push back output stream: "matrix_o[43]"
		for (int i = 0; i < aesl_tmp_418; i++)
		{
			matrix_o[43].write(aesl_tmp_417[i]);
		}

		// push back output stream: "matrix_o[44]"
		for (int i = 0; i < aesl_tmp_421; i++)
		{
			matrix_o[44].write(aesl_tmp_420[i]);
		}

		// push back output stream: "matrix_o[45]"
		for (int i = 0; i < aesl_tmp_424; i++)
		{
			matrix_o[45].write(aesl_tmp_423[i]);
		}

		// push back output stream: "matrix_o[46]"
		for (int i = 0; i < aesl_tmp_427; i++)
		{
			matrix_o[46].write(aesl_tmp_426[i]);
		}

		// push back output stream: "matrix_o[47]"
		for (int i = 0; i < aesl_tmp_430; i++)
		{
			matrix_o[47].write(aesl_tmp_429[i]);
		}

		// push back output stream: "matrix_o[48]"
		for (int i = 0; i < aesl_tmp_433; i++)
		{
			matrix_o[48].write(aesl_tmp_432[i]);
		}

		// push back output stream: "matrix_o[49]"
		for (int i = 0; i < aesl_tmp_436; i++)
		{
			matrix_o[49].write(aesl_tmp_435[i]);
		}

		// push back output stream: "matrix_o[50]"
		for (int i = 0; i < aesl_tmp_439; i++)
		{
			matrix_o[50].write(aesl_tmp_438[i]);
		}

		// push back output stream: "matrix_o[51]"
		for (int i = 0; i < aesl_tmp_442; i++)
		{
			matrix_o[51].write(aesl_tmp_441[i]);
		}

		// push back output stream: "matrix_o[52]"
		for (int i = 0; i < aesl_tmp_445; i++)
		{
			matrix_o[52].write(aesl_tmp_444[i]);
		}

		// push back output stream: "matrix_o[53]"
		for (int i = 0; i < aesl_tmp_448; i++)
		{
			matrix_o[53].write(aesl_tmp_447[i]);
		}

		// push back output stream: "matrix_o[54]"
		for (int i = 0; i < aesl_tmp_451; i++)
		{
			matrix_o[54].write(aesl_tmp_450[i]);
		}

		// push back output stream: "matrix_o[55]"
		for (int i = 0; i < aesl_tmp_454; i++)
		{
			matrix_o[55].write(aesl_tmp_453[i]);
		}

		// push back output stream: "matrix_o[56]"
		for (int i = 0; i < aesl_tmp_457; i++)
		{
			matrix_o[56].write(aesl_tmp_456[i]);
		}

		// push back output stream: "matrix_o[57]"
		for (int i = 0; i < aesl_tmp_460; i++)
		{
			matrix_o[57].write(aesl_tmp_459[i]);
		}

		// push back output stream: "matrix_o[58]"
		for (int i = 0; i < aesl_tmp_463; i++)
		{
			matrix_o[58].write(aesl_tmp_462[i]);
		}

		// push back output stream: "matrix_o[59]"
		for (int i = 0; i < aesl_tmp_466; i++)
		{
			matrix_o[59].write(aesl_tmp_465[i]);
		}

		// push back output stream: "matrix_o[60]"
		for (int i = 0; i < aesl_tmp_469; i++)
		{
			matrix_o[60].write(aesl_tmp_468[i]);
		}

		// push back output stream: "matrix_o[61]"
		for (int i = 0; i < aesl_tmp_472; i++)
		{
			matrix_o[61].write(aesl_tmp_471[i]);
		}

		// push back output stream: "matrix_o[62]"
		for (int i = 0; i < aesl_tmp_475; i++)
		{
			matrix_o[62].write(aesl_tmp_474[i]);
		}

		// push back output stream: "matrix_o[63]"
		for (int i = 0; i < aesl_tmp_478; i++)
		{
			matrix_o[63].write(aesl_tmp_477[i]);
		}

		// push back output stream: "matrix_o[64]"
		for (int i = 0; i < aesl_tmp_481; i++)
		{
			matrix_o[64].write(aesl_tmp_480[i]);
		}

		// push back output stream: "matrix_o[65]"
		for (int i = 0; i < aesl_tmp_484; i++)
		{
			matrix_o[65].write(aesl_tmp_483[i]);
		}

		// push back output stream: "matrix_o[66]"
		for (int i = 0; i < aesl_tmp_487; i++)
		{
			matrix_o[66].write(aesl_tmp_486[i]);
		}

		// push back output stream: "matrix_o[67]"
		for (int i = 0; i < aesl_tmp_490; i++)
		{
			matrix_o[67].write(aesl_tmp_489[i]);
		}

		// push back output stream: "matrix_o[68]"
		for (int i = 0; i < aesl_tmp_493; i++)
		{
			matrix_o[68].write(aesl_tmp_492[i]);
		}

		// push back output stream: "matrix_o[69]"
		for (int i = 0; i < aesl_tmp_496; i++)
		{
			matrix_o[69].write(aesl_tmp_495[i]);
		}

		// push back output stream: "matrix_o[70]"
		for (int i = 0; i < aesl_tmp_499; i++)
		{
			matrix_o[70].write(aesl_tmp_498[i]);
		}

		// push back output stream: "matrix_o[71]"
		for (int i = 0; i < aesl_tmp_502; i++)
		{
			matrix_o[71].write(aesl_tmp_501[i]);
		}

		// push back output stream: "matrix_o[72]"
		for (int i = 0; i < aesl_tmp_505; i++)
		{
			matrix_o[72].write(aesl_tmp_504[i]);
		}

		// push back output stream: "matrix_o[73]"
		for (int i = 0; i < aesl_tmp_508; i++)
		{
			matrix_o[73].write(aesl_tmp_507[i]);
		}

		// push back output stream: "matrix_o[74]"
		for (int i = 0; i < aesl_tmp_511; i++)
		{
			matrix_o[74].write(aesl_tmp_510[i]);
		}

		// push back output stream: "matrix_o[75]"
		for (int i = 0; i < aesl_tmp_514; i++)
		{
			matrix_o[75].write(aesl_tmp_513[i]);
		}

		// push back output stream: "matrix_o[76]"
		for (int i = 0; i < aesl_tmp_517; i++)
		{
			matrix_o[76].write(aesl_tmp_516[i]);
		}

		// push back output stream: "matrix_o[77]"
		for (int i = 0; i < aesl_tmp_520; i++)
		{
			matrix_o[77].write(aesl_tmp_519[i]);
		}

		// push back output stream: "matrix_o[78]"
		for (int i = 0; i < aesl_tmp_523; i++)
		{
			matrix_o[78].write(aesl_tmp_522[i]);
		}

		// push back output stream: "matrix_o[79]"
		for (int i = 0; i < aesl_tmp_526; i++)
		{
			matrix_o[79].write(aesl_tmp_525[i]);
		}

		// push back output stream: "matrix_o[80]"
		for (int i = 0; i < aesl_tmp_529; i++)
		{
			matrix_o[80].write(aesl_tmp_528[i]);
		}

		// push back output stream: "matrix_o[81]"
		for (int i = 0; i < aesl_tmp_532; i++)
		{
			matrix_o[81].write(aesl_tmp_531[i]);
		}

		// push back output stream: "matrix_o[82]"
		for (int i = 0; i < aesl_tmp_535; i++)
		{
			matrix_o[82].write(aesl_tmp_534[i]);
		}

		// push back output stream: "matrix_o[83]"
		for (int i = 0; i < aesl_tmp_538; i++)
		{
			matrix_o[83].write(aesl_tmp_537[i]);
		}

		// push back output stream: "matrix_o[84]"
		for (int i = 0; i < aesl_tmp_541; i++)
		{
			matrix_o[84].write(aesl_tmp_540[i]);
		}

		// push back output stream: "matrix_o[85]"
		for (int i = 0; i < aesl_tmp_544; i++)
		{
			matrix_o[85].write(aesl_tmp_543[i]);
		}

		// push back output stream: "matrix_o[86]"
		for (int i = 0; i < aesl_tmp_547; i++)
		{
			matrix_o[86].write(aesl_tmp_546[i]);
		}

		// push back output stream: "matrix_o[87]"
		for (int i = 0; i < aesl_tmp_550; i++)
		{
			matrix_o[87].write(aesl_tmp_549[i]);
		}

		// push back output stream: "matrix_o[88]"
		for (int i = 0; i < aesl_tmp_553; i++)
		{
			matrix_o[88].write(aesl_tmp_552[i]);
		}

		// push back output stream: "matrix_o[89]"
		for (int i = 0; i < aesl_tmp_556; i++)
		{
			matrix_o[89].write(aesl_tmp_555[i]);
		}

		// push back output stream: "matrix_o[90]"
		for (int i = 0; i < aesl_tmp_559; i++)
		{
			matrix_o[90].write(aesl_tmp_558[i]);
		}

		// push back output stream: "matrix_o[91]"
		for (int i = 0; i < aesl_tmp_562; i++)
		{
			matrix_o[91].write(aesl_tmp_561[i]);
		}

		// push back output stream: "matrix_o[92]"
		for (int i = 0; i < aesl_tmp_565; i++)
		{
			matrix_o[92].write(aesl_tmp_564[i]);
		}

		// push back output stream: "matrix_o[93]"
		for (int i = 0; i < aesl_tmp_568; i++)
		{
			matrix_o[93].write(aesl_tmp_567[i]);
		}

		// push back output stream: "matrix_o[94]"
		for (int i = 0; i < aesl_tmp_571; i++)
		{
			matrix_o[94].write(aesl_tmp_570[i]);
		}

		// push back output stream: "matrix_o[95]"
		for (int i = 0; i < aesl_tmp_574; i++)
		{
			matrix_o[95].write(aesl_tmp_573[i]);
		}

		// push back output stream: "matrix_o[96]"
		for (int i = 0; i < aesl_tmp_577; i++)
		{
			matrix_o[96].write(aesl_tmp_576[i]);
		}

		// push back output stream: "matrix_o[97]"
		for (int i = 0; i < aesl_tmp_580; i++)
		{
			matrix_o[97].write(aesl_tmp_579[i]);
		}

		// push back output stream: "matrix_o[98]"
		for (int i = 0; i < aesl_tmp_583; i++)
		{
			matrix_o[98].write(aesl_tmp_582[i]);
		}

		// push back output stream: "matrix_o[99]"
		for (int i = 0; i < aesl_tmp_586; i++)
		{
			matrix_o[99].write(aesl_tmp_585[i]);
		}

		// push back output stream: "matrix_o[100]"
		for (int i = 0; i < aesl_tmp_589; i++)
		{
			matrix_o[100].write(aesl_tmp_588[i]);
		}

		// push back output stream: "matrix_o[101]"
		for (int i = 0; i < aesl_tmp_592; i++)
		{
			matrix_o[101].write(aesl_tmp_591[i]);
		}

		// push back output stream: "matrix_o[102]"
		for (int i = 0; i < aesl_tmp_595; i++)
		{
			matrix_o[102].write(aesl_tmp_594[i]);
		}

		// push back output stream: "matrix_o[103]"
		for (int i = 0; i < aesl_tmp_598; i++)
		{
			matrix_o[103].write(aesl_tmp_597[i]);
		}

		// push back output stream: "matrix_o[104]"
		for (int i = 0; i < aesl_tmp_601; i++)
		{
			matrix_o[104].write(aesl_tmp_600[i]);
		}

		// push back output stream: "matrix_o[105]"
		for (int i = 0; i < aesl_tmp_604; i++)
		{
			matrix_o[105].write(aesl_tmp_603[i]);
		}

		// push back output stream: "matrix_o[106]"
		for (int i = 0; i < aesl_tmp_607; i++)
		{
			matrix_o[106].write(aesl_tmp_606[i]);
		}

		// push back output stream: "matrix_o[107]"
		for (int i = 0; i < aesl_tmp_610; i++)
		{
			matrix_o[107].write(aesl_tmp_609[i]);
		}

		// push back output stream: "matrix_o[108]"
		for (int i = 0; i < aesl_tmp_613; i++)
		{
			matrix_o[108].write(aesl_tmp_612[i]);
		}

		// push back output stream: "matrix_o[109]"
		for (int i = 0; i < aesl_tmp_616; i++)
		{
			matrix_o[109].write(aesl_tmp_615[i]);
		}

		// push back output stream: "matrix_o[110]"
		for (int i = 0; i < aesl_tmp_619; i++)
		{
			matrix_o[110].write(aesl_tmp_618[i]);
		}

		// push back output stream: "matrix_o[111]"
		for (int i = 0; i < aesl_tmp_622; i++)
		{
			matrix_o[111].write(aesl_tmp_621[i]);
		}

		// push back output stream: "matrix_o[112]"
		for (int i = 0; i < aesl_tmp_625; i++)
		{
			matrix_o[112].write(aesl_tmp_624[i]);
		}

		// push back output stream: "matrix_o[113]"
		for (int i = 0; i < aesl_tmp_628; i++)
		{
			matrix_o[113].write(aesl_tmp_627[i]);
		}

		// push back output stream: "matrix_o[114]"
		for (int i = 0; i < aesl_tmp_631; i++)
		{
			matrix_o[114].write(aesl_tmp_630[i]);
		}

		// push back output stream: "matrix_o[115]"
		for (int i = 0; i < aesl_tmp_634; i++)
		{
			matrix_o[115].write(aesl_tmp_633[i]);
		}

		// push back output stream: "matrix_o[116]"
		for (int i = 0; i < aesl_tmp_637; i++)
		{
			matrix_o[116].write(aesl_tmp_636[i]);
		}

		// push back output stream: "matrix_o[117]"
		for (int i = 0; i < aesl_tmp_640; i++)
		{
			matrix_o[117].write(aesl_tmp_639[i]);
		}

		// push back output stream: "matrix_o[118]"
		for (int i = 0; i < aesl_tmp_643; i++)
		{
			matrix_o[118].write(aesl_tmp_642[i]);
		}

		// push back output stream: "matrix_o[119]"
		for (int i = 0; i < aesl_tmp_646; i++)
		{
			matrix_o[119].write(aesl_tmp_645[i]);
		}

		// push back output stream: "matrix_o[120]"
		for (int i = 0; i < aesl_tmp_649; i++)
		{
			matrix_o[120].write(aesl_tmp_648[i]);
		}

		// push back output stream: "matrix_o[121]"
		for (int i = 0; i < aesl_tmp_652; i++)
		{
			matrix_o[121].write(aesl_tmp_651[i]);
		}

		// push back output stream: "matrix_o[122]"
		for (int i = 0; i < aesl_tmp_655; i++)
		{
			matrix_o[122].write(aesl_tmp_654[i]);
		}

		// push back output stream: "matrix_o[123]"
		for (int i = 0; i < aesl_tmp_658; i++)
		{
			matrix_o[123].write(aesl_tmp_657[i]);
		}

		// push back output stream: "matrix_o[124]"
		for (int i = 0; i < aesl_tmp_661; i++)
		{
			matrix_o[124].write(aesl_tmp_660[i]);
		}

		// push back output stream: "matrix_o[125]"
		for (int i = 0; i < aesl_tmp_664; i++)
		{
			matrix_o[125].write(aesl_tmp_663[i]);
		}

		// push back output stream: "matrix_o[126]"
		for (int i = 0; i < aesl_tmp_667; i++)
		{
			matrix_o[126].write(aesl_tmp_666[i]);
		}

		// push back output stream: "matrix_o[127]"
		for (int i = 0; i < aesl_tmp_670; i++)
		{
			matrix_o[127].write(aesl_tmp_669[i]);
		}

		AESL_transaction_pc++;
	}
	else
	{
		static unsigned AESL_transaction;

		static AESL_FILE_HANDLER aesl_fh;

		// "matrix_i_0_V"
		char* tvin_matrix_i_0_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_0_V);
		char* wrapc_stream_size_in_matrix_i_0_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_0_V);
		char* wrapc_stream_ingress_status_matrix_i_0_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V);

		// "matrix_i_1_V"
		char* tvin_matrix_i_1_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_1_V);
		char* wrapc_stream_size_in_matrix_i_1_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_1_V);
		char* wrapc_stream_ingress_status_matrix_i_1_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V);

		// "matrix_i_2_V"
		char* tvin_matrix_i_2_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_2_V);
		char* wrapc_stream_size_in_matrix_i_2_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_2_V);
		char* wrapc_stream_ingress_status_matrix_i_2_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V);

		// "matrix_i_3_V"
		char* tvin_matrix_i_3_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_3_V);
		char* wrapc_stream_size_in_matrix_i_3_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_3_V);
		char* wrapc_stream_ingress_status_matrix_i_3_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V);

		// "matrix_i_4_V"
		char* tvin_matrix_i_4_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_4_V);
		char* wrapc_stream_size_in_matrix_i_4_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_4_V);
		char* wrapc_stream_ingress_status_matrix_i_4_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V);

		// "matrix_i_5_V"
		char* tvin_matrix_i_5_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_5_V);
		char* wrapc_stream_size_in_matrix_i_5_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_5_V);
		char* wrapc_stream_ingress_status_matrix_i_5_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V);

		// "matrix_i_6_V"
		char* tvin_matrix_i_6_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_6_V);
		char* wrapc_stream_size_in_matrix_i_6_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_6_V);
		char* wrapc_stream_ingress_status_matrix_i_6_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V);

		// "matrix_i_7_V"
		char* tvin_matrix_i_7_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_7_V);
		char* wrapc_stream_size_in_matrix_i_7_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_7_V);
		char* wrapc_stream_ingress_status_matrix_i_7_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V);

		// "matrix_i_8_V"
		char* tvin_matrix_i_8_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_8_V);
		char* wrapc_stream_size_in_matrix_i_8_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_8_V);
		char* wrapc_stream_ingress_status_matrix_i_8_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V);

		// "matrix_i_9_V"
		char* tvin_matrix_i_9_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_9_V);
		char* wrapc_stream_size_in_matrix_i_9_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_9_V);
		char* wrapc_stream_ingress_status_matrix_i_9_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V);

		// "matrix_i_10_V"
		char* tvin_matrix_i_10_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_10_V);
		char* wrapc_stream_size_in_matrix_i_10_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_10_V);
		char* wrapc_stream_ingress_status_matrix_i_10_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V);

		// "matrix_i_11_V"
		char* tvin_matrix_i_11_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_11_V);
		char* wrapc_stream_size_in_matrix_i_11_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_11_V);
		char* wrapc_stream_ingress_status_matrix_i_11_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V);

		// "matrix_i_12_V"
		char* tvin_matrix_i_12_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_12_V);
		char* wrapc_stream_size_in_matrix_i_12_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_12_V);
		char* wrapc_stream_ingress_status_matrix_i_12_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V);

		// "matrix_i_13_V"
		char* tvin_matrix_i_13_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_13_V);
		char* wrapc_stream_size_in_matrix_i_13_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_13_V);
		char* wrapc_stream_ingress_status_matrix_i_13_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V);

		// "matrix_i_14_V"
		char* tvin_matrix_i_14_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_14_V);
		char* wrapc_stream_size_in_matrix_i_14_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_14_V);
		char* wrapc_stream_ingress_status_matrix_i_14_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V);

		// "matrix_i_15_V"
		char* tvin_matrix_i_15_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_15_V);
		char* wrapc_stream_size_in_matrix_i_15_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_15_V);
		char* wrapc_stream_ingress_status_matrix_i_15_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V);

		// "matrix_i_16_V"
		char* tvin_matrix_i_16_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_16_V);
		char* wrapc_stream_size_in_matrix_i_16_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_16_V);
		char* wrapc_stream_ingress_status_matrix_i_16_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V);

		// "matrix_i_17_V"
		char* tvin_matrix_i_17_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_17_V);
		char* wrapc_stream_size_in_matrix_i_17_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_17_V);
		char* wrapc_stream_ingress_status_matrix_i_17_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V);

		// "matrix_i_18_V"
		char* tvin_matrix_i_18_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_18_V);
		char* wrapc_stream_size_in_matrix_i_18_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_18_V);
		char* wrapc_stream_ingress_status_matrix_i_18_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V);

		// "matrix_i_19_V"
		char* tvin_matrix_i_19_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_19_V);
		char* wrapc_stream_size_in_matrix_i_19_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_19_V);
		char* wrapc_stream_ingress_status_matrix_i_19_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V);

		// "matrix_i_20_V"
		char* tvin_matrix_i_20_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_20_V);
		char* wrapc_stream_size_in_matrix_i_20_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_20_V);
		char* wrapc_stream_ingress_status_matrix_i_20_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V);

		// "matrix_i_21_V"
		char* tvin_matrix_i_21_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_21_V);
		char* wrapc_stream_size_in_matrix_i_21_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_21_V);
		char* wrapc_stream_ingress_status_matrix_i_21_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V);

		// "matrix_i_22_V"
		char* tvin_matrix_i_22_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_22_V);
		char* wrapc_stream_size_in_matrix_i_22_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_22_V);
		char* wrapc_stream_ingress_status_matrix_i_22_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V);

		// "matrix_i_23_V"
		char* tvin_matrix_i_23_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_23_V);
		char* wrapc_stream_size_in_matrix_i_23_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_23_V);
		char* wrapc_stream_ingress_status_matrix_i_23_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V);

		// "matrix_i_24_V"
		char* tvin_matrix_i_24_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_24_V);
		char* wrapc_stream_size_in_matrix_i_24_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_24_V);
		char* wrapc_stream_ingress_status_matrix_i_24_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V);

		// "matrix_i_25_V"
		char* tvin_matrix_i_25_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_25_V);
		char* wrapc_stream_size_in_matrix_i_25_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_25_V);
		char* wrapc_stream_ingress_status_matrix_i_25_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V);

		// "matrix_i_26_V"
		char* tvin_matrix_i_26_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_26_V);
		char* wrapc_stream_size_in_matrix_i_26_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_26_V);
		char* wrapc_stream_ingress_status_matrix_i_26_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V);

		// "matrix_i_27_V"
		char* tvin_matrix_i_27_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_27_V);
		char* wrapc_stream_size_in_matrix_i_27_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_27_V);
		char* wrapc_stream_ingress_status_matrix_i_27_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V);

		// "matrix_i_28_V"
		char* tvin_matrix_i_28_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_28_V);
		char* wrapc_stream_size_in_matrix_i_28_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_28_V);
		char* wrapc_stream_ingress_status_matrix_i_28_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V);

		// "matrix_i_29_V"
		char* tvin_matrix_i_29_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_29_V);
		char* wrapc_stream_size_in_matrix_i_29_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_29_V);
		char* wrapc_stream_ingress_status_matrix_i_29_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V);

		// "matrix_i_30_V"
		char* tvin_matrix_i_30_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_30_V);
		char* wrapc_stream_size_in_matrix_i_30_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_30_V);
		char* wrapc_stream_ingress_status_matrix_i_30_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V);

		// "matrix_i_31_V"
		char* tvin_matrix_i_31_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_31_V);
		char* wrapc_stream_size_in_matrix_i_31_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_31_V);
		char* wrapc_stream_ingress_status_matrix_i_31_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V);

		// "matrix_i_32_V"
		char* tvin_matrix_i_32_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_32_V);
		char* wrapc_stream_size_in_matrix_i_32_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_32_V);
		char* wrapc_stream_ingress_status_matrix_i_32_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V);

		// "matrix_i_33_V"
		char* tvin_matrix_i_33_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_33_V);
		char* wrapc_stream_size_in_matrix_i_33_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_33_V);
		char* wrapc_stream_ingress_status_matrix_i_33_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V);

		// "matrix_i_34_V"
		char* tvin_matrix_i_34_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_34_V);
		char* wrapc_stream_size_in_matrix_i_34_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_34_V);
		char* wrapc_stream_ingress_status_matrix_i_34_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V);

		// "matrix_i_35_V"
		char* tvin_matrix_i_35_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_35_V);
		char* wrapc_stream_size_in_matrix_i_35_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_35_V);
		char* wrapc_stream_ingress_status_matrix_i_35_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V);

		// "matrix_i_36_V"
		char* tvin_matrix_i_36_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_36_V);
		char* wrapc_stream_size_in_matrix_i_36_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_36_V);
		char* wrapc_stream_ingress_status_matrix_i_36_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V);

		// "matrix_i_37_V"
		char* tvin_matrix_i_37_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_37_V);
		char* wrapc_stream_size_in_matrix_i_37_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_37_V);
		char* wrapc_stream_ingress_status_matrix_i_37_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V);

		// "matrix_i_38_V"
		char* tvin_matrix_i_38_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_38_V);
		char* wrapc_stream_size_in_matrix_i_38_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_38_V);
		char* wrapc_stream_ingress_status_matrix_i_38_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V);

		// "matrix_i_39_V"
		char* tvin_matrix_i_39_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_39_V);
		char* wrapc_stream_size_in_matrix_i_39_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_39_V);
		char* wrapc_stream_ingress_status_matrix_i_39_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V);

		// "matrix_i_40_V"
		char* tvin_matrix_i_40_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_40_V);
		char* wrapc_stream_size_in_matrix_i_40_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_40_V);
		char* wrapc_stream_ingress_status_matrix_i_40_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V);

		// "matrix_i_41_V"
		char* tvin_matrix_i_41_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_41_V);
		char* wrapc_stream_size_in_matrix_i_41_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_41_V);
		char* wrapc_stream_ingress_status_matrix_i_41_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V);

		// "matrix_i_42_V"
		char* tvin_matrix_i_42_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_42_V);
		char* wrapc_stream_size_in_matrix_i_42_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_42_V);
		char* wrapc_stream_ingress_status_matrix_i_42_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V);

		// "matrix_i_43_V"
		char* tvin_matrix_i_43_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_43_V);
		char* wrapc_stream_size_in_matrix_i_43_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_43_V);
		char* wrapc_stream_ingress_status_matrix_i_43_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V);

		// "matrix_i_44_V"
		char* tvin_matrix_i_44_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_44_V);
		char* wrapc_stream_size_in_matrix_i_44_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_44_V);
		char* wrapc_stream_ingress_status_matrix_i_44_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V);

		// "matrix_i_45_V"
		char* tvin_matrix_i_45_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_45_V);
		char* wrapc_stream_size_in_matrix_i_45_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_45_V);
		char* wrapc_stream_ingress_status_matrix_i_45_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V);

		// "matrix_i_46_V"
		char* tvin_matrix_i_46_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_46_V);
		char* wrapc_stream_size_in_matrix_i_46_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_46_V);
		char* wrapc_stream_ingress_status_matrix_i_46_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V);

		// "matrix_i_47_V"
		char* tvin_matrix_i_47_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_47_V);
		char* wrapc_stream_size_in_matrix_i_47_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_47_V);
		char* wrapc_stream_ingress_status_matrix_i_47_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V);

		// "matrix_i_48_V"
		char* tvin_matrix_i_48_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_48_V);
		char* wrapc_stream_size_in_matrix_i_48_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_48_V);
		char* wrapc_stream_ingress_status_matrix_i_48_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V);

		// "matrix_i_49_V"
		char* tvin_matrix_i_49_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_49_V);
		char* wrapc_stream_size_in_matrix_i_49_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_49_V);
		char* wrapc_stream_ingress_status_matrix_i_49_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V);

		// "matrix_i_50_V"
		char* tvin_matrix_i_50_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_50_V);
		char* wrapc_stream_size_in_matrix_i_50_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_50_V);
		char* wrapc_stream_ingress_status_matrix_i_50_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V);

		// "matrix_i_51_V"
		char* tvin_matrix_i_51_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_51_V);
		char* wrapc_stream_size_in_matrix_i_51_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_51_V);
		char* wrapc_stream_ingress_status_matrix_i_51_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V);

		// "matrix_i_52_V"
		char* tvin_matrix_i_52_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_52_V);
		char* wrapc_stream_size_in_matrix_i_52_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_52_V);
		char* wrapc_stream_ingress_status_matrix_i_52_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V);

		// "matrix_i_53_V"
		char* tvin_matrix_i_53_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_53_V);
		char* wrapc_stream_size_in_matrix_i_53_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_53_V);
		char* wrapc_stream_ingress_status_matrix_i_53_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V);

		// "matrix_i_54_V"
		char* tvin_matrix_i_54_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_54_V);
		char* wrapc_stream_size_in_matrix_i_54_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_54_V);
		char* wrapc_stream_ingress_status_matrix_i_54_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V);

		// "matrix_i_55_V"
		char* tvin_matrix_i_55_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_55_V);
		char* wrapc_stream_size_in_matrix_i_55_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_55_V);
		char* wrapc_stream_ingress_status_matrix_i_55_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V);

		// "matrix_i_56_V"
		char* tvin_matrix_i_56_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_56_V);
		char* wrapc_stream_size_in_matrix_i_56_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_56_V);
		char* wrapc_stream_ingress_status_matrix_i_56_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V);

		// "matrix_i_57_V"
		char* tvin_matrix_i_57_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_57_V);
		char* wrapc_stream_size_in_matrix_i_57_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_57_V);
		char* wrapc_stream_ingress_status_matrix_i_57_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V);

		// "matrix_i_58_V"
		char* tvin_matrix_i_58_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_58_V);
		char* wrapc_stream_size_in_matrix_i_58_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_58_V);
		char* wrapc_stream_ingress_status_matrix_i_58_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V);

		// "matrix_i_59_V"
		char* tvin_matrix_i_59_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_59_V);
		char* wrapc_stream_size_in_matrix_i_59_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_59_V);
		char* wrapc_stream_ingress_status_matrix_i_59_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V);

		// "matrix_i_60_V"
		char* tvin_matrix_i_60_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_60_V);
		char* wrapc_stream_size_in_matrix_i_60_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_60_V);
		char* wrapc_stream_ingress_status_matrix_i_60_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V);

		// "matrix_i_61_V"
		char* tvin_matrix_i_61_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_61_V);
		char* wrapc_stream_size_in_matrix_i_61_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_61_V);
		char* wrapc_stream_ingress_status_matrix_i_61_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V);

		// "matrix_i_62_V"
		char* tvin_matrix_i_62_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_62_V);
		char* wrapc_stream_size_in_matrix_i_62_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_62_V);
		char* wrapc_stream_ingress_status_matrix_i_62_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V);

		// "matrix_i_63_V"
		char* tvin_matrix_i_63_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_63_V);
		char* wrapc_stream_size_in_matrix_i_63_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_63_V);
		char* wrapc_stream_ingress_status_matrix_i_63_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V);

		// "matrix_i_64_V"
		char* tvin_matrix_i_64_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_64_V);
		char* wrapc_stream_size_in_matrix_i_64_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_64_V);
		char* wrapc_stream_ingress_status_matrix_i_64_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V);

		// "matrix_i_65_V"
		char* tvin_matrix_i_65_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_65_V);
		char* wrapc_stream_size_in_matrix_i_65_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_65_V);
		char* wrapc_stream_ingress_status_matrix_i_65_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V);

		// "matrix_i_66_V"
		char* tvin_matrix_i_66_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_66_V);
		char* wrapc_stream_size_in_matrix_i_66_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_66_V);
		char* wrapc_stream_ingress_status_matrix_i_66_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V);

		// "matrix_i_67_V"
		char* tvin_matrix_i_67_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_67_V);
		char* wrapc_stream_size_in_matrix_i_67_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_67_V);
		char* wrapc_stream_ingress_status_matrix_i_67_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V);

		// "matrix_i_68_V"
		char* tvin_matrix_i_68_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_68_V);
		char* wrapc_stream_size_in_matrix_i_68_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_68_V);
		char* wrapc_stream_ingress_status_matrix_i_68_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V);

		// "matrix_i_69_V"
		char* tvin_matrix_i_69_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_69_V);
		char* wrapc_stream_size_in_matrix_i_69_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_69_V);
		char* wrapc_stream_ingress_status_matrix_i_69_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V);

		// "matrix_i_70_V"
		char* tvin_matrix_i_70_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_70_V);
		char* wrapc_stream_size_in_matrix_i_70_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_70_V);
		char* wrapc_stream_ingress_status_matrix_i_70_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V);

		// "matrix_i_71_V"
		char* tvin_matrix_i_71_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_71_V);
		char* wrapc_stream_size_in_matrix_i_71_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_71_V);
		char* wrapc_stream_ingress_status_matrix_i_71_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V);

		// "matrix_i_72_V"
		char* tvin_matrix_i_72_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_72_V);
		char* wrapc_stream_size_in_matrix_i_72_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_72_V);
		char* wrapc_stream_ingress_status_matrix_i_72_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V);

		// "matrix_i_73_V"
		char* tvin_matrix_i_73_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_73_V);
		char* wrapc_stream_size_in_matrix_i_73_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_73_V);
		char* wrapc_stream_ingress_status_matrix_i_73_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V);

		// "matrix_i_74_V"
		char* tvin_matrix_i_74_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_74_V);
		char* wrapc_stream_size_in_matrix_i_74_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_74_V);
		char* wrapc_stream_ingress_status_matrix_i_74_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V);

		// "matrix_i_75_V"
		char* tvin_matrix_i_75_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_75_V);
		char* wrapc_stream_size_in_matrix_i_75_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_75_V);
		char* wrapc_stream_ingress_status_matrix_i_75_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V);

		// "matrix_i_76_V"
		char* tvin_matrix_i_76_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_76_V);
		char* wrapc_stream_size_in_matrix_i_76_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_76_V);
		char* wrapc_stream_ingress_status_matrix_i_76_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V);

		// "matrix_i_77_V"
		char* tvin_matrix_i_77_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_77_V);
		char* wrapc_stream_size_in_matrix_i_77_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_77_V);
		char* wrapc_stream_ingress_status_matrix_i_77_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V);

		// "matrix_i_78_V"
		char* tvin_matrix_i_78_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_78_V);
		char* wrapc_stream_size_in_matrix_i_78_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_78_V);
		char* wrapc_stream_ingress_status_matrix_i_78_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V);

		// "matrix_i_79_V"
		char* tvin_matrix_i_79_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_79_V);
		char* wrapc_stream_size_in_matrix_i_79_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_79_V);
		char* wrapc_stream_ingress_status_matrix_i_79_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V);

		// "matrix_i_80_V"
		char* tvin_matrix_i_80_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_80_V);
		char* wrapc_stream_size_in_matrix_i_80_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_80_V);
		char* wrapc_stream_ingress_status_matrix_i_80_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V);

		// "matrix_i_81_V"
		char* tvin_matrix_i_81_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_81_V);
		char* wrapc_stream_size_in_matrix_i_81_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_81_V);
		char* wrapc_stream_ingress_status_matrix_i_81_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V);

		// "matrix_i_82_V"
		char* tvin_matrix_i_82_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_82_V);
		char* wrapc_stream_size_in_matrix_i_82_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_82_V);
		char* wrapc_stream_ingress_status_matrix_i_82_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V);

		// "matrix_i_83_V"
		char* tvin_matrix_i_83_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_83_V);
		char* wrapc_stream_size_in_matrix_i_83_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_83_V);
		char* wrapc_stream_ingress_status_matrix_i_83_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V);

		// "matrix_i_84_V"
		char* tvin_matrix_i_84_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_84_V);
		char* wrapc_stream_size_in_matrix_i_84_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_84_V);
		char* wrapc_stream_ingress_status_matrix_i_84_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V);

		// "matrix_i_85_V"
		char* tvin_matrix_i_85_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_85_V);
		char* wrapc_stream_size_in_matrix_i_85_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_85_V);
		char* wrapc_stream_ingress_status_matrix_i_85_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V);

		// "matrix_i_86_V"
		char* tvin_matrix_i_86_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_86_V);
		char* wrapc_stream_size_in_matrix_i_86_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_86_V);
		char* wrapc_stream_ingress_status_matrix_i_86_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V);

		// "matrix_i_87_V"
		char* tvin_matrix_i_87_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_87_V);
		char* wrapc_stream_size_in_matrix_i_87_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_87_V);
		char* wrapc_stream_ingress_status_matrix_i_87_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V);

		// "matrix_i_88_V"
		char* tvin_matrix_i_88_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_88_V);
		char* wrapc_stream_size_in_matrix_i_88_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_88_V);
		char* wrapc_stream_ingress_status_matrix_i_88_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V);

		// "matrix_i_89_V"
		char* tvin_matrix_i_89_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_89_V);
		char* wrapc_stream_size_in_matrix_i_89_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_89_V);
		char* wrapc_stream_ingress_status_matrix_i_89_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V);

		// "matrix_i_90_V"
		char* tvin_matrix_i_90_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_90_V);
		char* wrapc_stream_size_in_matrix_i_90_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_90_V);
		char* wrapc_stream_ingress_status_matrix_i_90_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V);

		// "matrix_i_91_V"
		char* tvin_matrix_i_91_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_91_V);
		char* wrapc_stream_size_in_matrix_i_91_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_91_V);
		char* wrapc_stream_ingress_status_matrix_i_91_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V);

		// "matrix_i_92_V"
		char* tvin_matrix_i_92_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_92_V);
		char* wrapc_stream_size_in_matrix_i_92_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_92_V);
		char* wrapc_stream_ingress_status_matrix_i_92_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V);

		// "matrix_i_93_V"
		char* tvin_matrix_i_93_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_93_V);
		char* wrapc_stream_size_in_matrix_i_93_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_93_V);
		char* wrapc_stream_ingress_status_matrix_i_93_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V);

		// "matrix_i_94_V"
		char* tvin_matrix_i_94_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_94_V);
		char* wrapc_stream_size_in_matrix_i_94_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_94_V);
		char* wrapc_stream_ingress_status_matrix_i_94_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V);

		// "matrix_i_95_V"
		char* tvin_matrix_i_95_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_i_95_V);
		char* wrapc_stream_size_in_matrix_i_95_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_IN_matrix_i_95_V);
		char* wrapc_stream_ingress_status_matrix_i_95_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V);

		// "kernel_s1x1"
		char* tvin_kernel_s1x1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_kernel_s1x1);

		// "kernel_e1x1"
		char* tvin_kernel_e1x1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_kernel_e1x1);

		// "kernel_e3x3"
		char* tvin_kernel_e3x3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_kernel_e3x3);

		// "matrix_o_0_V"
		char* tvin_matrix_o_0_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_0_V);
		char* tvout_matrix_o_0_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_0_V);
		char* wrapc_stream_size_out_matrix_o_0_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V);
		char* wrapc_stream_egress_status_matrix_o_0_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_0_V);

		// "matrix_o_1_V"
		char* tvin_matrix_o_1_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_1_V);
		char* tvout_matrix_o_1_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_1_V);
		char* wrapc_stream_size_out_matrix_o_1_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_1_V);
		char* wrapc_stream_egress_status_matrix_o_1_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_1_V);

		// "matrix_o_2_V"
		char* tvin_matrix_o_2_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_2_V);
		char* tvout_matrix_o_2_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_2_V);
		char* wrapc_stream_size_out_matrix_o_2_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_2_V);
		char* wrapc_stream_egress_status_matrix_o_2_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_2_V);

		// "matrix_o_3_V"
		char* tvin_matrix_o_3_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_3_V);
		char* tvout_matrix_o_3_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_3_V);
		char* wrapc_stream_size_out_matrix_o_3_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_3_V);
		char* wrapc_stream_egress_status_matrix_o_3_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_3_V);

		// "matrix_o_4_V"
		char* tvin_matrix_o_4_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_4_V);
		char* tvout_matrix_o_4_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_4_V);
		char* wrapc_stream_size_out_matrix_o_4_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_4_V);
		char* wrapc_stream_egress_status_matrix_o_4_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_4_V);

		// "matrix_o_5_V"
		char* tvin_matrix_o_5_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_5_V);
		char* tvout_matrix_o_5_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_5_V);
		char* wrapc_stream_size_out_matrix_o_5_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_5_V);
		char* wrapc_stream_egress_status_matrix_o_5_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_5_V);

		// "matrix_o_6_V"
		char* tvin_matrix_o_6_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_6_V);
		char* tvout_matrix_o_6_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_6_V);
		char* wrapc_stream_size_out_matrix_o_6_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_6_V);
		char* wrapc_stream_egress_status_matrix_o_6_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_6_V);

		// "matrix_o_7_V"
		char* tvin_matrix_o_7_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_7_V);
		char* tvout_matrix_o_7_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_7_V);
		char* wrapc_stream_size_out_matrix_o_7_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_7_V);
		char* wrapc_stream_egress_status_matrix_o_7_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_7_V);

		// "matrix_o_8_V"
		char* tvin_matrix_o_8_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_8_V);
		char* tvout_matrix_o_8_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_8_V);
		char* wrapc_stream_size_out_matrix_o_8_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_8_V);
		char* wrapc_stream_egress_status_matrix_o_8_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_8_V);

		// "matrix_o_9_V"
		char* tvin_matrix_o_9_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_9_V);
		char* tvout_matrix_o_9_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_9_V);
		char* wrapc_stream_size_out_matrix_o_9_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_9_V);
		char* wrapc_stream_egress_status_matrix_o_9_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_9_V);

		// "matrix_o_10_V"
		char* tvin_matrix_o_10_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_10_V);
		char* tvout_matrix_o_10_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_10_V);
		char* wrapc_stream_size_out_matrix_o_10_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_10_V);
		char* wrapc_stream_egress_status_matrix_o_10_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_10_V);

		// "matrix_o_11_V"
		char* tvin_matrix_o_11_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_11_V);
		char* tvout_matrix_o_11_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_11_V);
		char* wrapc_stream_size_out_matrix_o_11_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_11_V);
		char* wrapc_stream_egress_status_matrix_o_11_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_11_V);

		// "matrix_o_12_V"
		char* tvin_matrix_o_12_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_12_V);
		char* tvout_matrix_o_12_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_12_V);
		char* wrapc_stream_size_out_matrix_o_12_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_12_V);
		char* wrapc_stream_egress_status_matrix_o_12_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_12_V);

		// "matrix_o_13_V"
		char* tvin_matrix_o_13_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_13_V);
		char* tvout_matrix_o_13_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_13_V);
		char* wrapc_stream_size_out_matrix_o_13_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_13_V);
		char* wrapc_stream_egress_status_matrix_o_13_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_13_V);

		// "matrix_o_14_V"
		char* tvin_matrix_o_14_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_14_V);
		char* tvout_matrix_o_14_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_14_V);
		char* wrapc_stream_size_out_matrix_o_14_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_14_V);
		char* wrapc_stream_egress_status_matrix_o_14_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_14_V);

		// "matrix_o_15_V"
		char* tvin_matrix_o_15_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_15_V);
		char* tvout_matrix_o_15_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_15_V);
		char* wrapc_stream_size_out_matrix_o_15_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_15_V);
		char* wrapc_stream_egress_status_matrix_o_15_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_15_V);

		// "matrix_o_16_V"
		char* tvin_matrix_o_16_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_16_V);
		char* tvout_matrix_o_16_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_16_V);
		char* wrapc_stream_size_out_matrix_o_16_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_16_V);
		char* wrapc_stream_egress_status_matrix_o_16_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_16_V);

		// "matrix_o_17_V"
		char* tvin_matrix_o_17_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_17_V);
		char* tvout_matrix_o_17_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_17_V);
		char* wrapc_stream_size_out_matrix_o_17_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_17_V);
		char* wrapc_stream_egress_status_matrix_o_17_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_17_V);

		// "matrix_o_18_V"
		char* tvin_matrix_o_18_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_18_V);
		char* tvout_matrix_o_18_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_18_V);
		char* wrapc_stream_size_out_matrix_o_18_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_18_V);
		char* wrapc_stream_egress_status_matrix_o_18_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_18_V);

		// "matrix_o_19_V"
		char* tvin_matrix_o_19_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_19_V);
		char* tvout_matrix_o_19_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_19_V);
		char* wrapc_stream_size_out_matrix_o_19_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_19_V);
		char* wrapc_stream_egress_status_matrix_o_19_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_19_V);

		// "matrix_o_20_V"
		char* tvin_matrix_o_20_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_20_V);
		char* tvout_matrix_o_20_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_20_V);
		char* wrapc_stream_size_out_matrix_o_20_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_20_V);
		char* wrapc_stream_egress_status_matrix_o_20_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_20_V);

		// "matrix_o_21_V"
		char* tvin_matrix_o_21_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_21_V);
		char* tvout_matrix_o_21_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_21_V);
		char* wrapc_stream_size_out_matrix_o_21_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_21_V);
		char* wrapc_stream_egress_status_matrix_o_21_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_21_V);

		// "matrix_o_22_V"
		char* tvin_matrix_o_22_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_22_V);
		char* tvout_matrix_o_22_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_22_V);
		char* wrapc_stream_size_out_matrix_o_22_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_22_V);
		char* wrapc_stream_egress_status_matrix_o_22_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_22_V);

		// "matrix_o_23_V"
		char* tvin_matrix_o_23_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_23_V);
		char* tvout_matrix_o_23_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_23_V);
		char* wrapc_stream_size_out_matrix_o_23_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_23_V);
		char* wrapc_stream_egress_status_matrix_o_23_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_23_V);

		// "matrix_o_24_V"
		char* tvin_matrix_o_24_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_24_V);
		char* tvout_matrix_o_24_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_24_V);
		char* wrapc_stream_size_out_matrix_o_24_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_24_V);
		char* wrapc_stream_egress_status_matrix_o_24_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_24_V);

		// "matrix_o_25_V"
		char* tvin_matrix_o_25_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_25_V);
		char* tvout_matrix_o_25_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_25_V);
		char* wrapc_stream_size_out_matrix_o_25_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_25_V);
		char* wrapc_stream_egress_status_matrix_o_25_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_25_V);

		// "matrix_o_26_V"
		char* tvin_matrix_o_26_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_26_V);
		char* tvout_matrix_o_26_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_26_V);
		char* wrapc_stream_size_out_matrix_o_26_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_26_V);
		char* wrapc_stream_egress_status_matrix_o_26_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_26_V);

		// "matrix_o_27_V"
		char* tvin_matrix_o_27_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_27_V);
		char* tvout_matrix_o_27_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_27_V);
		char* wrapc_stream_size_out_matrix_o_27_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_27_V);
		char* wrapc_stream_egress_status_matrix_o_27_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_27_V);

		// "matrix_o_28_V"
		char* tvin_matrix_o_28_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_28_V);
		char* tvout_matrix_o_28_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_28_V);
		char* wrapc_stream_size_out_matrix_o_28_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_28_V);
		char* wrapc_stream_egress_status_matrix_o_28_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_28_V);

		// "matrix_o_29_V"
		char* tvin_matrix_o_29_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_29_V);
		char* tvout_matrix_o_29_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_29_V);
		char* wrapc_stream_size_out_matrix_o_29_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_29_V);
		char* wrapc_stream_egress_status_matrix_o_29_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_29_V);

		// "matrix_o_30_V"
		char* tvin_matrix_o_30_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_30_V);
		char* tvout_matrix_o_30_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_30_V);
		char* wrapc_stream_size_out_matrix_o_30_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_30_V);
		char* wrapc_stream_egress_status_matrix_o_30_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_30_V);

		// "matrix_o_31_V"
		char* tvin_matrix_o_31_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_31_V);
		char* tvout_matrix_o_31_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_31_V);
		char* wrapc_stream_size_out_matrix_o_31_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_31_V);
		char* wrapc_stream_egress_status_matrix_o_31_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_31_V);

		// "matrix_o_32_V"
		char* tvin_matrix_o_32_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_32_V);
		char* tvout_matrix_o_32_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_32_V);
		char* wrapc_stream_size_out_matrix_o_32_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_32_V);
		char* wrapc_stream_egress_status_matrix_o_32_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_32_V);

		// "matrix_o_33_V"
		char* tvin_matrix_o_33_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_33_V);
		char* tvout_matrix_o_33_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_33_V);
		char* wrapc_stream_size_out_matrix_o_33_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_33_V);
		char* wrapc_stream_egress_status_matrix_o_33_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_33_V);

		// "matrix_o_34_V"
		char* tvin_matrix_o_34_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_34_V);
		char* tvout_matrix_o_34_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_34_V);
		char* wrapc_stream_size_out_matrix_o_34_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_34_V);
		char* wrapc_stream_egress_status_matrix_o_34_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_34_V);

		// "matrix_o_35_V"
		char* tvin_matrix_o_35_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_35_V);
		char* tvout_matrix_o_35_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_35_V);
		char* wrapc_stream_size_out_matrix_o_35_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_35_V);
		char* wrapc_stream_egress_status_matrix_o_35_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_35_V);

		// "matrix_o_36_V"
		char* tvin_matrix_o_36_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_36_V);
		char* tvout_matrix_o_36_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_36_V);
		char* wrapc_stream_size_out_matrix_o_36_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_36_V);
		char* wrapc_stream_egress_status_matrix_o_36_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_36_V);

		// "matrix_o_37_V"
		char* tvin_matrix_o_37_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_37_V);
		char* tvout_matrix_o_37_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_37_V);
		char* wrapc_stream_size_out_matrix_o_37_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_37_V);
		char* wrapc_stream_egress_status_matrix_o_37_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_37_V);

		// "matrix_o_38_V"
		char* tvin_matrix_o_38_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_38_V);
		char* tvout_matrix_o_38_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_38_V);
		char* wrapc_stream_size_out_matrix_o_38_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_38_V);
		char* wrapc_stream_egress_status_matrix_o_38_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_38_V);

		// "matrix_o_39_V"
		char* tvin_matrix_o_39_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_39_V);
		char* tvout_matrix_o_39_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_39_V);
		char* wrapc_stream_size_out_matrix_o_39_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_39_V);
		char* wrapc_stream_egress_status_matrix_o_39_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_39_V);

		// "matrix_o_40_V"
		char* tvin_matrix_o_40_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_40_V);
		char* tvout_matrix_o_40_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_40_V);
		char* wrapc_stream_size_out_matrix_o_40_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_40_V);
		char* wrapc_stream_egress_status_matrix_o_40_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_40_V);

		// "matrix_o_41_V"
		char* tvin_matrix_o_41_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_41_V);
		char* tvout_matrix_o_41_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_41_V);
		char* wrapc_stream_size_out_matrix_o_41_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_41_V);
		char* wrapc_stream_egress_status_matrix_o_41_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_41_V);

		// "matrix_o_42_V"
		char* tvin_matrix_o_42_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_42_V);
		char* tvout_matrix_o_42_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_42_V);
		char* wrapc_stream_size_out_matrix_o_42_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_42_V);
		char* wrapc_stream_egress_status_matrix_o_42_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_42_V);

		// "matrix_o_43_V"
		char* tvin_matrix_o_43_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_43_V);
		char* tvout_matrix_o_43_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_43_V);
		char* wrapc_stream_size_out_matrix_o_43_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_43_V);
		char* wrapc_stream_egress_status_matrix_o_43_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_43_V);

		// "matrix_o_44_V"
		char* tvin_matrix_o_44_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_44_V);
		char* tvout_matrix_o_44_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_44_V);
		char* wrapc_stream_size_out_matrix_o_44_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_44_V);
		char* wrapc_stream_egress_status_matrix_o_44_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_44_V);

		// "matrix_o_45_V"
		char* tvin_matrix_o_45_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_45_V);
		char* tvout_matrix_o_45_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_45_V);
		char* wrapc_stream_size_out_matrix_o_45_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_45_V);
		char* wrapc_stream_egress_status_matrix_o_45_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_45_V);

		// "matrix_o_46_V"
		char* tvin_matrix_o_46_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_46_V);
		char* tvout_matrix_o_46_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_46_V);
		char* wrapc_stream_size_out_matrix_o_46_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_46_V);
		char* wrapc_stream_egress_status_matrix_o_46_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_46_V);

		// "matrix_o_47_V"
		char* tvin_matrix_o_47_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_47_V);
		char* tvout_matrix_o_47_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_47_V);
		char* wrapc_stream_size_out_matrix_o_47_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_47_V);
		char* wrapc_stream_egress_status_matrix_o_47_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_47_V);

		// "matrix_o_48_V"
		char* tvin_matrix_o_48_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_48_V);
		char* tvout_matrix_o_48_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_48_V);
		char* wrapc_stream_size_out_matrix_o_48_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_48_V);
		char* wrapc_stream_egress_status_matrix_o_48_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_48_V);

		// "matrix_o_49_V"
		char* tvin_matrix_o_49_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_49_V);
		char* tvout_matrix_o_49_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_49_V);
		char* wrapc_stream_size_out_matrix_o_49_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_49_V);
		char* wrapc_stream_egress_status_matrix_o_49_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_49_V);

		// "matrix_o_50_V"
		char* tvin_matrix_o_50_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_50_V);
		char* tvout_matrix_o_50_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_50_V);
		char* wrapc_stream_size_out_matrix_o_50_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_50_V);
		char* wrapc_stream_egress_status_matrix_o_50_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_50_V);

		// "matrix_o_51_V"
		char* tvin_matrix_o_51_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_51_V);
		char* tvout_matrix_o_51_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_51_V);
		char* wrapc_stream_size_out_matrix_o_51_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_51_V);
		char* wrapc_stream_egress_status_matrix_o_51_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_51_V);

		// "matrix_o_52_V"
		char* tvin_matrix_o_52_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_52_V);
		char* tvout_matrix_o_52_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_52_V);
		char* wrapc_stream_size_out_matrix_o_52_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_52_V);
		char* wrapc_stream_egress_status_matrix_o_52_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_52_V);

		// "matrix_o_53_V"
		char* tvin_matrix_o_53_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_53_V);
		char* tvout_matrix_o_53_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_53_V);
		char* wrapc_stream_size_out_matrix_o_53_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_53_V);
		char* wrapc_stream_egress_status_matrix_o_53_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_53_V);

		// "matrix_o_54_V"
		char* tvin_matrix_o_54_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_54_V);
		char* tvout_matrix_o_54_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_54_V);
		char* wrapc_stream_size_out_matrix_o_54_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_54_V);
		char* wrapc_stream_egress_status_matrix_o_54_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_54_V);

		// "matrix_o_55_V"
		char* tvin_matrix_o_55_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_55_V);
		char* tvout_matrix_o_55_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_55_V);
		char* wrapc_stream_size_out_matrix_o_55_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_55_V);
		char* wrapc_stream_egress_status_matrix_o_55_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_55_V);

		// "matrix_o_56_V"
		char* tvin_matrix_o_56_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_56_V);
		char* tvout_matrix_o_56_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_56_V);
		char* wrapc_stream_size_out_matrix_o_56_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_56_V);
		char* wrapc_stream_egress_status_matrix_o_56_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_56_V);

		// "matrix_o_57_V"
		char* tvin_matrix_o_57_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_57_V);
		char* tvout_matrix_o_57_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_57_V);
		char* wrapc_stream_size_out_matrix_o_57_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_57_V);
		char* wrapc_stream_egress_status_matrix_o_57_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_57_V);

		// "matrix_o_58_V"
		char* tvin_matrix_o_58_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_58_V);
		char* tvout_matrix_o_58_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_58_V);
		char* wrapc_stream_size_out_matrix_o_58_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_58_V);
		char* wrapc_stream_egress_status_matrix_o_58_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_58_V);

		// "matrix_o_59_V"
		char* tvin_matrix_o_59_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_59_V);
		char* tvout_matrix_o_59_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_59_V);
		char* wrapc_stream_size_out_matrix_o_59_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_59_V);
		char* wrapc_stream_egress_status_matrix_o_59_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_59_V);

		// "matrix_o_60_V"
		char* tvin_matrix_o_60_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_60_V);
		char* tvout_matrix_o_60_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_60_V);
		char* wrapc_stream_size_out_matrix_o_60_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_60_V);
		char* wrapc_stream_egress_status_matrix_o_60_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_60_V);

		// "matrix_o_61_V"
		char* tvin_matrix_o_61_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_61_V);
		char* tvout_matrix_o_61_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_61_V);
		char* wrapc_stream_size_out_matrix_o_61_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_61_V);
		char* wrapc_stream_egress_status_matrix_o_61_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_61_V);

		// "matrix_o_62_V"
		char* tvin_matrix_o_62_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_62_V);
		char* tvout_matrix_o_62_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_62_V);
		char* wrapc_stream_size_out_matrix_o_62_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_62_V);
		char* wrapc_stream_egress_status_matrix_o_62_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_62_V);

		// "matrix_o_63_V"
		char* tvin_matrix_o_63_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_63_V);
		char* tvout_matrix_o_63_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_63_V);
		char* wrapc_stream_size_out_matrix_o_63_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_63_V);
		char* wrapc_stream_egress_status_matrix_o_63_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_63_V);

		// "matrix_o_64_V"
		char* tvin_matrix_o_64_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_64_V);
		char* tvout_matrix_o_64_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_64_V);
		char* wrapc_stream_size_out_matrix_o_64_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_64_V);
		char* wrapc_stream_egress_status_matrix_o_64_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_64_V);

		// "matrix_o_65_V"
		char* tvin_matrix_o_65_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_65_V);
		char* tvout_matrix_o_65_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_65_V);
		char* wrapc_stream_size_out_matrix_o_65_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_65_V);
		char* wrapc_stream_egress_status_matrix_o_65_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_65_V);

		// "matrix_o_66_V"
		char* tvin_matrix_o_66_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_66_V);
		char* tvout_matrix_o_66_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_66_V);
		char* wrapc_stream_size_out_matrix_o_66_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_66_V);
		char* wrapc_stream_egress_status_matrix_o_66_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_66_V);

		// "matrix_o_67_V"
		char* tvin_matrix_o_67_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_67_V);
		char* tvout_matrix_o_67_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_67_V);
		char* wrapc_stream_size_out_matrix_o_67_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_67_V);
		char* wrapc_stream_egress_status_matrix_o_67_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_67_V);

		// "matrix_o_68_V"
		char* tvin_matrix_o_68_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_68_V);
		char* tvout_matrix_o_68_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_68_V);
		char* wrapc_stream_size_out_matrix_o_68_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_68_V);
		char* wrapc_stream_egress_status_matrix_o_68_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_68_V);

		// "matrix_o_69_V"
		char* tvin_matrix_o_69_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_69_V);
		char* tvout_matrix_o_69_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_69_V);
		char* wrapc_stream_size_out_matrix_o_69_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_69_V);
		char* wrapc_stream_egress_status_matrix_o_69_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_69_V);

		// "matrix_o_70_V"
		char* tvin_matrix_o_70_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_70_V);
		char* tvout_matrix_o_70_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_70_V);
		char* wrapc_stream_size_out_matrix_o_70_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_70_V);
		char* wrapc_stream_egress_status_matrix_o_70_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_70_V);

		// "matrix_o_71_V"
		char* tvin_matrix_o_71_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_71_V);
		char* tvout_matrix_o_71_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_71_V);
		char* wrapc_stream_size_out_matrix_o_71_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_71_V);
		char* wrapc_stream_egress_status_matrix_o_71_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_71_V);

		// "matrix_o_72_V"
		char* tvin_matrix_o_72_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_72_V);
		char* tvout_matrix_o_72_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_72_V);
		char* wrapc_stream_size_out_matrix_o_72_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_72_V);
		char* wrapc_stream_egress_status_matrix_o_72_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_72_V);

		// "matrix_o_73_V"
		char* tvin_matrix_o_73_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_73_V);
		char* tvout_matrix_o_73_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_73_V);
		char* wrapc_stream_size_out_matrix_o_73_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_73_V);
		char* wrapc_stream_egress_status_matrix_o_73_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_73_V);

		// "matrix_o_74_V"
		char* tvin_matrix_o_74_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_74_V);
		char* tvout_matrix_o_74_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_74_V);
		char* wrapc_stream_size_out_matrix_o_74_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_74_V);
		char* wrapc_stream_egress_status_matrix_o_74_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_74_V);

		// "matrix_o_75_V"
		char* tvin_matrix_o_75_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_75_V);
		char* tvout_matrix_o_75_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_75_V);
		char* wrapc_stream_size_out_matrix_o_75_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_75_V);
		char* wrapc_stream_egress_status_matrix_o_75_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_75_V);

		// "matrix_o_76_V"
		char* tvin_matrix_o_76_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_76_V);
		char* tvout_matrix_o_76_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_76_V);
		char* wrapc_stream_size_out_matrix_o_76_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_76_V);
		char* wrapc_stream_egress_status_matrix_o_76_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_76_V);

		// "matrix_o_77_V"
		char* tvin_matrix_o_77_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_77_V);
		char* tvout_matrix_o_77_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_77_V);
		char* wrapc_stream_size_out_matrix_o_77_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_77_V);
		char* wrapc_stream_egress_status_matrix_o_77_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_77_V);

		// "matrix_o_78_V"
		char* tvin_matrix_o_78_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_78_V);
		char* tvout_matrix_o_78_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_78_V);
		char* wrapc_stream_size_out_matrix_o_78_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_78_V);
		char* wrapc_stream_egress_status_matrix_o_78_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_78_V);

		// "matrix_o_79_V"
		char* tvin_matrix_o_79_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_79_V);
		char* tvout_matrix_o_79_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_79_V);
		char* wrapc_stream_size_out_matrix_o_79_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_79_V);
		char* wrapc_stream_egress_status_matrix_o_79_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_79_V);

		// "matrix_o_80_V"
		char* tvin_matrix_o_80_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_80_V);
		char* tvout_matrix_o_80_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_80_V);
		char* wrapc_stream_size_out_matrix_o_80_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_80_V);
		char* wrapc_stream_egress_status_matrix_o_80_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_80_V);

		// "matrix_o_81_V"
		char* tvin_matrix_o_81_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_81_V);
		char* tvout_matrix_o_81_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_81_V);
		char* wrapc_stream_size_out_matrix_o_81_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_81_V);
		char* wrapc_stream_egress_status_matrix_o_81_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_81_V);

		// "matrix_o_82_V"
		char* tvin_matrix_o_82_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_82_V);
		char* tvout_matrix_o_82_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_82_V);
		char* wrapc_stream_size_out_matrix_o_82_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_82_V);
		char* wrapc_stream_egress_status_matrix_o_82_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_82_V);

		// "matrix_o_83_V"
		char* tvin_matrix_o_83_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_83_V);
		char* tvout_matrix_o_83_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_83_V);
		char* wrapc_stream_size_out_matrix_o_83_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_83_V);
		char* wrapc_stream_egress_status_matrix_o_83_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_83_V);

		// "matrix_o_84_V"
		char* tvin_matrix_o_84_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_84_V);
		char* tvout_matrix_o_84_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_84_V);
		char* wrapc_stream_size_out_matrix_o_84_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_84_V);
		char* wrapc_stream_egress_status_matrix_o_84_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_84_V);

		// "matrix_o_85_V"
		char* tvin_matrix_o_85_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_85_V);
		char* tvout_matrix_o_85_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_85_V);
		char* wrapc_stream_size_out_matrix_o_85_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_85_V);
		char* wrapc_stream_egress_status_matrix_o_85_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_85_V);

		// "matrix_o_86_V"
		char* tvin_matrix_o_86_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_86_V);
		char* tvout_matrix_o_86_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_86_V);
		char* wrapc_stream_size_out_matrix_o_86_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_86_V);
		char* wrapc_stream_egress_status_matrix_o_86_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_86_V);

		// "matrix_o_87_V"
		char* tvin_matrix_o_87_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_87_V);
		char* tvout_matrix_o_87_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_87_V);
		char* wrapc_stream_size_out_matrix_o_87_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_87_V);
		char* wrapc_stream_egress_status_matrix_o_87_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_87_V);

		// "matrix_o_88_V"
		char* tvin_matrix_o_88_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_88_V);
		char* tvout_matrix_o_88_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_88_V);
		char* wrapc_stream_size_out_matrix_o_88_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_88_V);
		char* wrapc_stream_egress_status_matrix_o_88_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_88_V);

		// "matrix_o_89_V"
		char* tvin_matrix_o_89_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_89_V);
		char* tvout_matrix_o_89_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_89_V);
		char* wrapc_stream_size_out_matrix_o_89_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_89_V);
		char* wrapc_stream_egress_status_matrix_o_89_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_89_V);

		// "matrix_o_90_V"
		char* tvin_matrix_o_90_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_90_V);
		char* tvout_matrix_o_90_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_90_V);
		char* wrapc_stream_size_out_matrix_o_90_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_90_V);
		char* wrapc_stream_egress_status_matrix_o_90_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_90_V);

		// "matrix_o_91_V"
		char* tvin_matrix_o_91_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_91_V);
		char* tvout_matrix_o_91_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_91_V);
		char* wrapc_stream_size_out_matrix_o_91_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_91_V);
		char* wrapc_stream_egress_status_matrix_o_91_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_91_V);

		// "matrix_o_92_V"
		char* tvin_matrix_o_92_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_92_V);
		char* tvout_matrix_o_92_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_92_V);
		char* wrapc_stream_size_out_matrix_o_92_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_92_V);
		char* wrapc_stream_egress_status_matrix_o_92_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_92_V);

		// "matrix_o_93_V"
		char* tvin_matrix_o_93_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_93_V);
		char* tvout_matrix_o_93_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_93_V);
		char* wrapc_stream_size_out_matrix_o_93_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_93_V);
		char* wrapc_stream_egress_status_matrix_o_93_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_93_V);

		// "matrix_o_94_V"
		char* tvin_matrix_o_94_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_94_V);
		char* tvout_matrix_o_94_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_94_V);
		char* wrapc_stream_size_out_matrix_o_94_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_94_V);
		char* wrapc_stream_egress_status_matrix_o_94_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_94_V);

		// "matrix_o_95_V"
		char* tvin_matrix_o_95_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_95_V);
		char* tvout_matrix_o_95_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_95_V);
		char* wrapc_stream_size_out_matrix_o_95_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_95_V);
		char* wrapc_stream_egress_status_matrix_o_95_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_95_V);

		// "matrix_o_96_V"
		char* tvin_matrix_o_96_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_96_V);
		char* tvout_matrix_o_96_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_96_V);
		char* wrapc_stream_size_out_matrix_o_96_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_96_V);
		char* wrapc_stream_egress_status_matrix_o_96_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_96_V);

		// "matrix_o_97_V"
		char* tvin_matrix_o_97_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_97_V);
		char* tvout_matrix_o_97_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_97_V);
		char* wrapc_stream_size_out_matrix_o_97_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_97_V);
		char* wrapc_stream_egress_status_matrix_o_97_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_97_V);

		// "matrix_o_98_V"
		char* tvin_matrix_o_98_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_98_V);
		char* tvout_matrix_o_98_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_98_V);
		char* wrapc_stream_size_out_matrix_o_98_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_98_V);
		char* wrapc_stream_egress_status_matrix_o_98_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_98_V);

		// "matrix_o_99_V"
		char* tvin_matrix_o_99_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_99_V);
		char* tvout_matrix_o_99_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_99_V);
		char* wrapc_stream_size_out_matrix_o_99_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_99_V);
		char* wrapc_stream_egress_status_matrix_o_99_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_99_V);

		// "matrix_o_100_V"
		char* tvin_matrix_o_100_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_100_V);
		char* tvout_matrix_o_100_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_100_V);
		char* wrapc_stream_size_out_matrix_o_100_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_100_V);
		char* wrapc_stream_egress_status_matrix_o_100_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_100_V);

		// "matrix_o_101_V"
		char* tvin_matrix_o_101_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_101_V);
		char* tvout_matrix_o_101_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_101_V);
		char* wrapc_stream_size_out_matrix_o_101_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_101_V);
		char* wrapc_stream_egress_status_matrix_o_101_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_101_V);

		// "matrix_o_102_V"
		char* tvin_matrix_o_102_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_102_V);
		char* tvout_matrix_o_102_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_102_V);
		char* wrapc_stream_size_out_matrix_o_102_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_102_V);
		char* wrapc_stream_egress_status_matrix_o_102_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_102_V);

		// "matrix_o_103_V"
		char* tvin_matrix_o_103_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_103_V);
		char* tvout_matrix_o_103_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_103_V);
		char* wrapc_stream_size_out_matrix_o_103_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_103_V);
		char* wrapc_stream_egress_status_matrix_o_103_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_103_V);

		// "matrix_o_104_V"
		char* tvin_matrix_o_104_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_104_V);
		char* tvout_matrix_o_104_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_104_V);
		char* wrapc_stream_size_out_matrix_o_104_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_104_V);
		char* wrapc_stream_egress_status_matrix_o_104_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_104_V);

		// "matrix_o_105_V"
		char* tvin_matrix_o_105_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_105_V);
		char* tvout_matrix_o_105_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_105_V);
		char* wrapc_stream_size_out_matrix_o_105_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_105_V);
		char* wrapc_stream_egress_status_matrix_o_105_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_105_V);

		// "matrix_o_106_V"
		char* tvin_matrix_o_106_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_106_V);
		char* tvout_matrix_o_106_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_106_V);
		char* wrapc_stream_size_out_matrix_o_106_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_106_V);
		char* wrapc_stream_egress_status_matrix_o_106_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_106_V);

		// "matrix_o_107_V"
		char* tvin_matrix_o_107_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_107_V);
		char* tvout_matrix_o_107_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_107_V);
		char* wrapc_stream_size_out_matrix_o_107_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_107_V);
		char* wrapc_stream_egress_status_matrix_o_107_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_107_V);

		// "matrix_o_108_V"
		char* tvin_matrix_o_108_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_108_V);
		char* tvout_matrix_o_108_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_108_V);
		char* wrapc_stream_size_out_matrix_o_108_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_108_V);
		char* wrapc_stream_egress_status_matrix_o_108_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_108_V);

		// "matrix_o_109_V"
		char* tvin_matrix_o_109_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_109_V);
		char* tvout_matrix_o_109_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_109_V);
		char* wrapc_stream_size_out_matrix_o_109_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_109_V);
		char* wrapc_stream_egress_status_matrix_o_109_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_109_V);

		// "matrix_o_110_V"
		char* tvin_matrix_o_110_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_110_V);
		char* tvout_matrix_o_110_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_110_V);
		char* wrapc_stream_size_out_matrix_o_110_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_110_V);
		char* wrapc_stream_egress_status_matrix_o_110_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_110_V);

		// "matrix_o_111_V"
		char* tvin_matrix_o_111_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_111_V);
		char* tvout_matrix_o_111_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_111_V);
		char* wrapc_stream_size_out_matrix_o_111_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_111_V);
		char* wrapc_stream_egress_status_matrix_o_111_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_111_V);

		// "matrix_o_112_V"
		char* tvin_matrix_o_112_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_112_V);
		char* tvout_matrix_o_112_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_112_V);
		char* wrapc_stream_size_out_matrix_o_112_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_112_V);
		char* wrapc_stream_egress_status_matrix_o_112_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_112_V);

		// "matrix_o_113_V"
		char* tvin_matrix_o_113_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_113_V);
		char* tvout_matrix_o_113_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_113_V);
		char* wrapc_stream_size_out_matrix_o_113_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_113_V);
		char* wrapc_stream_egress_status_matrix_o_113_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_113_V);

		// "matrix_o_114_V"
		char* tvin_matrix_o_114_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_114_V);
		char* tvout_matrix_o_114_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_114_V);
		char* wrapc_stream_size_out_matrix_o_114_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_114_V);
		char* wrapc_stream_egress_status_matrix_o_114_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_114_V);

		// "matrix_o_115_V"
		char* tvin_matrix_o_115_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_115_V);
		char* tvout_matrix_o_115_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_115_V);
		char* wrapc_stream_size_out_matrix_o_115_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_115_V);
		char* wrapc_stream_egress_status_matrix_o_115_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_115_V);

		// "matrix_o_116_V"
		char* tvin_matrix_o_116_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_116_V);
		char* tvout_matrix_o_116_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_116_V);
		char* wrapc_stream_size_out_matrix_o_116_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_116_V);
		char* wrapc_stream_egress_status_matrix_o_116_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_116_V);

		// "matrix_o_117_V"
		char* tvin_matrix_o_117_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_117_V);
		char* tvout_matrix_o_117_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_117_V);
		char* wrapc_stream_size_out_matrix_o_117_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_117_V);
		char* wrapc_stream_egress_status_matrix_o_117_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_117_V);

		// "matrix_o_118_V"
		char* tvin_matrix_o_118_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_118_V);
		char* tvout_matrix_o_118_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_118_V);
		char* wrapc_stream_size_out_matrix_o_118_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_118_V);
		char* wrapc_stream_egress_status_matrix_o_118_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_118_V);

		// "matrix_o_119_V"
		char* tvin_matrix_o_119_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_119_V);
		char* tvout_matrix_o_119_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_119_V);
		char* wrapc_stream_size_out_matrix_o_119_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_119_V);
		char* wrapc_stream_egress_status_matrix_o_119_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_119_V);

		// "matrix_o_120_V"
		char* tvin_matrix_o_120_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_120_V);
		char* tvout_matrix_o_120_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_120_V);
		char* wrapc_stream_size_out_matrix_o_120_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_120_V);
		char* wrapc_stream_egress_status_matrix_o_120_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_120_V);

		// "matrix_o_121_V"
		char* tvin_matrix_o_121_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_121_V);
		char* tvout_matrix_o_121_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_121_V);
		char* wrapc_stream_size_out_matrix_o_121_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_121_V);
		char* wrapc_stream_egress_status_matrix_o_121_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_121_V);

		// "matrix_o_122_V"
		char* tvin_matrix_o_122_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_122_V);
		char* tvout_matrix_o_122_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_122_V);
		char* wrapc_stream_size_out_matrix_o_122_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_122_V);
		char* wrapc_stream_egress_status_matrix_o_122_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_122_V);

		// "matrix_o_123_V"
		char* tvin_matrix_o_123_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_123_V);
		char* tvout_matrix_o_123_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_123_V);
		char* wrapc_stream_size_out_matrix_o_123_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_123_V);
		char* wrapc_stream_egress_status_matrix_o_123_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_123_V);

		// "matrix_o_124_V"
		char* tvin_matrix_o_124_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_124_V);
		char* tvout_matrix_o_124_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_124_V);
		char* wrapc_stream_size_out_matrix_o_124_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_124_V);
		char* wrapc_stream_egress_status_matrix_o_124_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_124_V);

		// "matrix_o_125_V"
		char* tvin_matrix_o_125_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_125_V);
		char* tvout_matrix_o_125_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_125_V);
		char* wrapc_stream_size_out_matrix_o_125_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_125_V);
		char* wrapc_stream_egress_status_matrix_o_125_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_125_V);

		// "matrix_o_126_V"
		char* tvin_matrix_o_126_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_126_V);
		char* tvout_matrix_o_126_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_126_V);
		char* wrapc_stream_size_out_matrix_o_126_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_126_V);
		char* wrapc_stream_egress_status_matrix_o_126_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_126_V);

		// "matrix_o_127_V"
		char* tvin_matrix_o_127_V = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_matrix_o_127_V);
		char* tvout_matrix_o_127_V = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_matrix_o_127_V);
		char* wrapc_stream_size_out_matrix_o_127_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_SIZE_OUT_matrix_o_127_V);
		char* wrapc_stream_egress_status_matrix_o_127_V = new char[50];
		aesl_fh.touch(WRAPC_STREAM_EGRESS_STATUS_matrix_o_127_V);

		static INTER_TCL_FILE tcl_file(INTER_TCL);
		int leading_zero;

		// dump stream tvin: "matrix_i[0]"
		std::vector<short > aesl_tmp_0;
		int aesl_tmp_1 = 0;
		while (!matrix_i[0].empty())
		{
			aesl_tmp_0.push_back(matrix_i[0].read());
			aesl_tmp_1++;
		}

		// dump stream tvin: "matrix_i[1]"
		std::vector<short > aesl_tmp_3;
		int aesl_tmp_4 = 0;
		while (!matrix_i[1].empty())
		{
			aesl_tmp_3.push_back(matrix_i[1].read());
			aesl_tmp_4++;
		}

		// dump stream tvin: "matrix_i[2]"
		std::vector<short > aesl_tmp_6;
		int aesl_tmp_7 = 0;
		while (!matrix_i[2].empty())
		{
			aesl_tmp_6.push_back(matrix_i[2].read());
			aesl_tmp_7++;
		}

		// dump stream tvin: "matrix_i[3]"
		std::vector<short > aesl_tmp_9;
		int aesl_tmp_10 = 0;
		while (!matrix_i[3].empty())
		{
			aesl_tmp_9.push_back(matrix_i[3].read());
			aesl_tmp_10++;
		}

		// dump stream tvin: "matrix_i[4]"
		std::vector<short > aesl_tmp_12;
		int aesl_tmp_13 = 0;
		while (!matrix_i[4].empty())
		{
			aesl_tmp_12.push_back(matrix_i[4].read());
			aesl_tmp_13++;
		}

		// dump stream tvin: "matrix_i[5]"
		std::vector<short > aesl_tmp_15;
		int aesl_tmp_16 = 0;
		while (!matrix_i[5].empty())
		{
			aesl_tmp_15.push_back(matrix_i[5].read());
			aesl_tmp_16++;
		}

		// dump stream tvin: "matrix_i[6]"
		std::vector<short > aesl_tmp_18;
		int aesl_tmp_19 = 0;
		while (!matrix_i[6].empty())
		{
			aesl_tmp_18.push_back(matrix_i[6].read());
			aesl_tmp_19++;
		}

		// dump stream tvin: "matrix_i[7]"
		std::vector<short > aesl_tmp_21;
		int aesl_tmp_22 = 0;
		while (!matrix_i[7].empty())
		{
			aesl_tmp_21.push_back(matrix_i[7].read());
			aesl_tmp_22++;
		}

		// dump stream tvin: "matrix_i[8]"
		std::vector<short > aesl_tmp_24;
		int aesl_tmp_25 = 0;
		while (!matrix_i[8].empty())
		{
			aesl_tmp_24.push_back(matrix_i[8].read());
			aesl_tmp_25++;
		}

		// dump stream tvin: "matrix_i[9]"
		std::vector<short > aesl_tmp_27;
		int aesl_tmp_28 = 0;
		while (!matrix_i[9].empty())
		{
			aesl_tmp_27.push_back(matrix_i[9].read());
			aesl_tmp_28++;
		}

		// dump stream tvin: "matrix_i[10]"
		std::vector<short > aesl_tmp_30;
		int aesl_tmp_31 = 0;
		while (!matrix_i[10].empty())
		{
			aesl_tmp_30.push_back(matrix_i[10].read());
			aesl_tmp_31++;
		}

		// dump stream tvin: "matrix_i[11]"
		std::vector<short > aesl_tmp_33;
		int aesl_tmp_34 = 0;
		while (!matrix_i[11].empty())
		{
			aesl_tmp_33.push_back(matrix_i[11].read());
			aesl_tmp_34++;
		}

		// dump stream tvin: "matrix_i[12]"
		std::vector<short > aesl_tmp_36;
		int aesl_tmp_37 = 0;
		while (!matrix_i[12].empty())
		{
			aesl_tmp_36.push_back(matrix_i[12].read());
			aesl_tmp_37++;
		}

		// dump stream tvin: "matrix_i[13]"
		std::vector<short > aesl_tmp_39;
		int aesl_tmp_40 = 0;
		while (!matrix_i[13].empty())
		{
			aesl_tmp_39.push_back(matrix_i[13].read());
			aesl_tmp_40++;
		}

		// dump stream tvin: "matrix_i[14]"
		std::vector<short > aesl_tmp_42;
		int aesl_tmp_43 = 0;
		while (!matrix_i[14].empty())
		{
			aesl_tmp_42.push_back(matrix_i[14].read());
			aesl_tmp_43++;
		}

		// dump stream tvin: "matrix_i[15]"
		std::vector<short > aesl_tmp_45;
		int aesl_tmp_46 = 0;
		while (!matrix_i[15].empty())
		{
			aesl_tmp_45.push_back(matrix_i[15].read());
			aesl_tmp_46++;
		}

		// dump stream tvin: "matrix_i[16]"
		std::vector<short > aesl_tmp_48;
		int aesl_tmp_49 = 0;
		while (!matrix_i[16].empty())
		{
			aesl_tmp_48.push_back(matrix_i[16].read());
			aesl_tmp_49++;
		}

		// dump stream tvin: "matrix_i[17]"
		std::vector<short > aesl_tmp_51;
		int aesl_tmp_52 = 0;
		while (!matrix_i[17].empty())
		{
			aesl_tmp_51.push_back(matrix_i[17].read());
			aesl_tmp_52++;
		}

		// dump stream tvin: "matrix_i[18]"
		std::vector<short > aesl_tmp_54;
		int aesl_tmp_55 = 0;
		while (!matrix_i[18].empty())
		{
			aesl_tmp_54.push_back(matrix_i[18].read());
			aesl_tmp_55++;
		}

		// dump stream tvin: "matrix_i[19]"
		std::vector<short > aesl_tmp_57;
		int aesl_tmp_58 = 0;
		while (!matrix_i[19].empty())
		{
			aesl_tmp_57.push_back(matrix_i[19].read());
			aesl_tmp_58++;
		}

		// dump stream tvin: "matrix_i[20]"
		std::vector<short > aesl_tmp_60;
		int aesl_tmp_61 = 0;
		while (!matrix_i[20].empty())
		{
			aesl_tmp_60.push_back(matrix_i[20].read());
			aesl_tmp_61++;
		}

		// dump stream tvin: "matrix_i[21]"
		std::vector<short > aesl_tmp_63;
		int aesl_tmp_64 = 0;
		while (!matrix_i[21].empty())
		{
			aesl_tmp_63.push_back(matrix_i[21].read());
			aesl_tmp_64++;
		}

		// dump stream tvin: "matrix_i[22]"
		std::vector<short > aesl_tmp_66;
		int aesl_tmp_67 = 0;
		while (!matrix_i[22].empty())
		{
			aesl_tmp_66.push_back(matrix_i[22].read());
			aesl_tmp_67++;
		}

		// dump stream tvin: "matrix_i[23]"
		std::vector<short > aesl_tmp_69;
		int aesl_tmp_70 = 0;
		while (!matrix_i[23].empty())
		{
			aesl_tmp_69.push_back(matrix_i[23].read());
			aesl_tmp_70++;
		}

		// dump stream tvin: "matrix_i[24]"
		std::vector<short > aesl_tmp_72;
		int aesl_tmp_73 = 0;
		while (!matrix_i[24].empty())
		{
			aesl_tmp_72.push_back(matrix_i[24].read());
			aesl_tmp_73++;
		}

		// dump stream tvin: "matrix_i[25]"
		std::vector<short > aesl_tmp_75;
		int aesl_tmp_76 = 0;
		while (!matrix_i[25].empty())
		{
			aesl_tmp_75.push_back(matrix_i[25].read());
			aesl_tmp_76++;
		}

		// dump stream tvin: "matrix_i[26]"
		std::vector<short > aesl_tmp_78;
		int aesl_tmp_79 = 0;
		while (!matrix_i[26].empty())
		{
			aesl_tmp_78.push_back(matrix_i[26].read());
			aesl_tmp_79++;
		}

		// dump stream tvin: "matrix_i[27]"
		std::vector<short > aesl_tmp_81;
		int aesl_tmp_82 = 0;
		while (!matrix_i[27].empty())
		{
			aesl_tmp_81.push_back(matrix_i[27].read());
			aesl_tmp_82++;
		}

		// dump stream tvin: "matrix_i[28]"
		std::vector<short > aesl_tmp_84;
		int aesl_tmp_85 = 0;
		while (!matrix_i[28].empty())
		{
			aesl_tmp_84.push_back(matrix_i[28].read());
			aesl_tmp_85++;
		}

		// dump stream tvin: "matrix_i[29]"
		std::vector<short > aesl_tmp_87;
		int aesl_tmp_88 = 0;
		while (!matrix_i[29].empty())
		{
			aesl_tmp_87.push_back(matrix_i[29].read());
			aesl_tmp_88++;
		}

		// dump stream tvin: "matrix_i[30]"
		std::vector<short > aesl_tmp_90;
		int aesl_tmp_91 = 0;
		while (!matrix_i[30].empty())
		{
			aesl_tmp_90.push_back(matrix_i[30].read());
			aesl_tmp_91++;
		}

		// dump stream tvin: "matrix_i[31]"
		std::vector<short > aesl_tmp_93;
		int aesl_tmp_94 = 0;
		while (!matrix_i[31].empty())
		{
			aesl_tmp_93.push_back(matrix_i[31].read());
			aesl_tmp_94++;
		}

		// dump stream tvin: "matrix_i[32]"
		std::vector<short > aesl_tmp_96;
		int aesl_tmp_97 = 0;
		while (!matrix_i[32].empty())
		{
			aesl_tmp_96.push_back(matrix_i[32].read());
			aesl_tmp_97++;
		}

		// dump stream tvin: "matrix_i[33]"
		std::vector<short > aesl_tmp_99;
		int aesl_tmp_100 = 0;
		while (!matrix_i[33].empty())
		{
			aesl_tmp_99.push_back(matrix_i[33].read());
			aesl_tmp_100++;
		}

		// dump stream tvin: "matrix_i[34]"
		std::vector<short > aesl_tmp_102;
		int aesl_tmp_103 = 0;
		while (!matrix_i[34].empty())
		{
			aesl_tmp_102.push_back(matrix_i[34].read());
			aesl_tmp_103++;
		}

		// dump stream tvin: "matrix_i[35]"
		std::vector<short > aesl_tmp_105;
		int aesl_tmp_106 = 0;
		while (!matrix_i[35].empty())
		{
			aesl_tmp_105.push_back(matrix_i[35].read());
			aesl_tmp_106++;
		}

		// dump stream tvin: "matrix_i[36]"
		std::vector<short > aesl_tmp_108;
		int aesl_tmp_109 = 0;
		while (!matrix_i[36].empty())
		{
			aesl_tmp_108.push_back(matrix_i[36].read());
			aesl_tmp_109++;
		}

		// dump stream tvin: "matrix_i[37]"
		std::vector<short > aesl_tmp_111;
		int aesl_tmp_112 = 0;
		while (!matrix_i[37].empty())
		{
			aesl_tmp_111.push_back(matrix_i[37].read());
			aesl_tmp_112++;
		}

		// dump stream tvin: "matrix_i[38]"
		std::vector<short > aesl_tmp_114;
		int aesl_tmp_115 = 0;
		while (!matrix_i[38].empty())
		{
			aesl_tmp_114.push_back(matrix_i[38].read());
			aesl_tmp_115++;
		}

		// dump stream tvin: "matrix_i[39]"
		std::vector<short > aesl_tmp_117;
		int aesl_tmp_118 = 0;
		while (!matrix_i[39].empty())
		{
			aesl_tmp_117.push_back(matrix_i[39].read());
			aesl_tmp_118++;
		}

		// dump stream tvin: "matrix_i[40]"
		std::vector<short > aesl_tmp_120;
		int aesl_tmp_121 = 0;
		while (!matrix_i[40].empty())
		{
			aesl_tmp_120.push_back(matrix_i[40].read());
			aesl_tmp_121++;
		}

		// dump stream tvin: "matrix_i[41]"
		std::vector<short > aesl_tmp_123;
		int aesl_tmp_124 = 0;
		while (!matrix_i[41].empty())
		{
			aesl_tmp_123.push_back(matrix_i[41].read());
			aesl_tmp_124++;
		}

		// dump stream tvin: "matrix_i[42]"
		std::vector<short > aesl_tmp_126;
		int aesl_tmp_127 = 0;
		while (!matrix_i[42].empty())
		{
			aesl_tmp_126.push_back(matrix_i[42].read());
			aesl_tmp_127++;
		}

		// dump stream tvin: "matrix_i[43]"
		std::vector<short > aesl_tmp_129;
		int aesl_tmp_130 = 0;
		while (!matrix_i[43].empty())
		{
			aesl_tmp_129.push_back(matrix_i[43].read());
			aesl_tmp_130++;
		}

		// dump stream tvin: "matrix_i[44]"
		std::vector<short > aesl_tmp_132;
		int aesl_tmp_133 = 0;
		while (!matrix_i[44].empty())
		{
			aesl_tmp_132.push_back(matrix_i[44].read());
			aesl_tmp_133++;
		}

		// dump stream tvin: "matrix_i[45]"
		std::vector<short > aesl_tmp_135;
		int aesl_tmp_136 = 0;
		while (!matrix_i[45].empty())
		{
			aesl_tmp_135.push_back(matrix_i[45].read());
			aesl_tmp_136++;
		}

		// dump stream tvin: "matrix_i[46]"
		std::vector<short > aesl_tmp_138;
		int aesl_tmp_139 = 0;
		while (!matrix_i[46].empty())
		{
			aesl_tmp_138.push_back(matrix_i[46].read());
			aesl_tmp_139++;
		}

		// dump stream tvin: "matrix_i[47]"
		std::vector<short > aesl_tmp_141;
		int aesl_tmp_142 = 0;
		while (!matrix_i[47].empty())
		{
			aesl_tmp_141.push_back(matrix_i[47].read());
			aesl_tmp_142++;
		}

		// dump stream tvin: "matrix_i[48]"
		std::vector<short > aesl_tmp_144;
		int aesl_tmp_145 = 0;
		while (!matrix_i[48].empty())
		{
			aesl_tmp_144.push_back(matrix_i[48].read());
			aesl_tmp_145++;
		}

		// dump stream tvin: "matrix_i[49]"
		std::vector<short > aesl_tmp_147;
		int aesl_tmp_148 = 0;
		while (!matrix_i[49].empty())
		{
			aesl_tmp_147.push_back(matrix_i[49].read());
			aesl_tmp_148++;
		}

		// dump stream tvin: "matrix_i[50]"
		std::vector<short > aesl_tmp_150;
		int aesl_tmp_151 = 0;
		while (!matrix_i[50].empty())
		{
			aesl_tmp_150.push_back(matrix_i[50].read());
			aesl_tmp_151++;
		}

		// dump stream tvin: "matrix_i[51]"
		std::vector<short > aesl_tmp_153;
		int aesl_tmp_154 = 0;
		while (!matrix_i[51].empty())
		{
			aesl_tmp_153.push_back(matrix_i[51].read());
			aesl_tmp_154++;
		}

		// dump stream tvin: "matrix_i[52]"
		std::vector<short > aesl_tmp_156;
		int aesl_tmp_157 = 0;
		while (!matrix_i[52].empty())
		{
			aesl_tmp_156.push_back(matrix_i[52].read());
			aesl_tmp_157++;
		}

		// dump stream tvin: "matrix_i[53]"
		std::vector<short > aesl_tmp_159;
		int aesl_tmp_160 = 0;
		while (!matrix_i[53].empty())
		{
			aesl_tmp_159.push_back(matrix_i[53].read());
			aesl_tmp_160++;
		}

		// dump stream tvin: "matrix_i[54]"
		std::vector<short > aesl_tmp_162;
		int aesl_tmp_163 = 0;
		while (!matrix_i[54].empty())
		{
			aesl_tmp_162.push_back(matrix_i[54].read());
			aesl_tmp_163++;
		}

		// dump stream tvin: "matrix_i[55]"
		std::vector<short > aesl_tmp_165;
		int aesl_tmp_166 = 0;
		while (!matrix_i[55].empty())
		{
			aesl_tmp_165.push_back(matrix_i[55].read());
			aesl_tmp_166++;
		}

		// dump stream tvin: "matrix_i[56]"
		std::vector<short > aesl_tmp_168;
		int aesl_tmp_169 = 0;
		while (!matrix_i[56].empty())
		{
			aesl_tmp_168.push_back(matrix_i[56].read());
			aesl_tmp_169++;
		}

		// dump stream tvin: "matrix_i[57]"
		std::vector<short > aesl_tmp_171;
		int aesl_tmp_172 = 0;
		while (!matrix_i[57].empty())
		{
			aesl_tmp_171.push_back(matrix_i[57].read());
			aesl_tmp_172++;
		}

		// dump stream tvin: "matrix_i[58]"
		std::vector<short > aesl_tmp_174;
		int aesl_tmp_175 = 0;
		while (!matrix_i[58].empty())
		{
			aesl_tmp_174.push_back(matrix_i[58].read());
			aesl_tmp_175++;
		}

		// dump stream tvin: "matrix_i[59]"
		std::vector<short > aesl_tmp_177;
		int aesl_tmp_178 = 0;
		while (!matrix_i[59].empty())
		{
			aesl_tmp_177.push_back(matrix_i[59].read());
			aesl_tmp_178++;
		}

		// dump stream tvin: "matrix_i[60]"
		std::vector<short > aesl_tmp_180;
		int aesl_tmp_181 = 0;
		while (!matrix_i[60].empty())
		{
			aesl_tmp_180.push_back(matrix_i[60].read());
			aesl_tmp_181++;
		}

		// dump stream tvin: "matrix_i[61]"
		std::vector<short > aesl_tmp_183;
		int aesl_tmp_184 = 0;
		while (!matrix_i[61].empty())
		{
			aesl_tmp_183.push_back(matrix_i[61].read());
			aesl_tmp_184++;
		}

		// dump stream tvin: "matrix_i[62]"
		std::vector<short > aesl_tmp_186;
		int aesl_tmp_187 = 0;
		while (!matrix_i[62].empty())
		{
			aesl_tmp_186.push_back(matrix_i[62].read());
			aesl_tmp_187++;
		}

		// dump stream tvin: "matrix_i[63]"
		std::vector<short > aesl_tmp_189;
		int aesl_tmp_190 = 0;
		while (!matrix_i[63].empty())
		{
			aesl_tmp_189.push_back(matrix_i[63].read());
			aesl_tmp_190++;
		}

		// dump stream tvin: "matrix_i[64]"
		std::vector<short > aesl_tmp_192;
		int aesl_tmp_193 = 0;
		while (!matrix_i[64].empty())
		{
			aesl_tmp_192.push_back(matrix_i[64].read());
			aesl_tmp_193++;
		}

		// dump stream tvin: "matrix_i[65]"
		std::vector<short > aesl_tmp_195;
		int aesl_tmp_196 = 0;
		while (!matrix_i[65].empty())
		{
			aesl_tmp_195.push_back(matrix_i[65].read());
			aesl_tmp_196++;
		}

		// dump stream tvin: "matrix_i[66]"
		std::vector<short > aesl_tmp_198;
		int aesl_tmp_199 = 0;
		while (!matrix_i[66].empty())
		{
			aesl_tmp_198.push_back(matrix_i[66].read());
			aesl_tmp_199++;
		}

		// dump stream tvin: "matrix_i[67]"
		std::vector<short > aesl_tmp_201;
		int aesl_tmp_202 = 0;
		while (!matrix_i[67].empty())
		{
			aesl_tmp_201.push_back(matrix_i[67].read());
			aesl_tmp_202++;
		}

		// dump stream tvin: "matrix_i[68]"
		std::vector<short > aesl_tmp_204;
		int aesl_tmp_205 = 0;
		while (!matrix_i[68].empty())
		{
			aesl_tmp_204.push_back(matrix_i[68].read());
			aesl_tmp_205++;
		}

		// dump stream tvin: "matrix_i[69]"
		std::vector<short > aesl_tmp_207;
		int aesl_tmp_208 = 0;
		while (!matrix_i[69].empty())
		{
			aesl_tmp_207.push_back(matrix_i[69].read());
			aesl_tmp_208++;
		}

		// dump stream tvin: "matrix_i[70]"
		std::vector<short > aesl_tmp_210;
		int aesl_tmp_211 = 0;
		while (!matrix_i[70].empty())
		{
			aesl_tmp_210.push_back(matrix_i[70].read());
			aesl_tmp_211++;
		}

		// dump stream tvin: "matrix_i[71]"
		std::vector<short > aesl_tmp_213;
		int aesl_tmp_214 = 0;
		while (!matrix_i[71].empty())
		{
			aesl_tmp_213.push_back(matrix_i[71].read());
			aesl_tmp_214++;
		}

		// dump stream tvin: "matrix_i[72]"
		std::vector<short > aesl_tmp_216;
		int aesl_tmp_217 = 0;
		while (!matrix_i[72].empty())
		{
			aesl_tmp_216.push_back(matrix_i[72].read());
			aesl_tmp_217++;
		}

		// dump stream tvin: "matrix_i[73]"
		std::vector<short > aesl_tmp_219;
		int aesl_tmp_220 = 0;
		while (!matrix_i[73].empty())
		{
			aesl_tmp_219.push_back(matrix_i[73].read());
			aesl_tmp_220++;
		}

		// dump stream tvin: "matrix_i[74]"
		std::vector<short > aesl_tmp_222;
		int aesl_tmp_223 = 0;
		while (!matrix_i[74].empty())
		{
			aesl_tmp_222.push_back(matrix_i[74].read());
			aesl_tmp_223++;
		}

		// dump stream tvin: "matrix_i[75]"
		std::vector<short > aesl_tmp_225;
		int aesl_tmp_226 = 0;
		while (!matrix_i[75].empty())
		{
			aesl_tmp_225.push_back(matrix_i[75].read());
			aesl_tmp_226++;
		}

		// dump stream tvin: "matrix_i[76]"
		std::vector<short > aesl_tmp_228;
		int aesl_tmp_229 = 0;
		while (!matrix_i[76].empty())
		{
			aesl_tmp_228.push_back(matrix_i[76].read());
			aesl_tmp_229++;
		}

		// dump stream tvin: "matrix_i[77]"
		std::vector<short > aesl_tmp_231;
		int aesl_tmp_232 = 0;
		while (!matrix_i[77].empty())
		{
			aesl_tmp_231.push_back(matrix_i[77].read());
			aesl_tmp_232++;
		}

		// dump stream tvin: "matrix_i[78]"
		std::vector<short > aesl_tmp_234;
		int aesl_tmp_235 = 0;
		while (!matrix_i[78].empty())
		{
			aesl_tmp_234.push_back(matrix_i[78].read());
			aesl_tmp_235++;
		}

		// dump stream tvin: "matrix_i[79]"
		std::vector<short > aesl_tmp_237;
		int aesl_tmp_238 = 0;
		while (!matrix_i[79].empty())
		{
			aesl_tmp_237.push_back(matrix_i[79].read());
			aesl_tmp_238++;
		}

		// dump stream tvin: "matrix_i[80]"
		std::vector<short > aesl_tmp_240;
		int aesl_tmp_241 = 0;
		while (!matrix_i[80].empty())
		{
			aesl_tmp_240.push_back(matrix_i[80].read());
			aesl_tmp_241++;
		}

		// dump stream tvin: "matrix_i[81]"
		std::vector<short > aesl_tmp_243;
		int aesl_tmp_244 = 0;
		while (!matrix_i[81].empty())
		{
			aesl_tmp_243.push_back(matrix_i[81].read());
			aesl_tmp_244++;
		}

		// dump stream tvin: "matrix_i[82]"
		std::vector<short > aesl_tmp_246;
		int aesl_tmp_247 = 0;
		while (!matrix_i[82].empty())
		{
			aesl_tmp_246.push_back(matrix_i[82].read());
			aesl_tmp_247++;
		}

		// dump stream tvin: "matrix_i[83]"
		std::vector<short > aesl_tmp_249;
		int aesl_tmp_250 = 0;
		while (!matrix_i[83].empty())
		{
			aesl_tmp_249.push_back(matrix_i[83].read());
			aesl_tmp_250++;
		}

		// dump stream tvin: "matrix_i[84]"
		std::vector<short > aesl_tmp_252;
		int aesl_tmp_253 = 0;
		while (!matrix_i[84].empty())
		{
			aesl_tmp_252.push_back(matrix_i[84].read());
			aesl_tmp_253++;
		}

		// dump stream tvin: "matrix_i[85]"
		std::vector<short > aesl_tmp_255;
		int aesl_tmp_256 = 0;
		while (!matrix_i[85].empty())
		{
			aesl_tmp_255.push_back(matrix_i[85].read());
			aesl_tmp_256++;
		}

		// dump stream tvin: "matrix_i[86]"
		std::vector<short > aesl_tmp_258;
		int aesl_tmp_259 = 0;
		while (!matrix_i[86].empty())
		{
			aesl_tmp_258.push_back(matrix_i[86].read());
			aesl_tmp_259++;
		}

		// dump stream tvin: "matrix_i[87]"
		std::vector<short > aesl_tmp_261;
		int aesl_tmp_262 = 0;
		while (!matrix_i[87].empty())
		{
			aesl_tmp_261.push_back(matrix_i[87].read());
			aesl_tmp_262++;
		}

		// dump stream tvin: "matrix_i[88]"
		std::vector<short > aesl_tmp_264;
		int aesl_tmp_265 = 0;
		while (!matrix_i[88].empty())
		{
			aesl_tmp_264.push_back(matrix_i[88].read());
			aesl_tmp_265++;
		}

		// dump stream tvin: "matrix_i[89]"
		std::vector<short > aesl_tmp_267;
		int aesl_tmp_268 = 0;
		while (!matrix_i[89].empty())
		{
			aesl_tmp_267.push_back(matrix_i[89].read());
			aesl_tmp_268++;
		}

		// dump stream tvin: "matrix_i[90]"
		std::vector<short > aesl_tmp_270;
		int aesl_tmp_271 = 0;
		while (!matrix_i[90].empty())
		{
			aesl_tmp_270.push_back(matrix_i[90].read());
			aesl_tmp_271++;
		}

		// dump stream tvin: "matrix_i[91]"
		std::vector<short > aesl_tmp_273;
		int aesl_tmp_274 = 0;
		while (!matrix_i[91].empty())
		{
			aesl_tmp_273.push_back(matrix_i[91].read());
			aesl_tmp_274++;
		}

		// dump stream tvin: "matrix_i[92]"
		std::vector<short > aesl_tmp_276;
		int aesl_tmp_277 = 0;
		while (!matrix_i[92].empty())
		{
			aesl_tmp_276.push_back(matrix_i[92].read());
			aesl_tmp_277++;
		}

		// dump stream tvin: "matrix_i[93]"
		std::vector<short > aesl_tmp_279;
		int aesl_tmp_280 = 0;
		while (!matrix_i[93].empty())
		{
			aesl_tmp_279.push_back(matrix_i[93].read());
			aesl_tmp_280++;
		}

		// dump stream tvin: "matrix_i[94]"
		std::vector<short > aesl_tmp_282;
		int aesl_tmp_283 = 0;
		while (!matrix_i[94].empty())
		{
			aesl_tmp_282.push_back(matrix_i[94].read());
			aesl_tmp_283++;
		}

		// dump stream tvin: "matrix_i[95]"
		std::vector<short > aesl_tmp_285;
		int aesl_tmp_286 = 0;
		while (!matrix_i[95].empty())
		{
			aesl_tmp_285.push_back(matrix_i[95].read());
			aesl_tmp_286++;
		}

		// dump stream tvin: "matrix_o[0]"
		std::vector<short > aesl_tmp_288;
		int aesl_tmp_289 = 0;
		while (!matrix_o[0].empty())
		{
			aesl_tmp_288.push_back(matrix_o[0].read());
			aesl_tmp_289++;
		}

		// dump stream tvin: "matrix_o[1]"
		std::vector<short > aesl_tmp_291;
		int aesl_tmp_292 = 0;
		while (!matrix_o[1].empty())
		{
			aesl_tmp_291.push_back(matrix_o[1].read());
			aesl_tmp_292++;
		}

		// dump stream tvin: "matrix_o[2]"
		std::vector<short > aesl_tmp_294;
		int aesl_tmp_295 = 0;
		while (!matrix_o[2].empty())
		{
			aesl_tmp_294.push_back(matrix_o[2].read());
			aesl_tmp_295++;
		}

		// dump stream tvin: "matrix_o[3]"
		std::vector<short > aesl_tmp_297;
		int aesl_tmp_298 = 0;
		while (!matrix_o[3].empty())
		{
			aesl_tmp_297.push_back(matrix_o[3].read());
			aesl_tmp_298++;
		}

		// dump stream tvin: "matrix_o[4]"
		std::vector<short > aesl_tmp_300;
		int aesl_tmp_301 = 0;
		while (!matrix_o[4].empty())
		{
			aesl_tmp_300.push_back(matrix_o[4].read());
			aesl_tmp_301++;
		}

		// dump stream tvin: "matrix_o[5]"
		std::vector<short > aesl_tmp_303;
		int aesl_tmp_304 = 0;
		while (!matrix_o[5].empty())
		{
			aesl_tmp_303.push_back(matrix_o[5].read());
			aesl_tmp_304++;
		}

		// dump stream tvin: "matrix_o[6]"
		std::vector<short > aesl_tmp_306;
		int aesl_tmp_307 = 0;
		while (!matrix_o[6].empty())
		{
			aesl_tmp_306.push_back(matrix_o[6].read());
			aesl_tmp_307++;
		}

		// dump stream tvin: "matrix_o[7]"
		std::vector<short > aesl_tmp_309;
		int aesl_tmp_310 = 0;
		while (!matrix_o[7].empty())
		{
			aesl_tmp_309.push_back(matrix_o[7].read());
			aesl_tmp_310++;
		}

		// dump stream tvin: "matrix_o[8]"
		std::vector<short > aesl_tmp_312;
		int aesl_tmp_313 = 0;
		while (!matrix_o[8].empty())
		{
			aesl_tmp_312.push_back(matrix_o[8].read());
			aesl_tmp_313++;
		}

		// dump stream tvin: "matrix_o[9]"
		std::vector<short > aesl_tmp_315;
		int aesl_tmp_316 = 0;
		while (!matrix_o[9].empty())
		{
			aesl_tmp_315.push_back(matrix_o[9].read());
			aesl_tmp_316++;
		}

		// dump stream tvin: "matrix_o[10]"
		std::vector<short > aesl_tmp_318;
		int aesl_tmp_319 = 0;
		while (!matrix_o[10].empty())
		{
			aesl_tmp_318.push_back(matrix_o[10].read());
			aesl_tmp_319++;
		}

		// dump stream tvin: "matrix_o[11]"
		std::vector<short > aesl_tmp_321;
		int aesl_tmp_322 = 0;
		while (!matrix_o[11].empty())
		{
			aesl_tmp_321.push_back(matrix_o[11].read());
			aesl_tmp_322++;
		}

		// dump stream tvin: "matrix_o[12]"
		std::vector<short > aesl_tmp_324;
		int aesl_tmp_325 = 0;
		while (!matrix_o[12].empty())
		{
			aesl_tmp_324.push_back(matrix_o[12].read());
			aesl_tmp_325++;
		}

		// dump stream tvin: "matrix_o[13]"
		std::vector<short > aesl_tmp_327;
		int aesl_tmp_328 = 0;
		while (!matrix_o[13].empty())
		{
			aesl_tmp_327.push_back(matrix_o[13].read());
			aesl_tmp_328++;
		}

		// dump stream tvin: "matrix_o[14]"
		std::vector<short > aesl_tmp_330;
		int aesl_tmp_331 = 0;
		while (!matrix_o[14].empty())
		{
			aesl_tmp_330.push_back(matrix_o[14].read());
			aesl_tmp_331++;
		}

		// dump stream tvin: "matrix_o[15]"
		std::vector<short > aesl_tmp_333;
		int aesl_tmp_334 = 0;
		while (!matrix_o[15].empty())
		{
			aesl_tmp_333.push_back(matrix_o[15].read());
			aesl_tmp_334++;
		}

		// dump stream tvin: "matrix_o[16]"
		std::vector<short > aesl_tmp_336;
		int aesl_tmp_337 = 0;
		while (!matrix_o[16].empty())
		{
			aesl_tmp_336.push_back(matrix_o[16].read());
			aesl_tmp_337++;
		}

		// dump stream tvin: "matrix_o[17]"
		std::vector<short > aesl_tmp_339;
		int aesl_tmp_340 = 0;
		while (!matrix_o[17].empty())
		{
			aesl_tmp_339.push_back(matrix_o[17].read());
			aesl_tmp_340++;
		}

		// dump stream tvin: "matrix_o[18]"
		std::vector<short > aesl_tmp_342;
		int aesl_tmp_343 = 0;
		while (!matrix_o[18].empty())
		{
			aesl_tmp_342.push_back(matrix_o[18].read());
			aesl_tmp_343++;
		}

		// dump stream tvin: "matrix_o[19]"
		std::vector<short > aesl_tmp_345;
		int aesl_tmp_346 = 0;
		while (!matrix_o[19].empty())
		{
			aesl_tmp_345.push_back(matrix_o[19].read());
			aesl_tmp_346++;
		}

		// dump stream tvin: "matrix_o[20]"
		std::vector<short > aesl_tmp_348;
		int aesl_tmp_349 = 0;
		while (!matrix_o[20].empty())
		{
			aesl_tmp_348.push_back(matrix_o[20].read());
			aesl_tmp_349++;
		}

		// dump stream tvin: "matrix_o[21]"
		std::vector<short > aesl_tmp_351;
		int aesl_tmp_352 = 0;
		while (!matrix_o[21].empty())
		{
			aesl_tmp_351.push_back(matrix_o[21].read());
			aesl_tmp_352++;
		}

		// dump stream tvin: "matrix_o[22]"
		std::vector<short > aesl_tmp_354;
		int aesl_tmp_355 = 0;
		while (!matrix_o[22].empty())
		{
			aesl_tmp_354.push_back(matrix_o[22].read());
			aesl_tmp_355++;
		}

		// dump stream tvin: "matrix_o[23]"
		std::vector<short > aesl_tmp_357;
		int aesl_tmp_358 = 0;
		while (!matrix_o[23].empty())
		{
			aesl_tmp_357.push_back(matrix_o[23].read());
			aesl_tmp_358++;
		}

		// dump stream tvin: "matrix_o[24]"
		std::vector<short > aesl_tmp_360;
		int aesl_tmp_361 = 0;
		while (!matrix_o[24].empty())
		{
			aesl_tmp_360.push_back(matrix_o[24].read());
			aesl_tmp_361++;
		}

		// dump stream tvin: "matrix_o[25]"
		std::vector<short > aesl_tmp_363;
		int aesl_tmp_364 = 0;
		while (!matrix_o[25].empty())
		{
			aesl_tmp_363.push_back(matrix_o[25].read());
			aesl_tmp_364++;
		}

		// dump stream tvin: "matrix_o[26]"
		std::vector<short > aesl_tmp_366;
		int aesl_tmp_367 = 0;
		while (!matrix_o[26].empty())
		{
			aesl_tmp_366.push_back(matrix_o[26].read());
			aesl_tmp_367++;
		}

		// dump stream tvin: "matrix_o[27]"
		std::vector<short > aesl_tmp_369;
		int aesl_tmp_370 = 0;
		while (!matrix_o[27].empty())
		{
			aesl_tmp_369.push_back(matrix_o[27].read());
			aesl_tmp_370++;
		}

		// dump stream tvin: "matrix_o[28]"
		std::vector<short > aesl_tmp_372;
		int aesl_tmp_373 = 0;
		while (!matrix_o[28].empty())
		{
			aesl_tmp_372.push_back(matrix_o[28].read());
			aesl_tmp_373++;
		}

		// dump stream tvin: "matrix_o[29]"
		std::vector<short > aesl_tmp_375;
		int aesl_tmp_376 = 0;
		while (!matrix_o[29].empty())
		{
			aesl_tmp_375.push_back(matrix_o[29].read());
			aesl_tmp_376++;
		}

		// dump stream tvin: "matrix_o[30]"
		std::vector<short > aesl_tmp_378;
		int aesl_tmp_379 = 0;
		while (!matrix_o[30].empty())
		{
			aesl_tmp_378.push_back(matrix_o[30].read());
			aesl_tmp_379++;
		}

		// dump stream tvin: "matrix_o[31]"
		std::vector<short > aesl_tmp_381;
		int aesl_tmp_382 = 0;
		while (!matrix_o[31].empty())
		{
			aesl_tmp_381.push_back(matrix_o[31].read());
			aesl_tmp_382++;
		}

		// dump stream tvin: "matrix_o[32]"
		std::vector<short > aesl_tmp_384;
		int aesl_tmp_385 = 0;
		while (!matrix_o[32].empty())
		{
			aesl_tmp_384.push_back(matrix_o[32].read());
			aesl_tmp_385++;
		}

		// dump stream tvin: "matrix_o[33]"
		std::vector<short > aesl_tmp_387;
		int aesl_tmp_388 = 0;
		while (!matrix_o[33].empty())
		{
			aesl_tmp_387.push_back(matrix_o[33].read());
			aesl_tmp_388++;
		}

		// dump stream tvin: "matrix_o[34]"
		std::vector<short > aesl_tmp_390;
		int aesl_tmp_391 = 0;
		while (!matrix_o[34].empty())
		{
			aesl_tmp_390.push_back(matrix_o[34].read());
			aesl_tmp_391++;
		}

		// dump stream tvin: "matrix_o[35]"
		std::vector<short > aesl_tmp_393;
		int aesl_tmp_394 = 0;
		while (!matrix_o[35].empty())
		{
			aesl_tmp_393.push_back(matrix_o[35].read());
			aesl_tmp_394++;
		}

		// dump stream tvin: "matrix_o[36]"
		std::vector<short > aesl_tmp_396;
		int aesl_tmp_397 = 0;
		while (!matrix_o[36].empty())
		{
			aesl_tmp_396.push_back(matrix_o[36].read());
			aesl_tmp_397++;
		}

		// dump stream tvin: "matrix_o[37]"
		std::vector<short > aesl_tmp_399;
		int aesl_tmp_400 = 0;
		while (!matrix_o[37].empty())
		{
			aesl_tmp_399.push_back(matrix_o[37].read());
			aesl_tmp_400++;
		}

		// dump stream tvin: "matrix_o[38]"
		std::vector<short > aesl_tmp_402;
		int aesl_tmp_403 = 0;
		while (!matrix_o[38].empty())
		{
			aesl_tmp_402.push_back(matrix_o[38].read());
			aesl_tmp_403++;
		}

		// dump stream tvin: "matrix_o[39]"
		std::vector<short > aesl_tmp_405;
		int aesl_tmp_406 = 0;
		while (!matrix_o[39].empty())
		{
			aesl_tmp_405.push_back(matrix_o[39].read());
			aesl_tmp_406++;
		}

		// dump stream tvin: "matrix_o[40]"
		std::vector<short > aesl_tmp_408;
		int aesl_tmp_409 = 0;
		while (!matrix_o[40].empty())
		{
			aesl_tmp_408.push_back(matrix_o[40].read());
			aesl_tmp_409++;
		}

		// dump stream tvin: "matrix_o[41]"
		std::vector<short > aesl_tmp_411;
		int aesl_tmp_412 = 0;
		while (!matrix_o[41].empty())
		{
			aesl_tmp_411.push_back(matrix_o[41].read());
			aesl_tmp_412++;
		}

		// dump stream tvin: "matrix_o[42]"
		std::vector<short > aesl_tmp_414;
		int aesl_tmp_415 = 0;
		while (!matrix_o[42].empty())
		{
			aesl_tmp_414.push_back(matrix_o[42].read());
			aesl_tmp_415++;
		}

		// dump stream tvin: "matrix_o[43]"
		std::vector<short > aesl_tmp_417;
		int aesl_tmp_418 = 0;
		while (!matrix_o[43].empty())
		{
			aesl_tmp_417.push_back(matrix_o[43].read());
			aesl_tmp_418++;
		}

		// dump stream tvin: "matrix_o[44]"
		std::vector<short > aesl_tmp_420;
		int aesl_tmp_421 = 0;
		while (!matrix_o[44].empty())
		{
			aesl_tmp_420.push_back(matrix_o[44].read());
			aesl_tmp_421++;
		}

		// dump stream tvin: "matrix_o[45]"
		std::vector<short > aesl_tmp_423;
		int aesl_tmp_424 = 0;
		while (!matrix_o[45].empty())
		{
			aesl_tmp_423.push_back(matrix_o[45].read());
			aesl_tmp_424++;
		}

		// dump stream tvin: "matrix_o[46]"
		std::vector<short > aesl_tmp_426;
		int aesl_tmp_427 = 0;
		while (!matrix_o[46].empty())
		{
			aesl_tmp_426.push_back(matrix_o[46].read());
			aesl_tmp_427++;
		}

		// dump stream tvin: "matrix_o[47]"
		std::vector<short > aesl_tmp_429;
		int aesl_tmp_430 = 0;
		while (!matrix_o[47].empty())
		{
			aesl_tmp_429.push_back(matrix_o[47].read());
			aesl_tmp_430++;
		}

		// dump stream tvin: "matrix_o[48]"
		std::vector<short > aesl_tmp_432;
		int aesl_tmp_433 = 0;
		while (!matrix_o[48].empty())
		{
			aesl_tmp_432.push_back(matrix_o[48].read());
			aesl_tmp_433++;
		}

		// dump stream tvin: "matrix_o[49]"
		std::vector<short > aesl_tmp_435;
		int aesl_tmp_436 = 0;
		while (!matrix_o[49].empty())
		{
			aesl_tmp_435.push_back(matrix_o[49].read());
			aesl_tmp_436++;
		}

		// dump stream tvin: "matrix_o[50]"
		std::vector<short > aesl_tmp_438;
		int aesl_tmp_439 = 0;
		while (!matrix_o[50].empty())
		{
			aesl_tmp_438.push_back(matrix_o[50].read());
			aesl_tmp_439++;
		}

		// dump stream tvin: "matrix_o[51]"
		std::vector<short > aesl_tmp_441;
		int aesl_tmp_442 = 0;
		while (!matrix_o[51].empty())
		{
			aesl_tmp_441.push_back(matrix_o[51].read());
			aesl_tmp_442++;
		}

		// dump stream tvin: "matrix_o[52]"
		std::vector<short > aesl_tmp_444;
		int aesl_tmp_445 = 0;
		while (!matrix_o[52].empty())
		{
			aesl_tmp_444.push_back(matrix_o[52].read());
			aesl_tmp_445++;
		}

		// dump stream tvin: "matrix_o[53]"
		std::vector<short > aesl_tmp_447;
		int aesl_tmp_448 = 0;
		while (!matrix_o[53].empty())
		{
			aesl_tmp_447.push_back(matrix_o[53].read());
			aesl_tmp_448++;
		}

		// dump stream tvin: "matrix_o[54]"
		std::vector<short > aesl_tmp_450;
		int aesl_tmp_451 = 0;
		while (!matrix_o[54].empty())
		{
			aesl_tmp_450.push_back(matrix_o[54].read());
			aesl_tmp_451++;
		}

		// dump stream tvin: "matrix_o[55]"
		std::vector<short > aesl_tmp_453;
		int aesl_tmp_454 = 0;
		while (!matrix_o[55].empty())
		{
			aesl_tmp_453.push_back(matrix_o[55].read());
			aesl_tmp_454++;
		}

		// dump stream tvin: "matrix_o[56]"
		std::vector<short > aesl_tmp_456;
		int aesl_tmp_457 = 0;
		while (!matrix_o[56].empty())
		{
			aesl_tmp_456.push_back(matrix_o[56].read());
			aesl_tmp_457++;
		}

		// dump stream tvin: "matrix_o[57]"
		std::vector<short > aesl_tmp_459;
		int aesl_tmp_460 = 0;
		while (!matrix_o[57].empty())
		{
			aesl_tmp_459.push_back(matrix_o[57].read());
			aesl_tmp_460++;
		}

		// dump stream tvin: "matrix_o[58]"
		std::vector<short > aesl_tmp_462;
		int aesl_tmp_463 = 0;
		while (!matrix_o[58].empty())
		{
			aesl_tmp_462.push_back(matrix_o[58].read());
			aesl_tmp_463++;
		}

		// dump stream tvin: "matrix_o[59]"
		std::vector<short > aesl_tmp_465;
		int aesl_tmp_466 = 0;
		while (!matrix_o[59].empty())
		{
			aesl_tmp_465.push_back(matrix_o[59].read());
			aesl_tmp_466++;
		}

		// dump stream tvin: "matrix_o[60]"
		std::vector<short > aesl_tmp_468;
		int aesl_tmp_469 = 0;
		while (!matrix_o[60].empty())
		{
			aesl_tmp_468.push_back(matrix_o[60].read());
			aesl_tmp_469++;
		}

		// dump stream tvin: "matrix_o[61]"
		std::vector<short > aesl_tmp_471;
		int aesl_tmp_472 = 0;
		while (!matrix_o[61].empty())
		{
			aesl_tmp_471.push_back(matrix_o[61].read());
			aesl_tmp_472++;
		}

		// dump stream tvin: "matrix_o[62]"
		std::vector<short > aesl_tmp_474;
		int aesl_tmp_475 = 0;
		while (!matrix_o[62].empty())
		{
			aesl_tmp_474.push_back(matrix_o[62].read());
			aesl_tmp_475++;
		}

		// dump stream tvin: "matrix_o[63]"
		std::vector<short > aesl_tmp_477;
		int aesl_tmp_478 = 0;
		while (!matrix_o[63].empty())
		{
			aesl_tmp_477.push_back(matrix_o[63].read());
			aesl_tmp_478++;
		}

		// dump stream tvin: "matrix_o[64]"
		std::vector<short > aesl_tmp_480;
		int aesl_tmp_481 = 0;
		while (!matrix_o[64].empty())
		{
			aesl_tmp_480.push_back(matrix_o[64].read());
			aesl_tmp_481++;
		}

		// dump stream tvin: "matrix_o[65]"
		std::vector<short > aesl_tmp_483;
		int aesl_tmp_484 = 0;
		while (!matrix_o[65].empty())
		{
			aesl_tmp_483.push_back(matrix_o[65].read());
			aesl_tmp_484++;
		}

		// dump stream tvin: "matrix_o[66]"
		std::vector<short > aesl_tmp_486;
		int aesl_tmp_487 = 0;
		while (!matrix_o[66].empty())
		{
			aesl_tmp_486.push_back(matrix_o[66].read());
			aesl_tmp_487++;
		}

		// dump stream tvin: "matrix_o[67]"
		std::vector<short > aesl_tmp_489;
		int aesl_tmp_490 = 0;
		while (!matrix_o[67].empty())
		{
			aesl_tmp_489.push_back(matrix_o[67].read());
			aesl_tmp_490++;
		}

		// dump stream tvin: "matrix_o[68]"
		std::vector<short > aesl_tmp_492;
		int aesl_tmp_493 = 0;
		while (!matrix_o[68].empty())
		{
			aesl_tmp_492.push_back(matrix_o[68].read());
			aesl_tmp_493++;
		}

		// dump stream tvin: "matrix_o[69]"
		std::vector<short > aesl_tmp_495;
		int aesl_tmp_496 = 0;
		while (!matrix_o[69].empty())
		{
			aesl_tmp_495.push_back(matrix_o[69].read());
			aesl_tmp_496++;
		}

		// dump stream tvin: "matrix_o[70]"
		std::vector<short > aesl_tmp_498;
		int aesl_tmp_499 = 0;
		while (!matrix_o[70].empty())
		{
			aesl_tmp_498.push_back(matrix_o[70].read());
			aesl_tmp_499++;
		}

		// dump stream tvin: "matrix_o[71]"
		std::vector<short > aesl_tmp_501;
		int aesl_tmp_502 = 0;
		while (!matrix_o[71].empty())
		{
			aesl_tmp_501.push_back(matrix_o[71].read());
			aesl_tmp_502++;
		}

		// dump stream tvin: "matrix_o[72]"
		std::vector<short > aesl_tmp_504;
		int aesl_tmp_505 = 0;
		while (!matrix_o[72].empty())
		{
			aesl_tmp_504.push_back(matrix_o[72].read());
			aesl_tmp_505++;
		}

		// dump stream tvin: "matrix_o[73]"
		std::vector<short > aesl_tmp_507;
		int aesl_tmp_508 = 0;
		while (!matrix_o[73].empty())
		{
			aesl_tmp_507.push_back(matrix_o[73].read());
			aesl_tmp_508++;
		}

		// dump stream tvin: "matrix_o[74]"
		std::vector<short > aesl_tmp_510;
		int aesl_tmp_511 = 0;
		while (!matrix_o[74].empty())
		{
			aesl_tmp_510.push_back(matrix_o[74].read());
			aesl_tmp_511++;
		}

		// dump stream tvin: "matrix_o[75]"
		std::vector<short > aesl_tmp_513;
		int aesl_tmp_514 = 0;
		while (!matrix_o[75].empty())
		{
			aesl_tmp_513.push_back(matrix_o[75].read());
			aesl_tmp_514++;
		}

		// dump stream tvin: "matrix_o[76]"
		std::vector<short > aesl_tmp_516;
		int aesl_tmp_517 = 0;
		while (!matrix_o[76].empty())
		{
			aesl_tmp_516.push_back(matrix_o[76].read());
			aesl_tmp_517++;
		}

		// dump stream tvin: "matrix_o[77]"
		std::vector<short > aesl_tmp_519;
		int aesl_tmp_520 = 0;
		while (!matrix_o[77].empty())
		{
			aesl_tmp_519.push_back(matrix_o[77].read());
			aesl_tmp_520++;
		}

		// dump stream tvin: "matrix_o[78]"
		std::vector<short > aesl_tmp_522;
		int aesl_tmp_523 = 0;
		while (!matrix_o[78].empty())
		{
			aesl_tmp_522.push_back(matrix_o[78].read());
			aesl_tmp_523++;
		}

		// dump stream tvin: "matrix_o[79]"
		std::vector<short > aesl_tmp_525;
		int aesl_tmp_526 = 0;
		while (!matrix_o[79].empty())
		{
			aesl_tmp_525.push_back(matrix_o[79].read());
			aesl_tmp_526++;
		}

		// dump stream tvin: "matrix_o[80]"
		std::vector<short > aesl_tmp_528;
		int aesl_tmp_529 = 0;
		while (!matrix_o[80].empty())
		{
			aesl_tmp_528.push_back(matrix_o[80].read());
			aesl_tmp_529++;
		}

		// dump stream tvin: "matrix_o[81]"
		std::vector<short > aesl_tmp_531;
		int aesl_tmp_532 = 0;
		while (!matrix_o[81].empty())
		{
			aesl_tmp_531.push_back(matrix_o[81].read());
			aesl_tmp_532++;
		}

		// dump stream tvin: "matrix_o[82]"
		std::vector<short > aesl_tmp_534;
		int aesl_tmp_535 = 0;
		while (!matrix_o[82].empty())
		{
			aesl_tmp_534.push_back(matrix_o[82].read());
			aesl_tmp_535++;
		}

		// dump stream tvin: "matrix_o[83]"
		std::vector<short > aesl_tmp_537;
		int aesl_tmp_538 = 0;
		while (!matrix_o[83].empty())
		{
			aesl_tmp_537.push_back(matrix_o[83].read());
			aesl_tmp_538++;
		}

		// dump stream tvin: "matrix_o[84]"
		std::vector<short > aesl_tmp_540;
		int aesl_tmp_541 = 0;
		while (!matrix_o[84].empty())
		{
			aesl_tmp_540.push_back(matrix_o[84].read());
			aesl_tmp_541++;
		}

		// dump stream tvin: "matrix_o[85]"
		std::vector<short > aesl_tmp_543;
		int aesl_tmp_544 = 0;
		while (!matrix_o[85].empty())
		{
			aesl_tmp_543.push_back(matrix_o[85].read());
			aesl_tmp_544++;
		}

		// dump stream tvin: "matrix_o[86]"
		std::vector<short > aesl_tmp_546;
		int aesl_tmp_547 = 0;
		while (!matrix_o[86].empty())
		{
			aesl_tmp_546.push_back(matrix_o[86].read());
			aesl_tmp_547++;
		}

		// dump stream tvin: "matrix_o[87]"
		std::vector<short > aesl_tmp_549;
		int aesl_tmp_550 = 0;
		while (!matrix_o[87].empty())
		{
			aesl_tmp_549.push_back(matrix_o[87].read());
			aesl_tmp_550++;
		}

		// dump stream tvin: "matrix_o[88]"
		std::vector<short > aesl_tmp_552;
		int aesl_tmp_553 = 0;
		while (!matrix_o[88].empty())
		{
			aesl_tmp_552.push_back(matrix_o[88].read());
			aesl_tmp_553++;
		}

		// dump stream tvin: "matrix_o[89]"
		std::vector<short > aesl_tmp_555;
		int aesl_tmp_556 = 0;
		while (!matrix_o[89].empty())
		{
			aesl_tmp_555.push_back(matrix_o[89].read());
			aesl_tmp_556++;
		}

		// dump stream tvin: "matrix_o[90]"
		std::vector<short > aesl_tmp_558;
		int aesl_tmp_559 = 0;
		while (!matrix_o[90].empty())
		{
			aesl_tmp_558.push_back(matrix_o[90].read());
			aesl_tmp_559++;
		}

		// dump stream tvin: "matrix_o[91]"
		std::vector<short > aesl_tmp_561;
		int aesl_tmp_562 = 0;
		while (!matrix_o[91].empty())
		{
			aesl_tmp_561.push_back(matrix_o[91].read());
			aesl_tmp_562++;
		}

		// dump stream tvin: "matrix_o[92]"
		std::vector<short > aesl_tmp_564;
		int aesl_tmp_565 = 0;
		while (!matrix_o[92].empty())
		{
			aesl_tmp_564.push_back(matrix_o[92].read());
			aesl_tmp_565++;
		}

		// dump stream tvin: "matrix_o[93]"
		std::vector<short > aesl_tmp_567;
		int aesl_tmp_568 = 0;
		while (!matrix_o[93].empty())
		{
			aesl_tmp_567.push_back(matrix_o[93].read());
			aesl_tmp_568++;
		}

		// dump stream tvin: "matrix_o[94]"
		std::vector<short > aesl_tmp_570;
		int aesl_tmp_571 = 0;
		while (!matrix_o[94].empty())
		{
			aesl_tmp_570.push_back(matrix_o[94].read());
			aesl_tmp_571++;
		}

		// dump stream tvin: "matrix_o[95]"
		std::vector<short > aesl_tmp_573;
		int aesl_tmp_574 = 0;
		while (!matrix_o[95].empty())
		{
			aesl_tmp_573.push_back(matrix_o[95].read());
			aesl_tmp_574++;
		}

		// dump stream tvin: "matrix_o[96]"
		std::vector<short > aesl_tmp_576;
		int aesl_tmp_577 = 0;
		while (!matrix_o[96].empty())
		{
			aesl_tmp_576.push_back(matrix_o[96].read());
			aesl_tmp_577++;
		}

		// dump stream tvin: "matrix_o[97]"
		std::vector<short > aesl_tmp_579;
		int aesl_tmp_580 = 0;
		while (!matrix_o[97].empty())
		{
			aesl_tmp_579.push_back(matrix_o[97].read());
			aesl_tmp_580++;
		}

		// dump stream tvin: "matrix_o[98]"
		std::vector<short > aesl_tmp_582;
		int aesl_tmp_583 = 0;
		while (!matrix_o[98].empty())
		{
			aesl_tmp_582.push_back(matrix_o[98].read());
			aesl_tmp_583++;
		}

		// dump stream tvin: "matrix_o[99]"
		std::vector<short > aesl_tmp_585;
		int aesl_tmp_586 = 0;
		while (!matrix_o[99].empty())
		{
			aesl_tmp_585.push_back(matrix_o[99].read());
			aesl_tmp_586++;
		}

		// dump stream tvin: "matrix_o[100]"
		std::vector<short > aesl_tmp_588;
		int aesl_tmp_589 = 0;
		while (!matrix_o[100].empty())
		{
			aesl_tmp_588.push_back(matrix_o[100].read());
			aesl_tmp_589++;
		}

		// dump stream tvin: "matrix_o[101]"
		std::vector<short > aesl_tmp_591;
		int aesl_tmp_592 = 0;
		while (!matrix_o[101].empty())
		{
			aesl_tmp_591.push_back(matrix_o[101].read());
			aesl_tmp_592++;
		}

		// dump stream tvin: "matrix_o[102]"
		std::vector<short > aesl_tmp_594;
		int aesl_tmp_595 = 0;
		while (!matrix_o[102].empty())
		{
			aesl_tmp_594.push_back(matrix_o[102].read());
			aesl_tmp_595++;
		}

		// dump stream tvin: "matrix_o[103]"
		std::vector<short > aesl_tmp_597;
		int aesl_tmp_598 = 0;
		while (!matrix_o[103].empty())
		{
			aesl_tmp_597.push_back(matrix_o[103].read());
			aesl_tmp_598++;
		}

		// dump stream tvin: "matrix_o[104]"
		std::vector<short > aesl_tmp_600;
		int aesl_tmp_601 = 0;
		while (!matrix_o[104].empty())
		{
			aesl_tmp_600.push_back(matrix_o[104].read());
			aesl_tmp_601++;
		}

		// dump stream tvin: "matrix_o[105]"
		std::vector<short > aesl_tmp_603;
		int aesl_tmp_604 = 0;
		while (!matrix_o[105].empty())
		{
			aesl_tmp_603.push_back(matrix_o[105].read());
			aesl_tmp_604++;
		}

		// dump stream tvin: "matrix_o[106]"
		std::vector<short > aesl_tmp_606;
		int aesl_tmp_607 = 0;
		while (!matrix_o[106].empty())
		{
			aesl_tmp_606.push_back(matrix_o[106].read());
			aesl_tmp_607++;
		}

		// dump stream tvin: "matrix_o[107]"
		std::vector<short > aesl_tmp_609;
		int aesl_tmp_610 = 0;
		while (!matrix_o[107].empty())
		{
			aesl_tmp_609.push_back(matrix_o[107].read());
			aesl_tmp_610++;
		}

		// dump stream tvin: "matrix_o[108]"
		std::vector<short > aesl_tmp_612;
		int aesl_tmp_613 = 0;
		while (!matrix_o[108].empty())
		{
			aesl_tmp_612.push_back(matrix_o[108].read());
			aesl_tmp_613++;
		}

		// dump stream tvin: "matrix_o[109]"
		std::vector<short > aesl_tmp_615;
		int aesl_tmp_616 = 0;
		while (!matrix_o[109].empty())
		{
			aesl_tmp_615.push_back(matrix_o[109].read());
			aesl_tmp_616++;
		}

		// dump stream tvin: "matrix_o[110]"
		std::vector<short > aesl_tmp_618;
		int aesl_tmp_619 = 0;
		while (!matrix_o[110].empty())
		{
			aesl_tmp_618.push_back(matrix_o[110].read());
			aesl_tmp_619++;
		}

		// dump stream tvin: "matrix_o[111]"
		std::vector<short > aesl_tmp_621;
		int aesl_tmp_622 = 0;
		while (!matrix_o[111].empty())
		{
			aesl_tmp_621.push_back(matrix_o[111].read());
			aesl_tmp_622++;
		}

		// dump stream tvin: "matrix_o[112]"
		std::vector<short > aesl_tmp_624;
		int aesl_tmp_625 = 0;
		while (!matrix_o[112].empty())
		{
			aesl_tmp_624.push_back(matrix_o[112].read());
			aesl_tmp_625++;
		}

		// dump stream tvin: "matrix_o[113]"
		std::vector<short > aesl_tmp_627;
		int aesl_tmp_628 = 0;
		while (!matrix_o[113].empty())
		{
			aesl_tmp_627.push_back(matrix_o[113].read());
			aesl_tmp_628++;
		}

		// dump stream tvin: "matrix_o[114]"
		std::vector<short > aesl_tmp_630;
		int aesl_tmp_631 = 0;
		while (!matrix_o[114].empty())
		{
			aesl_tmp_630.push_back(matrix_o[114].read());
			aesl_tmp_631++;
		}

		// dump stream tvin: "matrix_o[115]"
		std::vector<short > aesl_tmp_633;
		int aesl_tmp_634 = 0;
		while (!matrix_o[115].empty())
		{
			aesl_tmp_633.push_back(matrix_o[115].read());
			aesl_tmp_634++;
		}

		// dump stream tvin: "matrix_o[116]"
		std::vector<short > aesl_tmp_636;
		int aesl_tmp_637 = 0;
		while (!matrix_o[116].empty())
		{
			aesl_tmp_636.push_back(matrix_o[116].read());
			aesl_tmp_637++;
		}

		// dump stream tvin: "matrix_o[117]"
		std::vector<short > aesl_tmp_639;
		int aesl_tmp_640 = 0;
		while (!matrix_o[117].empty())
		{
			aesl_tmp_639.push_back(matrix_o[117].read());
			aesl_tmp_640++;
		}

		// dump stream tvin: "matrix_o[118]"
		std::vector<short > aesl_tmp_642;
		int aesl_tmp_643 = 0;
		while (!matrix_o[118].empty())
		{
			aesl_tmp_642.push_back(matrix_o[118].read());
			aesl_tmp_643++;
		}

		// dump stream tvin: "matrix_o[119]"
		std::vector<short > aesl_tmp_645;
		int aesl_tmp_646 = 0;
		while (!matrix_o[119].empty())
		{
			aesl_tmp_645.push_back(matrix_o[119].read());
			aesl_tmp_646++;
		}

		// dump stream tvin: "matrix_o[120]"
		std::vector<short > aesl_tmp_648;
		int aesl_tmp_649 = 0;
		while (!matrix_o[120].empty())
		{
			aesl_tmp_648.push_back(matrix_o[120].read());
			aesl_tmp_649++;
		}

		// dump stream tvin: "matrix_o[121]"
		std::vector<short > aesl_tmp_651;
		int aesl_tmp_652 = 0;
		while (!matrix_o[121].empty())
		{
			aesl_tmp_651.push_back(matrix_o[121].read());
			aesl_tmp_652++;
		}

		// dump stream tvin: "matrix_o[122]"
		std::vector<short > aesl_tmp_654;
		int aesl_tmp_655 = 0;
		while (!matrix_o[122].empty())
		{
			aesl_tmp_654.push_back(matrix_o[122].read());
			aesl_tmp_655++;
		}

		// dump stream tvin: "matrix_o[123]"
		std::vector<short > aesl_tmp_657;
		int aesl_tmp_658 = 0;
		while (!matrix_o[123].empty())
		{
			aesl_tmp_657.push_back(matrix_o[123].read());
			aesl_tmp_658++;
		}

		// dump stream tvin: "matrix_o[124]"
		std::vector<short > aesl_tmp_660;
		int aesl_tmp_661 = 0;
		while (!matrix_o[124].empty())
		{
			aesl_tmp_660.push_back(matrix_o[124].read());
			aesl_tmp_661++;
		}

		// dump stream tvin: "matrix_o[125]"
		std::vector<short > aesl_tmp_663;
		int aesl_tmp_664 = 0;
		while (!matrix_o[125].empty())
		{
			aesl_tmp_663.push_back(matrix_o[125].read());
			aesl_tmp_664++;
		}

		// dump stream tvin: "matrix_o[126]"
		std::vector<short > aesl_tmp_666;
		int aesl_tmp_667 = 0;
		while (!matrix_o[126].empty())
		{
			aesl_tmp_666.push_back(matrix_o[126].read());
			aesl_tmp_667++;
		}

		// dump stream tvin: "matrix_o[127]"
		std::vector<short > aesl_tmp_669;
		int aesl_tmp_670 = 0;
		while (!matrix_o[127].empty())
		{
			aesl_tmp_669.push_back(matrix_o[127].read());
			aesl_tmp_670++;
		}

		// [[transaction]]
		sprintf(tvin_kernel_s1x1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_kernel_s1x1, tvin_kernel_s1x1);

		sc_bv<16>* kernel_s1x1_tvin_wrapc_buffer = new sc_bv<16>[16];

		// RTL Name: kernel_s1x1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: kernel_s1x1(15, 0)
				{
					// carray: (0) => (15) @ (1)
					for (int i_0 = 0; i_0 <= 15; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : kernel_s1x1[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : kernel_s1x1[0]
						// regulate_c_name       : kernel_s1x1
						// input_type_conversion : kernel_s1x1[i_0]
						if (&(kernel_s1x1[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> kernel_s1x1_tmp_mem;
							kernel_s1x1_tmp_mem = kernel_s1x1[i_0];
							kernel_s1x1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = kernel_s1x1_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 16; i++)
		{
			sprintf(tvin_kernel_s1x1, "%s\n", (kernel_s1x1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_kernel_s1x1, tvin_kernel_s1x1);
		}

		tcl_file.set_num(16, &tcl_file.kernel_s1x1_depth);
		sprintf(tvin_kernel_s1x1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_kernel_s1x1, tvin_kernel_s1x1);

		// release memory allocation
		delete [] kernel_s1x1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_kernel_e1x1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_kernel_e1x1, tvin_kernel_e1x1);

		sc_bv<16>* kernel_e1x1_tvin_wrapc_buffer = new sc_bv<16>[64];

		// RTL Name: kernel_e1x1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: kernel_e1x1(15, 0)
				{
					// carray: (0) => (63) @ (1)
					for (int i_0 = 0; i_0 <= 63; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : kernel_e1x1[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : kernel_e1x1[0]
						// regulate_c_name       : kernel_e1x1
						// input_type_conversion : kernel_e1x1[i_0]
						if (&(kernel_e1x1[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> kernel_e1x1_tmp_mem;
							kernel_e1x1_tmp_mem = kernel_e1x1[i_0];
							kernel_e1x1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = kernel_e1x1_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 64; i++)
		{
			sprintf(tvin_kernel_e1x1, "%s\n", (kernel_e1x1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_kernel_e1x1, tvin_kernel_e1x1);
		}

		tcl_file.set_num(64, &tcl_file.kernel_e1x1_depth);
		sprintf(tvin_kernel_e1x1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_kernel_e1x1, tvin_kernel_e1x1);

		// release memory allocation
		delete [] kernel_e1x1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_kernel_e3x3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_kernel_e3x3, tvin_kernel_e3x3);

		sc_bv<16>* kernel_e3x3_tvin_wrapc_buffer = new sc_bv<16>[576];

		// RTL Name: kernel_e3x3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: kernel_e3x3(15, 0)
				{
					// carray: (0) => (2) @ (1)
					for (int i_0 = 0; i_0 <= 2; i_0 += 1)
					{
						// carray: (0) => (2) @ (1)
						for (int i_1 = 0; i_1 <= 2; i_1 += 1)
						{
							// carray: (0) => (63) @ (1)
							for (int i_2 = 0; i_2 <= 63; i_2 += 1)
							{
								// sub                   : i_0 i_1 i_2
								// ori_name              : kernel_e3x3[i_0][i_1][i_2]
								// sub_1st_elem          : 0 0 0
								// ori_name_1st_elem     : kernel_e3x3[0][0][0]
								// regulate_c_name       : kernel_e3x3
								// input_type_conversion : kernel_e3x3[i_0][i_1][i_2]
								if (&(kernel_e3x3[0][0][0]) != NULL) // check the null address if the c port is array or others
								{
									sc_lv<16> kernel_e3x3_tmp_mem;
									kernel_e3x3_tmp_mem = kernel_e3x3[i_0][i_1][i_2];
									kernel_e3x3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = kernel_e3x3_tmp_mem.range(15, 0);
								}
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 576; i++)
		{
			sprintf(tvin_kernel_e3x3, "%s\n", (kernel_e3x3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_kernel_e3x3, tvin_kernel_e3x3);
		}

		tcl_file.set_num(576, &tcl_file.kernel_e3x3_depth);
		sprintf(tvin_kernel_e3x3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_kernel_e3x3, tvin_kernel_e3x3);

		// release memory allocation
		delete [] kernel_e3x3_tvin_wrapc_buffer;

		// push back input stream: "matrix_i[0]"
		for (int i = 0; i < aesl_tmp_1; i++)
		{
			matrix_i[0].write(aesl_tmp_0[i]);
		}

		// push back input stream: "matrix_i[1]"
		for (int i = 0; i < aesl_tmp_4; i++)
		{
			matrix_i[1].write(aesl_tmp_3[i]);
		}

		// push back input stream: "matrix_i[2]"
		for (int i = 0; i < aesl_tmp_7; i++)
		{
			matrix_i[2].write(aesl_tmp_6[i]);
		}

		// push back input stream: "matrix_i[3]"
		for (int i = 0; i < aesl_tmp_10; i++)
		{
			matrix_i[3].write(aesl_tmp_9[i]);
		}

		// push back input stream: "matrix_i[4]"
		for (int i = 0; i < aesl_tmp_13; i++)
		{
			matrix_i[4].write(aesl_tmp_12[i]);
		}

		// push back input stream: "matrix_i[5]"
		for (int i = 0; i < aesl_tmp_16; i++)
		{
			matrix_i[5].write(aesl_tmp_15[i]);
		}

		// push back input stream: "matrix_i[6]"
		for (int i = 0; i < aesl_tmp_19; i++)
		{
			matrix_i[6].write(aesl_tmp_18[i]);
		}

		// push back input stream: "matrix_i[7]"
		for (int i = 0; i < aesl_tmp_22; i++)
		{
			matrix_i[7].write(aesl_tmp_21[i]);
		}

		// push back input stream: "matrix_i[8]"
		for (int i = 0; i < aesl_tmp_25; i++)
		{
			matrix_i[8].write(aesl_tmp_24[i]);
		}

		// push back input stream: "matrix_i[9]"
		for (int i = 0; i < aesl_tmp_28; i++)
		{
			matrix_i[9].write(aesl_tmp_27[i]);
		}

		// push back input stream: "matrix_i[10]"
		for (int i = 0; i < aesl_tmp_31; i++)
		{
			matrix_i[10].write(aesl_tmp_30[i]);
		}

		// push back input stream: "matrix_i[11]"
		for (int i = 0; i < aesl_tmp_34; i++)
		{
			matrix_i[11].write(aesl_tmp_33[i]);
		}

		// push back input stream: "matrix_i[12]"
		for (int i = 0; i < aesl_tmp_37; i++)
		{
			matrix_i[12].write(aesl_tmp_36[i]);
		}

		// push back input stream: "matrix_i[13]"
		for (int i = 0; i < aesl_tmp_40; i++)
		{
			matrix_i[13].write(aesl_tmp_39[i]);
		}

		// push back input stream: "matrix_i[14]"
		for (int i = 0; i < aesl_tmp_43; i++)
		{
			matrix_i[14].write(aesl_tmp_42[i]);
		}

		// push back input stream: "matrix_i[15]"
		for (int i = 0; i < aesl_tmp_46; i++)
		{
			matrix_i[15].write(aesl_tmp_45[i]);
		}

		// push back input stream: "matrix_i[16]"
		for (int i = 0; i < aesl_tmp_49; i++)
		{
			matrix_i[16].write(aesl_tmp_48[i]);
		}

		// push back input stream: "matrix_i[17]"
		for (int i = 0; i < aesl_tmp_52; i++)
		{
			matrix_i[17].write(aesl_tmp_51[i]);
		}

		// push back input stream: "matrix_i[18]"
		for (int i = 0; i < aesl_tmp_55; i++)
		{
			matrix_i[18].write(aesl_tmp_54[i]);
		}

		// push back input stream: "matrix_i[19]"
		for (int i = 0; i < aesl_tmp_58; i++)
		{
			matrix_i[19].write(aesl_tmp_57[i]);
		}

		// push back input stream: "matrix_i[20]"
		for (int i = 0; i < aesl_tmp_61; i++)
		{
			matrix_i[20].write(aesl_tmp_60[i]);
		}

		// push back input stream: "matrix_i[21]"
		for (int i = 0; i < aesl_tmp_64; i++)
		{
			matrix_i[21].write(aesl_tmp_63[i]);
		}

		// push back input stream: "matrix_i[22]"
		for (int i = 0; i < aesl_tmp_67; i++)
		{
			matrix_i[22].write(aesl_tmp_66[i]);
		}

		// push back input stream: "matrix_i[23]"
		for (int i = 0; i < aesl_tmp_70; i++)
		{
			matrix_i[23].write(aesl_tmp_69[i]);
		}

		// push back input stream: "matrix_i[24]"
		for (int i = 0; i < aesl_tmp_73; i++)
		{
			matrix_i[24].write(aesl_tmp_72[i]);
		}

		// push back input stream: "matrix_i[25]"
		for (int i = 0; i < aesl_tmp_76; i++)
		{
			matrix_i[25].write(aesl_tmp_75[i]);
		}

		// push back input stream: "matrix_i[26]"
		for (int i = 0; i < aesl_tmp_79; i++)
		{
			matrix_i[26].write(aesl_tmp_78[i]);
		}

		// push back input stream: "matrix_i[27]"
		for (int i = 0; i < aesl_tmp_82; i++)
		{
			matrix_i[27].write(aesl_tmp_81[i]);
		}

		// push back input stream: "matrix_i[28]"
		for (int i = 0; i < aesl_tmp_85; i++)
		{
			matrix_i[28].write(aesl_tmp_84[i]);
		}

		// push back input stream: "matrix_i[29]"
		for (int i = 0; i < aesl_tmp_88; i++)
		{
			matrix_i[29].write(aesl_tmp_87[i]);
		}

		// push back input stream: "matrix_i[30]"
		for (int i = 0; i < aesl_tmp_91; i++)
		{
			matrix_i[30].write(aesl_tmp_90[i]);
		}

		// push back input stream: "matrix_i[31]"
		for (int i = 0; i < aesl_tmp_94; i++)
		{
			matrix_i[31].write(aesl_tmp_93[i]);
		}

		// push back input stream: "matrix_i[32]"
		for (int i = 0; i < aesl_tmp_97; i++)
		{
			matrix_i[32].write(aesl_tmp_96[i]);
		}

		// push back input stream: "matrix_i[33]"
		for (int i = 0; i < aesl_tmp_100; i++)
		{
			matrix_i[33].write(aesl_tmp_99[i]);
		}

		// push back input stream: "matrix_i[34]"
		for (int i = 0; i < aesl_tmp_103; i++)
		{
			matrix_i[34].write(aesl_tmp_102[i]);
		}

		// push back input stream: "matrix_i[35]"
		for (int i = 0; i < aesl_tmp_106; i++)
		{
			matrix_i[35].write(aesl_tmp_105[i]);
		}

		// push back input stream: "matrix_i[36]"
		for (int i = 0; i < aesl_tmp_109; i++)
		{
			matrix_i[36].write(aesl_tmp_108[i]);
		}

		// push back input stream: "matrix_i[37]"
		for (int i = 0; i < aesl_tmp_112; i++)
		{
			matrix_i[37].write(aesl_tmp_111[i]);
		}

		// push back input stream: "matrix_i[38]"
		for (int i = 0; i < aesl_tmp_115; i++)
		{
			matrix_i[38].write(aesl_tmp_114[i]);
		}

		// push back input stream: "matrix_i[39]"
		for (int i = 0; i < aesl_tmp_118; i++)
		{
			matrix_i[39].write(aesl_tmp_117[i]);
		}

		// push back input stream: "matrix_i[40]"
		for (int i = 0; i < aesl_tmp_121; i++)
		{
			matrix_i[40].write(aesl_tmp_120[i]);
		}

		// push back input stream: "matrix_i[41]"
		for (int i = 0; i < aesl_tmp_124; i++)
		{
			matrix_i[41].write(aesl_tmp_123[i]);
		}

		// push back input stream: "matrix_i[42]"
		for (int i = 0; i < aesl_tmp_127; i++)
		{
			matrix_i[42].write(aesl_tmp_126[i]);
		}

		// push back input stream: "matrix_i[43]"
		for (int i = 0; i < aesl_tmp_130; i++)
		{
			matrix_i[43].write(aesl_tmp_129[i]);
		}

		// push back input stream: "matrix_i[44]"
		for (int i = 0; i < aesl_tmp_133; i++)
		{
			matrix_i[44].write(aesl_tmp_132[i]);
		}

		// push back input stream: "matrix_i[45]"
		for (int i = 0; i < aesl_tmp_136; i++)
		{
			matrix_i[45].write(aesl_tmp_135[i]);
		}

		// push back input stream: "matrix_i[46]"
		for (int i = 0; i < aesl_tmp_139; i++)
		{
			matrix_i[46].write(aesl_tmp_138[i]);
		}

		// push back input stream: "matrix_i[47]"
		for (int i = 0; i < aesl_tmp_142; i++)
		{
			matrix_i[47].write(aesl_tmp_141[i]);
		}

		// push back input stream: "matrix_i[48]"
		for (int i = 0; i < aesl_tmp_145; i++)
		{
			matrix_i[48].write(aesl_tmp_144[i]);
		}

		// push back input stream: "matrix_i[49]"
		for (int i = 0; i < aesl_tmp_148; i++)
		{
			matrix_i[49].write(aesl_tmp_147[i]);
		}

		// push back input stream: "matrix_i[50]"
		for (int i = 0; i < aesl_tmp_151; i++)
		{
			matrix_i[50].write(aesl_tmp_150[i]);
		}

		// push back input stream: "matrix_i[51]"
		for (int i = 0; i < aesl_tmp_154; i++)
		{
			matrix_i[51].write(aesl_tmp_153[i]);
		}

		// push back input stream: "matrix_i[52]"
		for (int i = 0; i < aesl_tmp_157; i++)
		{
			matrix_i[52].write(aesl_tmp_156[i]);
		}

		// push back input stream: "matrix_i[53]"
		for (int i = 0; i < aesl_tmp_160; i++)
		{
			matrix_i[53].write(aesl_tmp_159[i]);
		}

		// push back input stream: "matrix_i[54]"
		for (int i = 0; i < aesl_tmp_163; i++)
		{
			matrix_i[54].write(aesl_tmp_162[i]);
		}

		// push back input stream: "matrix_i[55]"
		for (int i = 0; i < aesl_tmp_166; i++)
		{
			matrix_i[55].write(aesl_tmp_165[i]);
		}

		// push back input stream: "matrix_i[56]"
		for (int i = 0; i < aesl_tmp_169; i++)
		{
			matrix_i[56].write(aesl_tmp_168[i]);
		}

		// push back input stream: "matrix_i[57]"
		for (int i = 0; i < aesl_tmp_172; i++)
		{
			matrix_i[57].write(aesl_tmp_171[i]);
		}

		// push back input stream: "matrix_i[58]"
		for (int i = 0; i < aesl_tmp_175; i++)
		{
			matrix_i[58].write(aesl_tmp_174[i]);
		}

		// push back input stream: "matrix_i[59]"
		for (int i = 0; i < aesl_tmp_178; i++)
		{
			matrix_i[59].write(aesl_tmp_177[i]);
		}

		// push back input stream: "matrix_i[60]"
		for (int i = 0; i < aesl_tmp_181; i++)
		{
			matrix_i[60].write(aesl_tmp_180[i]);
		}

		// push back input stream: "matrix_i[61]"
		for (int i = 0; i < aesl_tmp_184; i++)
		{
			matrix_i[61].write(aesl_tmp_183[i]);
		}

		// push back input stream: "matrix_i[62]"
		for (int i = 0; i < aesl_tmp_187; i++)
		{
			matrix_i[62].write(aesl_tmp_186[i]);
		}

		// push back input stream: "matrix_i[63]"
		for (int i = 0; i < aesl_tmp_190; i++)
		{
			matrix_i[63].write(aesl_tmp_189[i]);
		}

		// push back input stream: "matrix_i[64]"
		for (int i = 0; i < aesl_tmp_193; i++)
		{
			matrix_i[64].write(aesl_tmp_192[i]);
		}

		// push back input stream: "matrix_i[65]"
		for (int i = 0; i < aesl_tmp_196; i++)
		{
			matrix_i[65].write(aesl_tmp_195[i]);
		}

		// push back input stream: "matrix_i[66]"
		for (int i = 0; i < aesl_tmp_199; i++)
		{
			matrix_i[66].write(aesl_tmp_198[i]);
		}

		// push back input stream: "matrix_i[67]"
		for (int i = 0; i < aesl_tmp_202; i++)
		{
			matrix_i[67].write(aesl_tmp_201[i]);
		}

		// push back input stream: "matrix_i[68]"
		for (int i = 0; i < aesl_tmp_205; i++)
		{
			matrix_i[68].write(aesl_tmp_204[i]);
		}

		// push back input stream: "matrix_i[69]"
		for (int i = 0; i < aesl_tmp_208; i++)
		{
			matrix_i[69].write(aesl_tmp_207[i]);
		}

		// push back input stream: "matrix_i[70]"
		for (int i = 0; i < aesl_tmp_211; i++)
		{
			matrix_i[70].write(aesl_tmp_210[i]);
		}

		// push back input stream: "matrix_i[71]"
		for (int i = 0; i < aesl_tmp_214; i++)
		{
			matrix_i[71].write(aesl_tmp_213[i]);
		}

		// push back input stream: "matrix_i[72]"
		for (int i = 0; i < aesl_tmp_217; i++)
		{
			matrix_i[72].write(aesl_tmp_216[i]);
		}

		// push back input stream: "matrix_i[73]"
		for (int i = 0; i < aesl_tmp_220; i++)
		{
			matrix_i[73].write(aesl_tmp_219[i]);
		}

		// push back input stream: "matrix_i[74]"
		for (int i = 0; i < aesl_tmp_223; i++)
		{
			matrix_i[74].write(aesl_tmp_222[i]);
		}

		// push back input stream: "matrix_i[75]"
		for (int i = 0; i < aesl_tmp_226; i++)
		{
			matrix_i[75].write(aesl_tmp_225[i]);
		}

		// push back input stream: "matrix_i[76]"
		for (int i = 0; i < aesl_tmp_229; i++)
		{
			matrix_i[76].write(aesl_tmp_228[i]);
		}

		// push back input stream: "matrix_i[77]"
		for (int i = 0; i < aesl_tmp_232; i++)
		{
			matrix_i[77].write(aesl_tmp_231[i]);
		}

		// push back input stream: "matrix_i[78]"
		for (int i = 0; i < aesl_tmp_235; i++)
		{
			matrix_i[78].write(aesl_tmp_234[i]);
		}

		// push back input stream: "matrix_i[79]"
		for (int i = 0; i < aesl_tmp_238; i++)
		{
			matrix_i[79].write(aesl_tmp_237[i]);
		}

		// push back input stream: "matrix_i[80]"
		for (int i = 0; i < aesl_tmp_241; i++)
		{
			matrix_i[80].write(aesl_tmp_240[i]);
		}

		// push back input stream: "matrix_i[81]"
		for (int i = 0; i < aesl_tmp_244; i++)
		{
			matrix_i[81].write(aesl_tmp_243[i]);
		}

		// push back input stream: "matrix_i[82]"
		for (int i = 0; i < aesl_tmp_247; i++)
		{
			matrix_i[82].write(aesl_tmp_246[i]);
		}

		// push back input stream: "matrix_i[83]"
		for (int i = 0; i < aesl_tmp_250; i++)
		{
			matrix_i[83].write(aesl_tmp_249[i]);
		}

		// push back input stream: "matrix_i[84]"
		for (int i = 0; i < aesl_tmp_253; i++)
		{
			matrix_i[84].write(aesl_tmp_252[i]);
		}

		// push back input stream: "matrix_i[85]"
		for (int i = 0; i < aesl_tmp_256; i++)
		{
			matrix_i[85].write(aesl_tmp_255[i]);
		}

		// push back input stream: "matrix_i[86]"
		for (int i = 0; i < aesl_tmp_259; i++)
		{
			matrix_i[86].write(aesl_tmp_258[i]);
		}

		// push back input stream: "matrix_i[87]"
		for (int i = 0; i < aesl_tmp_262; i++)
		{
			matrix_i[87].write(aesl_tmp_261[i]);
		}

		// push back input stream: "matrix_i[88]"
		for (int i = 0; i < aesl_tmp_265; i++)
		{
			matrix_i[88].write(aesl_tmp_264[i]);
		}

		// push back input stream: "matrix_i[89]"
		for (int i = 0; i < aesl_tmp_268; i++)
		{
			matrix_i[89].write(aesl_tmp_267[i]);
		}

		// push back input stream: "matrix_i[90]"
		for (int i = 0; i < aesl_tmp_271; i++)
		{
			matrix_i[90].write(aesl_tmp_270[i]);
		}

		// push back input stream: "matrix_i[91]"
		for (int i = 0; i < aesl_tmp_274; i++)
		{
			matrix_i[91].write(aesl_tmp_273[i]);
		}

		// push back input stream: "matrix_i[92]"
		for (int i = 0; i < aesl_tmp_277; i++)
		{
			matrix_i[92].write(aesl_tmp_276[i]);
		}

		// push back input stream: "matrix_i[93]"
		for (int i = 0; i < aesl_tmp_280; i++)
		{
			matrix_i[93].write(aesl_tmp_279[i]);
		}

		// push back input stream: "matrix_i[94]"
		for (int i = 0; i < aesl_tmp_283; i++)
		{
			matrix_i[94].write(aesl_tmp_282[i]);
		}

		// push back input stream: "matrix_i[95]"
		for (int i = 0; i < aesl_tmp_286; i++)
		{
			matrix_i[95].write(aesl_tmp_285[i]);
		}

		// push back input stream: "matrix_o[0]"
		for (int i = 0; i < aesl_tmp_289; i++)
		{
			matrix_o[0].write(aesl_tmp_288[i]);
		}

		// push back input stream: "matrix_o[1]"
		for (int i = 0; i < aesl_tmp_292; i++)
		{
			matrix_o[1].write(aesl_tmp_291[i]);
		}

		// push back input stream: "matrix_o[2]"
		for (int i = 0; i < aesl_tmp_295; i++)
		{
			matrix_o[2].write(aesl_tmp_294[i]);
		}

		// push back input stream: "matrix_o[3]"
		for (int i = 0; i < aesl_tmp_298; i++)
		{
			matrix_o[3].write(aesl_tmp_297[i]);
		}

		// push back input stream: "matrix_o[4]"
		for (int i = 0; i < aesl_tmp_301; i++)
		{
			matrix_o[4].write(aesl_tmp_300[i]);
		}

		// push back input stream: "matrix_o[5]"
		for (int i = 0; i < aesl_tmp_304; i++)
		{
			matrix_o[5].write(aesl_tmp_303[i]);
		}

		// push back input stream: "matrix_o[6]"
		for (int i = 0; i < aesl_tmp_307; i++)
		{
			matrix_o[6].write(aesl_tmp_306[i]);
		}

		// push back input stream: "matrix_o[7]"
		for (int i = 0; i < aesl_tmp_310; i++)
		{
			matrix_o[7].write(aesl_tmp_309[i]);
		}

		// push back input stream: "matrix_o[8]"
		for (int i = 0; i < aesl_tmp_313; i++)
		{
			matrix_o[8].write(aesl_tmp_312[i]);
		}

		// push back input stream: "matrix_o[9]"
		for (int i = 0; i < aesl_tmp_316; i++)
		{
			matrix_o[9].write(aesl_tmp_315[i]);
		}

		// push back input stream: "matrix_o[10]"
		for (int i = 0; i < aesl_tmp_319; i++)
		{
			matrix_o[10].write(aesl_tmp_318[i]);
		}

		// push back input stream: "matrix_o[11]"
		for (int i = 0; i < aesl_tmp_322; i++)
		{
			matrix_o[11].write(aesl_tmp_321[i]);
		}

		// push back input stream: "matrix_o[12]"
		for (int i = 0; i < aesl_tmp_325; i++)
		{
			matrix_o[12].write(aesl_tmp_324[i]);
		}

		// push back input stream: "matrix_o[13]"
		for (int i = 0; i < aesl_tmp_328; i++)
		{
			matrix_o[13].write(aesl_tmp_327[i]);
		}

		// push back input stream: "matrix_o[14]"
		for (int i = 0; i < aesl_tmp_331; i++)
		{
			matrix_o[14].write(aesl_tmp_330[i]);
		}

		// push back input stream: "matrix_o[15]"
		for (int i = 0; i < aesl_tmp_334; i++)
		{
			matrix_o[15].write(aesl_tmp_333[i]);
		}

		// push back input stream: "matrix_o[16]"
		for (int i = 0; i < aesl_tmp_337; i++)
		{
			matrix_o[16].write(aesl_tmp_336[i]);
		}

		// push back input stream: "matrix_o[17]"
		for (int i = 0; i < aesl_tmp_340; i++)
		{
			matrix_o[17].write(aesl_tmp_339[i]);
		}

		// push back input stream: "matrix_o[18]"
		for (int i = 0; i < aesl_tmp_343; i++)
		{
			matrix_o[18].write(aesl_tmp_342[i]);
		}

		// push back input stream: "matrix_o[19]"
		for (int i = 0; i < aesl_tmp_346; i++)
		{
			matrix_o[19].write(aesl_tmp_345[i]);
		}

		// push back input stream: "matrix_o[20]"
		for (int i = 0; i < aesl_tmp_349; i++)
		{
			matrix_o[20].write(aesl_tmp_348[i]);
		}

		// push back input stream: "matrix_o[21]"
		for (int i = 0; i < aesl_tmp_352; i++)
		{
			matrix_o[21].write(aesl_tmp_351[i]);
		}

		// push back input stream: "matrix_o[22]"
		for (int i = 0; i < aesl_tmp_355; i++)
		{
			matrix_o[22].write(aesl_tmp_354[i]);
		}

		// push back input stream: "matrix_o[23]"
		for (int i = 0; i < aesl_tmp_358; i++)
		{
			matrix_o[23].write(aesl_tmp_357[i]);
		}

		// push back input stream: "matrix_o[24]"
		for (int i = 0; i < aesl_tmp_361; i++)
		{
			matrix_o[24].write(aesl_tmp_360[i]);
		}

		// push back input stream: "matrix_o[25]"
		for (int i = 0; i < aesl_tmp_364; i++)
		{
			matrix_o[25].write(aesl_tmp_363[i]);
		}

		// push back input stream: "matrix_o[26]"
		for (int i = 0; i < aesl_tmp_367; i++)
		{
			matrix_o[26].write(aesl_tmp_366[i]);
		}

		// push back input stream: "matrix_o[27]"
		for (int i = 0; i < aesl_tmp_370; i++)
		{
			matrix_o[27].write(aesl_tmp_369[i]);
		}

		// push back input stream: "matrix_o[28]"
		for (int i = 0; i < aesl_tmp_373; i++)
		{
			matrix_o[28].write(aesl_tmp_372[i]);
		}

		// push back input stream: "matrix_o[29]"
		for (int i = 0; i < aesl_tmp_376; i++)
		{
			matrix_o[29].write(aesl_tmp_375[i]);
		}

		// push back input stream: "matrix_o[30]"
		for (int i = 0; i < aesl_tmp_379; i++)
		{
			matrix_o[30].write(aesl_tmp_378[i]);
		}

		// push back input stream: "matrix_o[31]"
		for (int i = 0; i < aesl_tmp_382; i++)
		{
			matrix_o[31].write(aesl_tmp_381[i]);
		}

		// push back input stream: "matrix_o[32]"
		for (int i = 0; i < aesl_tmp_385; i++)
		{
			matrix_o[32].write(aesl_tmp_384[i]);
		}

		// push back input stream: "matrix_o[33]"
		for (int i = 0; i < aesl_tmp_388; i++)
		{
			matrix_o[33].write(aesl_tmp_387[i]);
		}

		// push back input stream: "matrix_o[34]"
		for (int i = 0; i < aesl_tmp_391; i++)
		{
			matrix_o[34].write(aesl_tmp_390[i]);
		}

		// push back input stream: "matrix_o[35]"
		for (int i = 0; i < aesl_tmp_394; i++)
		{
			matrix_o[35].write(aesl_tmp_393[i]);
		}

		// push back input stream: "matrix_o[36]"
		for (int i = 0; i < aesl_tmp_397; i++)
		{
			matrix_o[36].write(aesl_tmp_396[i]);
		}

		// push back input stream: "matrix_o[37]"
		for (int i = 0; i < aesl_tmp_400; i++)
		{
			matrix_o[37].write(aesl_tmp_399[i]);
		}

		// push back input stream: "matrix_o[38]"
		for (int i = 0; i < aesl_tmp_403; i++)
		{
			matrix_o[38].write(aesl_tmp_402[i]);
		}

		// push back input stream: "matrix_o[39]"
		for (int i = 0; i < aesl_tmp_406; i++)
		{
			matrix_o[39].write(aesl_tmp_405[i]);
		}

		// push back input stream: "matrix_o[40]"
		for (int i = 0; i < aesl_tmp_409; i++)
		{
			matrix_o[40].write(aesl_tmp_408[i]);
		}

		// push back input stream: "matrix_o[41]"
		for (int i = 0; i < aesl_tmp_412; i++)
		{
			matrix_o[41].write(aesl_tmp_411[i]);
		}

		// push back input stream: "matrix_o[42]"
		for (int i = 0; i < aesl_tmp_415; i++)
		{
			matrix_o[42].write(aesl_tmp_414[i]);
		}

		// push back input stream: "matrix_o[43]"
		for (int i = 0; i < aesl_tmp_418; i++)
		{
			matrix_o[43].write(aesl_tmp_417[i]);
		}

		// push back input stream: "matrix_o[44]"
		for (int i = 0; i < aesl_tmp_421; i++)
		{
			matrix_o[44].write(aesl_tmp_420[i]);
		}

		// push back input stream: "matrix_o[45]"
		for (int i = 0; i < aesl_tmp_424; i++)
		{
			matrix_o[45].write(aesl_tmp_423[i]);
		}

		// push back input stream: "matrix_o[46]"
		for (int i = 0; i < aesl_tmp_427; i++)
		{
			matrix_o[46].write(aesl_tmp_426[i]);
		}

		// push back input stream: "matrix_o[47]"
		for (int i = 0; i < aesl_tmp_430; i++)
		{
			matrix_o[47].write(aesl_tmp_429[i]);
		}

		// push back input stream: "matrix_o[48]"
		for (int i = 0; i < aesl_tmp_433; i++)
		{
			matrix_o[48].write(aesl_tmp_432[i]);
		}

		// push back input stream: "matrix_o[49]"
		for (int i = 0; i < aesl_tmp_436; i++)
		{
			matrix_o[49].write(aesl_tmp_435[i]);
		}

		// push back input stream: "matrix_o[50]"
		for (int i = 0; i < aesl_tmp_439; i++)
		{
			matrix_o[50].write(aesl_tmp_438[i]);
		}

		// push back input stream: "matrix_o[51]"
		for (int i = 0; i < aesl_tmp_442; i++)
		{
			matrix_o[51].write(aesl_tmp_441[i]);
		}

		// push back input stream: "matrix_o[52]"
		for (int i = 0; i < aesl_tmp_445; i++)
		{
			matrix_o[52].write(aesl_tmp_444[i]);
		}

		// push back input stream: "matrix_o[53]"
		for (int i = 0; i < aesl_tmp_448; i++)
		{
			matrix_o[53].write(aesl_tmp_447[i]);
		}

		// push back input stream: "matrix_o[54]"
		for (int i = 0; i < aesl_tmp_451; i++)
		{
			matrix_o[54].write(aesl_tmp_450[i]);
		}

		// push back input stream: "matrix_o[55]"
		for (int i = 0; i < aesl_tmp_454; i++)
		{
			matrix_o[55].write(aesl_tmp_453[i]);
		}

		// push back input stream: "matrix_o[56]"
		for (int i = 0; i < aesl_tmp_457; i++)
		{
			matrix_o[56].write(aesl_tmp_456[i]);
		}

		// push back input stream: "matrix_o[57]"
		for (int i = 0; i < aesl_tmp_460; i++)
		{
			matrix_o[57].write(aesl_tmp_459[i]);
		}

		// push back input stream: "matrix_o[58]"
		for (int i = 0; i < aesl_tmp_463; i++)
		{
			matrix_o[58].write(aesl_tmp_462[i]);
		}

		// push back input stream: "matrix_o[59]"
		for (int i = 0; i < aesl_tmp_466; i++)
		{
			matrix_o[59].write(aesl_tmp_465[i]);
		}

		// push back input stream: "matrix_o[60]"
		for (int i = 0; i < aesl_tmp_469; i++)
		{
			matrix_o[60].write(aesl_tmp_468[i]);
		}

		// push back input stream: "matrix_o[61]"
		for (int i = 0; i < aesl_tmp_472; i++)
		{
			matrix_o[61].write(aesl_tmp_471[i]);
		}

		// push back input stream: "matrix_o[62]"
		for (int i = 0; i < aesl_tmp_475; i++)
		{
			matrix_o[62].write(aesl_tmp_474[i]);
		}

		// push back input stream: "matrix_o[63]"
		for (int i = 0; i < aesl_tmp_478; i++)
		{
			matrix_o[63].write(aesl_tmp_477[i]);
		}

		// push back input stream: "matrix_o[64]"
		for (int i = 0; i < aesl_tmp_481; i++)
		{
			matrix_o[64].write(aesl_tmp_480[i]);
		}

		// push back input stream: "matrix_o[65]"
		for (int i = 0; i < aesl_tmp_484; i++)
		{
			matrix_o[65].write(aesl_tmp_483[i]);
		}

		// push back input stream: "matrix_o[66]"
		for (int i = 0; i < aesl_tmp_487; i++)
		{
			matrix_o[66].write(aesl_tmp_486[i]);
		}

		// push back input stream: "matrix_o[67]"
		for (int i = 0; i < aesl_tmp_490; i++)
		{
			matrix_o[67].write(aesl_tmp_489[i]);
		}

		// push back input stream: "matrix_o[68]"
		for (int i = 0; i < aesl_tmp_493; i++)
		{
			matrix_o[68].write(aesl_tmp_492[i]);
		}

		// push back input stream: "matrix_o[69]"
		for (int i = 0; i < aesl_tmp_496; i++)
		{
			matrix_o[69].write(aesl_tmp_495[i]);
		}

		// push back input stream: "matrix_o[70]"
		for (int i = 0; i < aesl_tmp_499; i++)
		{
			matrix_o[70].write(aesl_tmp_498[i]);
		}

		// push back input stream: "matrix_o[71]"
		for (int i = 0; i < aesl_tmp_502; i++)
		{
			matrix_o[71].write(aesl_tmp_501[i]);
		}

		// push back input stream: "matrix_o[72]"
		for (int i = 0; i < aesl_tmp_505; i++)
		{
			matrix_o[72].write(aesl_tmp_504[i]);
		}

		// push back input stream: "matrix_o[73]"
		for (int i = 0; i < aesl_tmp_508; i++)
		{
			matrix_o[73].write(aesl_tmp_507[i]);
		}

		// push back input stream: "matrix_o[74]"
		for (int i = 0; i < aesl_tmp_511; i++)
		{
			matrix_o[74].write(aesl_tmp_510[i]);
		}

		// push back input stream: "matrix_o[75]"
		for (int i = 0; i < aesl_tmp_514; i++)
		{
			matrix_o[75].write(aesl_tmp_513[i]);
		}

		// push back input stream: "matrix_o[76]"
		for (int i = 0; i < aesl_tmp_517; i++)
		{
			matrix_o[76].write(aesl_tmp_516[i]);
		}

		// push back input stream: "matrix_o[77]"
		for (int i = 0; i < aesl_tmp_520; i++)
		{
			matrix_o[77].write(aesl_tmp_519[i]);
		}

		// push back input stream: "matrix_o[78]"
		for (int i = 0; i < aesl_tmp_523; i++)
		{
			matrix_o[78].write(aesl_tmp_522[i]);
		}

		// push back input stream: "matrix_o[79]"
		for (int i = 0; i < aesl_tmp_526; i++)
		{
			matrix_o[79].write(aesl_tmp_525[i]);
		}

		// push back input stream: "matrix_o[80]"
		for (int i = 0; i < aesl_tmp_529; i++)
		{
			matrix_o[80].write(aesl_tmp_528[i]);
		}

		// push back input stream: "matrix_o[81]"
		for (int i = 0; i < aesl_tmp_532; i++)
		{
			matrix_o[81].write(aesl_tmp_531[i]);
		}

		// push back input stream: "matrix_o[82]"
		for (int i = 0; i < aesl_tmp_535; i++)
		{
			matrix_o[82].write(aesl_tmp_534[i]);
		}

		// push back input stream: "matrix_o[83]"
		for (int i = 0; i < aesl_tmp_538; i++)
		{
			matrix_o[83].write(aesl_tmp_537[i]);
		}

		// push back input stream: "matrix_o[84]"
		for (int i = 0; i < aesl_tmp_541; i++)
		{
			matrix_o[84].write(aesl_tmp_540[i]);
		}

		// push back input stream: "matrix_o[85]"
		for (int i = 0; i < aesl_tmp_544; i++)
		{
			matrix_o[85].write(aesl_tmp_543[i]);
		}

		// push back input stream: "matrix_o[86]"
		for (int i = 0; i < aesl_tmp_547; i++)
		{
			matrix_o[86].write(aesl_tmp_546[i]);
		}

		// push back input stream: "matrix_o[87]"
		for (int i = 0; i < aesl_tmp_550; i++)
		{
			matrix_o[87].write(aesl_tmp_549[i]);
		}

		// push back input stream: "matrix_o[88]"
		for (int i = 0; i < aesl_tmp_553; i++)
		{
			matrix_o[88].write(aesl_tmp_552[i]);
		}

		// push back input stream: "matrix_o[89]"
		for (int i = 0; i < aesl_tmp_556; i++)
		{
			matrix_o[89].write(aesl_tmp_555[i]);
		}

		// push back input stream: "matrix_o[90]"
		for (int i = 0; i < aesl_tmp_559; i++)
		{
			matrix_o[90].write(aesl_tmp_558[i]);
		}

		// push back input stream: "matrix_o[91]"
		for (int i = 0; i < aesl_tmp_562; i++)
		{
			matrix_o[91].write(aesl_tmp_561[i]);
		}

		// push back input stream: "matrix_o[92]"
		for (int i = 0; i < aesl_tmp_565; i++)
		{
			matrix_o[92].write(aesl_tmp_564[i]);
		}

		// push back input stream: "matrix_o[93]"
		for (int i = 0; i < aesl_tmp_568; i++)
		{
			matrix_o[93].write(aesl_tmp_567[i]);
		}

		// push back input stream: "matrix_o[94]"
		for (int i = 0; i < aesl_tmp_571; i++)
		{
			matrix_o[94].write(aesl_tmp_570[i]);
		}

		// push back input stream: "matrix_o[95]"
		for (int i = 0; i < aesl_tmp_574; i++)
		{
			matrix_o[95].write(aesl_tmp_573[i]);
		}

		// push back input stream: "matrix_o[96]"
		for (int i = 0; i < aesl_tmp_577; i++)
		{
			matrix_o[96].write(aesl_tmp_576[i]);
		}

		// push back input stream: "matrix_o[97]"
		for (int i = 0; i < aesl_tmp_580; i++)
		{
			matrix_o[97].write(aesl_tmp_579[i]);
		}

		// push back input stream: "matrix_o[98]"
		for (int i = 0; i < aesl_tmp_583; i++)
		{
			matrix_o[98].write(aesl_tmp_582[i]);
		}

		// push back input stream: "matrix_o[99]"
		for (int i = 0; i < aesl_tmp_586; i++)
		{
			matrix_o[99].write(aesl_tmp_585[i]);
		}

		// push back input stream: "matrix_o[100]"
		for (int i = 0; i < aesl_tmp_589; i++)
		{
			matrix_o[100].write(aesl_tmp_588[i]);
		}

		// push back input stream: "matrix_o[101]"
		for (int i = 0; i < aesl_tmp_592; i++)
		{
			matrix_o[101].write(aesl_tmp_591[i]);
		}

		// push back input stream: "matrix_o[102]"
		for (int i = 0; i < aesl_tmp_595; i++)
		{
			matrix_o[102].write(aesl_tmp_594[i]);
		}

		// push back input stream: "matrix_o[103]"
		for (int i = 0; i < aesl_tmp_598; i++)
		{
			matrix_o[103].write(aesl_tmp_597[i]);
		}

		// push back input stream: "matrix_o[104]"
		for (int i = 0; i < aesl_tmp_601; i++)
		{
			matrix_o[104].write(aesl_tmp_600[i]);
		}

		// push back input stream: "matrix_o[105]"
		for (int i = 0; i < aesl_tmp_604; i++)
		{
			matrix_o[105].write(aesl_tmp_603[i]);
		}

		// push back input stream: "matrix_o[106]"
		for (int i = 0; i < aesl_tmp_607; i++)
		{
			matrix_o[106].write(aesl_tmp_606[i]);
		}

		// push back input stream: "matrix_o[107]"
		for (int i = 0; i < aesl_tmp_610; i++)
		{
			matrix_o[107].write(aesl_tmp_609[i]);
		}

		// push back input stream: "matrix_o[108]"
		for (int i = 0; i < aesl_tmp_613; i++)
		{
			matrix_o[108].write(aesl_tmp_612[i]);
		}

		// push back input stream: "matrix_o[109]"
		for (int i = 0; i < aesl_tmp_616; i++)
		{
			matrix_o[109].write(aesl_tmp_615[i]);
		}

		// push back input stream: "matrix_o[110]"
		for (int i = 0; i < aesl_tmp_619; i++)
		{
			matrix_o[110].write(aesl_tmp_618[i]);
		}

		// push back input stream: "matrix_o[111]"
		for (int i = 0; i < aesl_tmp_622; i++)
		{
			matrix_o[111].write(aesl_tmp_621[i]);
		}

		// push back input stream: "matrix_o[112]"
		for (int i = 0; i < aesl_tmp_625; i++)
		{
			matrix_o[112].write(aesl_tmp_624[i]);
		}

		// push back input stream: "matrix_o[113]"
		for (int i = 0; i < aesl_tmp_628; i++)
		{
			matrix_o[113].write(aesl_tmp_627[i]);
		}

		// push back input stream: "matrix_o[114]"
		for (int i = 0; i < aesl_tmp_631; i++)
		{
			matrix_o[114].write(aesl_tmp_630[i]);
		}

		// push back input stream: "matrix_o[115]"
		for (int i = 0; i < aesl_tmp_634; i++)
		{
			matrix_o[115].write(aesl_tmp_633[i]);
		}

		// push back input stream: "matrix_o[116]"
		for (int i = 0; i < aesl_tmp_637; i++)
		{
			matrix_o[116].write(aesl_tmp_636[i]);
		}

		// push back input stream: "matrix_o[117]"
		for (int i = 0; i < aesl_tmp_640; i++)
		{
			matrix_o[117].write(aesl_tmp_639[i]);
		}

		// push back input stream: "matrix_o[118]"
		for (int i = 0; i < aesl_tmp_643; i++)
		{
			matrix_o[118].write(aesl_tmp_642[i]);
		}

		// push back input stream: "matrix_o[119]"
		for (int i = 0; i < aesl_tmp_646; i++)
		{
			matrix_o[119].write(aesl_tmp_645[i]);
		}

		// push back input stream: "matrix_o[120]"
		for (int i = 0; i < aesl_tmp_649; i++)
		{
			matrix_o[120].write(aesl_tmp_648[i]);
		}

		// push back input stream: "matrix_o[121]"
		for (int i = 0; i < aesl_tmp_652; i++)
		{
			matrix_o[121].write(aesl_tmp_651[i]);
		}

		// push back input stream: "matrix_o[122]"
		for (int i = 0; i < aesl_tmp_655; i++)
		{
			matrix_o[122].write(aesl_tmp_654[i]);
		}

		// push back input stream: "matrix_o[123]"
		for (int i = 0; i < aesl_tmp_658; i++)
		{
			matrix_o[123].write(aesl_tmp_657[i]);
		}

		// push back input stream: "matrix_o[124]"
		for (int i = 0; i < aesl_tmp_661; i++)
		{
			matrix_o[124].write(aesl_tmp_660[i]);
		}

		// push back input stream: "matrix_o[125]"
		for (int i = 0; i < aesl_tmp_664; i++)
		{
			matrix_o[125].write(aesl_tmp_663[i]);
		}

		// push back input stream: "matrix_o[126]"
		for (int i = 0; i < aesl_tmp_667; i++)
		{
			matrix_o[126].write(aesl_tmp_666[i]);
		}

		// push back input stream: "matrix_o[127]"
		for (int i = 0; i < aesl_tmp_670; i++)
		{
			matrix_o[127].write(aesl_tmp_669[i]);
		}

// [call_c_dut] ---------->

		AESL_ORIG_DUT_fire2(matrix_i, kernel_s1x1, kernel_e1x1, kernel_e3x3, matrix_o);

		// record input size to tv3: "matrix_i[0]"
		int aesl_tmp_2 = matrix_i[0].size();

		// record input size to tv3: "matrix_i[1]"
		int aesl_tmp_5 = matrix_i[1].size();

		// record input size to tv3: "matrix_i[2]"
		int aesl_tmp_8 = matrix_i[2].size();

		// record input size to tv3: "matrix_i[3]"
		int aesl_tmp_11 = matrix_i[3].size();

		// record input size to tv3: "matrix_i[4]"
		int aesl_tmp_14 = matrix_i[4].size();

		// record input size to tv3: "matrix_i[5]"
		int aesl_tmp_17 = matrix_i[5].size();

		// record input size to tv3: "matrix_i[6]"
		int aesl_tmp_20 = matrix_i[6].size();

		// record input size to tv3: "matrix_i[7]"
		int aesl_tmp_23 = matrix_i[7].size();

		// record input size to tv3: "matrix_i[8]"
		int aesl_tmp_26 = matrix_i[8].size();

		// record input size to tv3: "matrix_i[9]"
		int aesl_tmp_29 = matrix_i[9].size();

		// record input size to tv3: "matrix_i[10]"
		int aesl_tmp_32 = matrix_i[10].size();

		// record input size to tv3: "matrix_i[11]"
		int aesl_tmp_35 = matrix_i[11].size();

		// record input size to tv3: "matrix_i[12]"
		int aesl_tmp_38 = matrix_i[12].size();

		// record input size to tv3: "matrix_i[13]"
		int aesl_tmp_41 = matrix_i[13].size();

		// record input size to tv3: "matrix_i[14]"
		int aesl_tmp_44 = matrix_i[14].size();

		// record input size to tv3: "matrix_i[15]"
		int aesl_tmp_47 = matrix_i[15].size();

		// record input size to tv3: "matrix_i[16]"
		int aesl_tmp_50 = matrix_i[16].size();

		// record input size to tv3: "matrix_i[17]"
		int aesl_tmp_53 = matrix_i[17].size();

		// record input size to tv3: "matrix_i[18]"
		int aesl_tmp_56 = matrix_i[18].size();

		// record input size to tv3: "matrix_i[19]"
		int aesl_tmp_59 = matrix_i[19].size();

		// record input size to tv3: "matrix_i[20]"
		int aesl_tmp_62 = matrix_i[20].size();

		// record input size to tv3: "matrix_i[21]"
		int aesl_tmp_65 = matrix_i[21].size();

		// record input size to tv3: "matrix_i[22]"
		int aesl_tmp_68 = matrix_i[22].size();

		// record input size to tv3: "matrix_i[23]"
		int aesl_tmp_71 = matrix_i[23].size();

		// record input size to tv3: "matrix_i[24]"
		int aesl_tmp_74 = matrix_i[24].size();

		// record input size to tv3: "matrix_i[25]"
		int aesl_tmp_77 = matrix_i[25].size();

		// record input size to tv3: "matrix_i[26]"
		int aesl_tmp_80 = matrix_i[26].size();

		// record input size to tv3: "matrix_i[27]"
		int aesl_tmp_83 = matrix_i[27].size();

		// record input size to tv3: "matrix_i[28]"
		int aesl_tmp_86 = matrix_i[28].size();

		// record input size to tv3: "matrix_i[29]"
		int aesl_tmp_89 = matrix_i[29].size();

		// record input size to tv3: "matrix_i[30]"
		int aesl_tmp_92 = matrix_i[30].size();

		// record input size to tv3: "matrix_i[31]"
		int aesl_tmp_95 = matrix_i[31].size();

		// record input size to tv3: "matrix_i[32]"
		int aesl_tmp_98 = matrix_i[32].size();

		// record input size to tv3: "matrix_i[33]"
		int aesl_tmp_101 = matrix_i[33].size();

		// record input size to tv3: "matrix_i[34]"
		int aesl_tmp_104 = matrix_i[34].size();

		// record input size to tv3: "matrix_i[35]"
		int aesl_tmp_107 = matrix_i[35].size();

		// record input size to tv3: "matrix_i[36]"
		int aesl_tmp_110 = matrix_i[36].size();

		// record input size to tv3: "matrix_i[37]"
		int aesl_tmp_113 = matrix_i[37].size();

		// record input size to tv3: "matrix_i[38]"
		int aesl_tmp_116 = matrix_i[38].size();

		// record input size to tv3: "matrix_i[39]"
		int aesl_tmp_119 = matrix_i[39].size();

		// record input size to tv3: "matrix_i[40]"
		int aesl_tmp_122 = matrix_i[40].size();

		// record input size to tv3: "matrix_i[41]"
		int aesl_tmp_125 = matrix_i[41].size();

		// record input size to tv3: "matrix_i[42]"
		int aesl_tmp_128 = matrix_i[42].size();

		// record input size to tv3: "matrix_i[43]"
		int aesl_tmp_131 = matrix_i[43].size();

		// record input size to tv3: "matrix_i[44]"
		int aesl_tmp_134 = matrix_i[44].size();

		// record input size to tv3: "matrix_i[45]"
		int aesl_tmp_137 = matrix_i[45].size();

		// record input size to tv3: "matrix_i[46]"
		int aesl_tmp_140 = matrix_i[46].size();

		// record input size to tv3: "matrix_i[47]"
		int aesl_tmp_143 = matrix_i[47].size();

		// record input size to tv3: "matrix_i[48]"
		int aesl_tmp_146 = matrix_i[48].size();

		// record input size to tv3: "matrix_i[49]"
		int aesl_tmp_149 = matrix_i[49].size();

		// record input size to tv3: "matrix_i[50]"
		int aesl_tmp_152 = matrix_i[50].size();

		// record input size to tv3: "matrix_i[51]"
		int aesl_tmp_155 = matrix_i[51].size();

		// record input size to tv3: "matrix_i[52]"
		int aesl_tmp_158 = matrix_i[52].size();

		// record input size to tv3: "matrix_i[53]"
		int aesl_tmp_161 = matrix_i[53].size();

		// record input size to tv3: "matrix_i[54]"
		int aesl_tmp_164 = matrix_i[54].size();

		// record input size to tv3: "matrix_i[55]"
		int aesl_tmp_167 = matrix_i[55].size();

		// record input size to tv3: "matrix_i[56]"
		int aesl_tmp_170 = matrix_i[56].size();

		// record input size to tv3: "matrix_i[57]"
		int aesl_tmp_173 = matrix_i[57].size();

		// record input size to tv3: "matrix_i[58]"
		int aesl_tmp_176 = matrix_i[58].size();

		// record input size to tv3: "matrix_i[59]"
		int aesl_tmp_179 = matrix_i[59].size();

		// record input size to tv3: "matrix_i[60]"
		int aesl_tmp_182 = matrix_i[60].size();

		// record input size to tv3: "matrix_i[61]"
		int aesl_tmp_185 = matrix_i[61].size();

		// record input size to tv3: "matrix_i[62]"
		int aesl_tmp_188 = matrix_i[62].size();

		// record input size to tv3: "matrix_i[63]"
		int aesl_tmp_191 = matrix_i[63].size();

		// record input size to tv3: "matrix_i[64]"
		int aesl_tmp_194 = matrix_i[64].size();

		// record input size to tv3: "matrix_i[65]"
		int aesl_tmp_197 = matrix_i[65].size();

		// record input size to tv3: "matrix_i[66]"
		int aesl_tmp_200 = matrix_i[66].size();

		// record input size to tv3: "matrix_i[67]"
		int aesl_tmp_203 = matrix_i[67].size();

		// record input size to tv3: "matrix_i[68]"
		int aesl_tmp_206 = matrix_i[68].size();

		// record input size to tv3: "matrix_i[69]"
		int aesl_tmp_209 = matrix_i[69].size();

		// record input size to tv3: "matrix_i[70]"
		int aesl_tmp_212 = matrix_i[70].size();

		// record input size to tv3: "matrix_i[71]"
		int aesl_tmp_215 = matrix_i[71].size();

		// record input size to tv3: "matrix_i[72]"
		int aesl_tmp_218 = matrix_i[72].size();

		// record input size to tv3: "matrix_i[73]"
		int aesl_tmp_221 = matrix_i[73].size();

		// record input size to tv3: "matrix_i[74]"
		int aesl_tmp_224 = matrix_i[74].size();

		// record input size to tv3: "matrix_i[75]"
		int aesl_tmp_227 = matrix_i[75].size();

		// record input size to tv3: "matrix_i[76]"
		int aesl_tmp_230 = matrix_i[76].size();

		// record input size to tv3: "matrix_i[77]"
		int aesl_tmp_233 = matrix_i[77].size();

		// record input size to tv3: "matrix_i[78]"
		int aesl_tmp_236 = matrix_i[78].size();

		// record input size to tv3: "matrix_i[79]"
		int aesl_tmp_239 = matrix_i[79].size();

		// record input size to tv3: "matrix_i[80]"
		int aesl_tmp_242 = matrix_i[80].size();

		// record input size to tv3: "matrix_i[81]"
		int aesl_tmp_245 = matrix_i[81].size();

		// record input size to tv3: "matrix_i[82]"
		int aesl_tmp_248 = matrix_i[82].size();

		// record input size to tv3: "matrix_i[83]"
		int aesl_tmp_251 = matrix_i[83].size();

		// record input size to tv3: "matrix_i[84]"
		int aesl_tmp_254 = matrix_i[84].size();

		// record input size to tv3: "matrix_i[85]"
		int aesl_tmp_257 = matrix_i[85].size();

		// record input size to tv3: "matrix_i[86]"
		int aesl_tmp_260 = matrix_i[86].size();

		// record input size to tv3: "matrix_i[87]"
		int aesl_tmp_263 = matrix_i[87].size();

		// record input size to tv3: "matrix_i[88]"
		int aesl_tmp_266 = matrix_i[88].size();

		// record input size to tv3: "matrix_i[89]"
		int aesl_tmp_269 = matrix_i[89].size();

		// record input size to tv3: "matrix_i[90]"
		int aesl_tmp_272 = matrix_i[90].size();

		// record input size to tv3: "matrix_i[91]"
		int aesl_tmp_275 = matrix_i[91].size();

		// record input size to tv3: "matrix_i[92]"
		int aesl_tmp_278 = matrix_i[92].size();

		// record input size to tv3: "matrix_i[93]"
		int aesl_tmp_281 = matrix_i[93].size();

		// record input size to tv3: "matrix_i[94]"
		int aesl_tmp_284 = matrix_i[94].size();

		// record input size to tv3: "matrix_i[95]"
		int aesl_tmp_287 = matrix_i[95].size();

		// pop output stream: "matrix_o[0]"
		int aesl_tmp_290 = aesl_tmp_289;
		aesl_tmp_289 = 0;
     aesl_tmp_288.clear();
		while (!matrix_o[0].empty())
		{
			aesl_tmp_288.push_back(matrix_o[0].read());
			aesl_tmp_289++;
		}

		// pop output stream: "matrix_o[1]"
		int aesl_tmp_293 = aesl_tmp_292;
		aesl_tmp_292 = 0;
     aesl_tmp_291.clear();
		while (!matrix_o[1].empty())
		{
			aesl_tmp_291.push_back(matrix_o[1].read());
			aesl_tmp_292++;
		}

		// pop output stream: "matrix_o[2]"
		int aesl_tmp_296 = aesl_tmp_295;
		aesl_tmp_295 = 0;
     aesl_tmp_294.clear();
		while (!matrix_o[2].empty())
		{
			aesl_tmp_294.push_back(matrix_o[2].read());
			aesl_tmp_295++;
		}

		// pop output stream: "matrix_o[3]"
		int aesl_tmp_299 = aesl_tmp_298;
		aesl_tmp_298 = 0;
     aesl_tmp_297.clear();
		while (!matrix_o[3].empty())
		{
			aesl_tmp_297.push_back(matrix_o[3].read());
			aesl_tmp_298++;
		}

		// pop output stream: "matrix_o[4]"
		int aesl_tmp_302 = aesl_tmp_301;
		aesl_tmp_301 = 0;
     aesl_tmp_300.clear();
		while (!matrix_o[4].empty())
		{
			aesl_tmp_300.push_back(matrix_o[4].read());
			aesl_tmp_301++;
		}

		// pop output stream: "matrix_o[5]"
		int aesl_tmp_305 = aesl_tmp_304;
		aesl_tmp_304 = 0;
     aesl_tmp_303.clear();
		while (!matrix_o[5].empty())
		{
			aesl_tmp_303.push_back(matrix_o[5].read());
			aesl_tmp_304++;
		}

		// pop output stream: "matrix_o[6]"
		int aesl_tmp_308 = aesl_tmp_307;
		aesl_tmp_307 = 0;
     aesl_tmp_306.clear();
		while (!matrix_o[6].empty())
		{
			aesl_tmp_306.push_back(matrix_o[6].read());
			aesl_tmp_307++;
		}

		// pop output stream: "matrix_o[7]"
		int aesl_tmp_311 = aesl_tmp_310;
		aesl_tmp_310 = 0;
     aesl_tmp_309.clear();
		while (!matrix_o[7].empty())
		{
			aesl_tmp_309.push_back(matrix_o[7].read());
			aesl_tmp_310++;
		}

		// pop output stream: "matrix_o[8]"
		int aesl_tmp_314 = aesl_tmp_313;
		aesl_tmp_313 = 0;
     aesl_tmp_312.clear();
		while (!matrix_o[8].empty())
		{
			aesl_tmp_312.push_back(matrix_o[8].read());
			aesl_tmp_313++;
		}

		// pop output stream: "matrix_o[9]"
		int aesl_tmp_317 = aesl_tmp_316;
		aesl_tmp_316 = 0;
     aesl_tmp_315.clear();
		while (!matrix_o[9].empty())
		{
			aesl_tmp_315.push_back(matrix_o[9].read());
			aesl_tmp_316++;
		}

		// pop output stream: "matrix_o[10]"
		int aesl_tmp_320 = aesl_tmp_319;
		aesl_tmp_319 = 0;
     aesl_tmp_318.clear();
		while (!matrix_o[10].empty())
		{
			aesl_tmp_318.push_back(matrix_o[10].read());
			aesl_tmp_319++;
		}

		// pop output stream: "matrix_o[11]"
		int aesl_tmp_323 = aesl_tmp_322;
		aesl_tmp_322 = 0;
     aesl_tmp_321.clear();
		while (!matrix_o[11].empty())
		{
			aesl_tmp_321.push_back(matrix_o[11].read());
			aesl_tmp_322++;
		}

		// pop output stream: "matrix_o[12]"
		int aesl_tmp_326 = aesl_tmp_325;
		aesl_tmp_325 = 0;
     aesl_tmp_324.clear();
		while (!matrix_o[12].empty())
		{
			aesl_tmp_324.push_back(matrix_o[12].read());
			aesl_tmp_325++;
		}

		// pop output stream: "matrix_o[13]"
		int aesl_tmp_329 = aesl_tmp_328;
		aesl_tmp_328 = 0;
     aesl_tmp_327.clear();
		while (!matrix_o[13].empty())
		{
			aesl_tmp_327.push_back(matrix_o[13].read());
			aesl_tmp_328++;
		}

		// pop output stream: "matrix_o[14]"
		int aesl_tmp_332 = aesl_tmp_331;
		aesl_tmp_331 = 0;
     aesl_tmp_330.clear();
		while (!matrix_o[14].empty())
		{
			aesl_tmp_330.push_back(matrix_o[14].read());
			aesl_tmp_331++;
		}

		// pop output stream: "matrix_o[15]"
		int aesl_tmp_335 = aesl_tmp_334;
		aesl_tmp_334 = 0;
     aesl_tmp_333.clear();
		while (!matrix_o[15].empty())
		{
			aesl_tmp_333.push_back(matrix_o[15].read());
			aesl_tmp_334++;
		}

		// pop output stream: "matrix_o[16]"
		int aesl_tmp_338 = aesl_tmp_337;
		aesl_tmp_337 = 0;
     aesl_tmp_336.clear();
		while (!matrix_o[16].empty())
		{
			aesl_tmp_336.push_back(matrix_o[16].read());
			aesl_tmp_337++;
		}

		// pop output stream: "matrix_o[17]"
		int aesl_tmp_341 = aesl_tmp_340;
		aesl_tmp_340 = 0;
     aesl_tmp_339.clear();
		while (!matrix_o[17].empty())
		{
			aesl_tmp_339.push_back(matrix_o[17].read());
			aesl_tmp_340++;
		}

		// pop output stream: "matrix_o[18]"
		int aesl_tmp_344 = aesl_tmp_343;
		aesl_tmp_343 = 0;
     aesl_tmp_342.clear();
		while (!matrix_o[18].empty())
		{
			aesl_tmp_342.push_back(matrix_o[18].read());
			aesl_tmp_343++;
		}

		// pop output stream: "matrix_o[19]"
		int aesl_tmp_347 = aesl_tmp_346;
		aesl_tmp_346 = 0;
     aesl_tmp_345.clear();
		while (!matrix_o[19].empty())
		{
			aesl_tmp_345.push_back(matrix_o[19].read());
			aesl_tmp_346++;
		}

		// pop output stream: "matrix_o[20]"
		int aesl_tmp_350 = aesl_tmp_349;
		aesl_tmp_349 = 0;
     aesl_tmp_348.clear();
		while (!matrix_o[20].empty())
		{
			aesl_tmp_348.push_back(matrix_o[20].read());
			aesl_tmp_349++;
		}

		// pop output stream: "matrix_o[21]"
		int aesl_tmp_353 = aesl_tmp_352;
		aesl_tmp_352 = 0;
     aesl_tmp_351.clear();
		while (!matrix_o[21].empty())
		{
			aesl_tmp_351.push_back(matrix_o[21].read());
			aesl_tmp_352++;
		}

		// pop output stream: "matrix_o[22]"
		int aesl_tmp_356 = aesl_tmp_355;
		aesl_tmp_355 = 0;
     aesl_tmp_354.clear();
		while (!matrix_o[22].empty())
		{
			aesl_tmp_354.push_back(matrix_o[22].read());
			aesl_tmp_355++;
		}

		// pop output stream: "matrix_o[23]"
		int aesl_tmp_359 = aesl_tmp_358;
		aesl_tmp_358 = 0;
     aesl_tmp_357.clear();
		while (!matrix_o[23].empty())
		{
			aesl_tmp_357.push_back(matrix_o[23].read());
			aesl_tmp_358++;
		}

		// pop output stream: "matrix_o[24]"
		int aesl_tmp_362 = aesl_tmp_361;
		aesl_tmp_361 = 0;
     aesl_tmp_360.clear();
		while (!matrix_o[24].empty())
		{
			aesl_tmp_360.push_back(matrix_o[24].read());
			aesl_tmp_361++;
		}

		// pop output stream: "matrix_o[25]"
		int aesl_tmp_365 = aesl_tmp_364;
		aesl_tmp_364 = 0;
     aesl_tmp_363.clear();
		while (!matrix_o[25].empty())
		{
			aesl_tmp_363.push_back(matrix_o[25].read());
			aesl_tmp_364++;
		}

		// pop output stream: "matrix_o[26]"
		int aesl_tmp_368 = aesl_tmp_367;
		aesl_tmp_367 = 0;
     aesl_tmp_366.clear();
		while (!matrix_o[26].empty())
		{
			aesl_tmp_366.push_back(matrix_o[26].read());
			aesl_tmp_367++;
		}

		// pop output stream: "matrix_o[27]"
		int aesl_tmp_371 = aesl_tmp_370;
		aesl_tmp_370 = 0;
     aesl_tmp_369.clear();
		while (!matrix_o[27].empty())
		{
			aesl_tmp_369.push_back(matrix_o[27].read());
			aesl_tmp_370++;
		}

		// pop output stream: "matrix_o[28]"
		int aesl_tmp_374 = aesl_tmp_373;
		aesl_tmp_373 = 0;
     aesl_tmp_372.clear();
		while (!matrix_o[28].empty())
		{
			aesl_tmp_372.push_back(matrix_o[28].read());
			aesl_tmp_373++;
		}

		// pop output stream: "matrix_o[29]"
		int aesl_tmp_377 = aesl_tmp_376;
		aesl_tmp_376 = 0;
     aesl_tmp_375.clear();
		while (!matrix_o[29].empty())
		{
			aesl_tmp_375.push_back(matrix_o[29].read());
			aesl_tmp_376++;
		}

		// pop output stream: "matrix_o[30]"
		int aesl_tmp_380 = aesl_tmp_379;
		aesl_tmp_379 = 0;
     aesl_tmp_378.clear();
		while (!matrix_o[30].empty())
		{
			aesl_tmp_378.push_back(matrix_o[30].read());
			aesl_tmp_379++;
		}

		// pop output stream: "matrix_o[31]"
		int aesl_tmp_383 = aesl_tmp_382;
		aesl_tmp_382 = 0;
     aesl_tmp_381.clear();
		while (!matrix_o[31].empty())
		{
			aesl_tmp_381.push_back(matrix_o[31].read());
			aesl_tmp_382++;
		}

		// pop output stream: "matrix_o[32]"
		int aesl_tmp_386 = aesl_tmp_385;
		aesl_tmp_385 = 0;
     aesl_tmp_384.clear();
		while (!matrix_o[32].empty())
		{
			aesl_tmp_384.push_back(matrix_o[32].read());
			aesl_tmp_385++;
		}

		// pop output stream: "matrix_o[33]"
		int aesl_tmp_389 = aesl_tmp_388;
		aesl_tmp_388 = 0;
     aesl_tmp_387.clear();
		while (!matrix_o[33].empty())
		{
			aesl_tmp_387.push_back(matrix_o[33].read());
			aesl_tmp_388++;
		}

		// pop output stream: "matrix_o[34]"
		int aesl_tmp_392 = aesl_tmp_391;
		aesl_tmp_391 = 0;
     aesl_tmp_390.clear();
		while (!matrix_o[34].empty())
		{
			aesl_tmp_390.push_back(matrix_o[34].read());
			aesl_tmp_391++;
		}

		// pop output stream: "matrix_o[35]"
		int aesl_tmp_395 = aesl_tmp_394;
		aesl_tmp_394 = 0;
     aesl_tmp_393.clear();
		while (!matrix_o[35].empty())
		{
			aesl_tmp_393.push_back(matrix_o[35].read());
			aesl_tmp_394++;
		}

		// pop output stream: "matrix_o[36]"
		int aesl_tmp_398 = aesl_tmp_397;
		aesl_tmp_397 = 0;
     aesl_tmp_396.clear();
		while (!matrix_o[36].empty())
		{
			aesl_tmp_396.push_back(matrix_o[36].read());
			aesl_tmp_397++;
		}

		// pop output stream: "matrix_o[37]"
		int aesl_tmp_401 = aesl_tmp_400;
		aesl_tmp_400 = 0;
     aesl_tmp_399.clear();
		while (!matrix_o[37].empty())
		{
			aesl_tmp_399.push_back(matrix_o[37].read());
			aesl_tmp_400++;
		}

		// pop output stream: "matrix_o[38]"
		int aesl_tmp_404 = aesl_tmp_403;
		aesl_tmp_403 = 0;
     aesl_tmp_402.clear();
		while (!matrix_o[38].empty())
		{
			aesl_tmp_402.push_back(matrix_o[38].read());
			aesl_tmp_403++;
		}

		// pop output stream: "matrix_o[39]"
		int aesl_tmp_407 = aesl_tmp_406;
		aesl_tmp_406 = 0;
     aesl_tmp_405.clear();
		while (!matrix_o[39].empty())
		{
			aesl_tmp_405.push_back(matrix_o[39].read());
			aesl_tmp_406++;
		}

		// pop output stream: "matrix_o[40]"
		int aesl_tmp_410 = aesl_tmp_409;
		aesl_tmp_409 = 0;
     aesl_tmp_408.clear();
		while (!matrix_o[40].empty())
		{
			aesl_tmp_408.push_back(matrix_o[40].read());
			aesl_tmp_409++;
		}

		// pop output stream: "matrix_o[41]"
		int aesl_tmp_413 = aesl_tmp_412;
		aesl_tmp_412 = 0;
     aesl_tmp_411.clear();
		while (!matrix_o[41].empty())
		{
			aesl_tmp_411.push_back(matrix_o[41].read());
			aesl_tmp_412++;
		}

		// pop output stream: "matrix_o[42]"
		int aesl_tmp_416 = aesl_tmp_415;
		aesl_tmp_415 = 0;
     aesl_tmp_414.clear();
		while (!matrix_o[42].empty())
		{
			aesl_tmp_414.push_back(matrix_o[42].read());
			aesl_tmp_415++;
		}

		// pop output stream: "matrix_o[43]"
		int aesl_tmp_419 = aesl_tmp_418;
		aesl_tmp_418 = 0;
     aesl_tmp_417.clear();
		while (!matrix_o[43].empty())
		{
			aesl_tmp_417.push_back(matrix_o[43].read());
			aesl_tmp_418++;
		}

		// pop output stream: "matrix_o[44]"
		int aesl_tmp_422 = aesl_tmp_421;
		aesl_tmp_421 = 0;
     aesl_tmp_420.clear();
		while (!matrix_o[44].empty())
		{
			aesl_tmp_420.push_back(matrix_o[44].read());
			aesl_tmp_421++;
		}

		// pop output stream: "matrix_o[45]"
		int aesl_tmp_425 = aesl_tmp_424;
		aesl_tmp_424 = 0;
     aesl_tmp_423.clear();
		while (!matrix_o[45].empty())
		{
			aesl_tmp_423.push_back(matrix_o[45].read());
			aesl_tmp_424++;
		}

		// pop output stream: "matrix_o[46]"
		int aesl_tmp_428 = aesl_tmp_427;
		aesl_tmp_427 = 0;
     aesl_tmp_426.clear();
		while (!matrix_o[46].empty())
		{
			aesl_tmp_426.push_back(matrix_o[46].read());
			aesl_tmp_427++;
		}

		// pop output stream: "matrix_o[47]"
		int aesl_tmp_431 = aesl_tmp_430;
		aesl_tmp_430 = 0;
     aesl_tmp_429.clear();
		while (!matrix_o[47].empty())
		{
			aesl_tmp_429.push_back(matrix_o[47].read());
			aesl_tmp_430++;
		}

		// pop output stream: "matrix_o[48]"
		int aesl_tmp_434 = aesl_tmp_433;
		aesl_tmp_433 = 0;
     aesl_tmp_432.clear();
		while (!matrix_o[48].empty())
		{
			aesl_tmp_432.push_back(matrix_o[48].read());
			aesl_tmp_433++;
		}

		// pop output stream: "matrix_o[49]"
		int aesl_tmp_437 = aesl_tmp_436;
		aesl_tmp_436 = 0;
     aesl_tmp_435.clear();
		while (!matrix_o[49].empty())
		{
			aesl_tmp_435.push_back(matrix_o[49].read());
			aesl_tmp_436++;
		}

		// pop output stream: "matrix_o[50]"
		int aesl_tmp_440 = aesl_tmp_439;
		aesl_tmp_439 = 0;
     aesl_tmp_438.clear();
		while (!matrix_o[50].empty())
		{
			aesl_tmp_438.push_back(matrix_o[50].read());
			aesl_tmp_439++;
		}

		// pop output stream: "matrix_o[51]"
		int aesl_tmp_443 = aesl_tmp_442;
		aesl_tmp_442 = 0;
     aesl_tmp_441.clear();
		while (!matrix_o[51].empty())
		{
			aesl_tmp_441.push_back(matrix_o[51].read());
			aesl_tmp_442++;
		}

		// pop output stream: "matrix_o[52]"
		int aesl_tmp_446 = aesl_tmp_445;
		aesl_tmp_445 = 0;
     aesl_tmp_444.clear();
		while (!matrix_o[52].empty())
		{
			aesl_tmp_444.push_back(matrix_o[52].read());
			aesl_tmp_445++;
		}

		// pop output stream: "matrix_o[53]"
		int aesl_tmp_449 = aesl_tmp_448;
		aesl_tmp_448 = 0;
     aesl_tmp_447.clear();
		while (!matrix_o[53].empty())
		{
			aesl_tmp_447.push_back(matrix_o[53].read());
			aesl_tmp_448++;
		}

		// pop output stream: "matrix_o[54]"
		int aesl_tmp_452 = aesl_tmp_451;
		aesl_tmp_451 = 0;
     aesl_tmp_450.clear();
		while (!matrix_o[54].empty())
		{
			aesl_tmp_450.push_back(matrix_o[54].read());
			aesl_tmp_451++;
		}

		// pop output stream: "matrix_o[55]"
		int aesl_tmp_455 = aesl_tmp_454;
		aesl_tmp_454 = 0;
     aesl_tmp_453.clear();
		while (!matrix_o[55].empty())
		{
			aesl_tmp_453.push_back(matrix_o[55].read());
			aesl_tmp_454++;
		}

		// pop output stream: "matrix_o[56]"
		int aesl_tmp_458 = aesl_tmp_457;
		aesl_tmp_457 = 0;
     aesl_tmp_456.clear();
		while (!matrix_o[56].empty())
		{
			aesl_tmp_456.push_back(matrix_o[56].read());
			aesl_tmp_457++;
		}

		// pop output stream: "matrix_o[57]"
		int aesl_tmp_461 = aesl_tmp_460;
		aesl_tmp_460 = 0;
     aesl_tmp_459.clear();
		while (!matrix_o[57].empty())
		{
			aesl_tmp_459.push_back(matrix_o[57].read());
			aesl_tmp_460++;
		}

		// pop output stream: "matrix_o[58]"
		int aesl_tmp_464 = aesl_tmp_463;
		aesl_tmp_463 = 0;
     aesl_tmp_462.clear();
		while (!matrix_o[58].empty())
		{
			aesl_tmp_462.push_back(matrix_o[58].read());
			aesl_tmp_463++;
		}

		// pop output stream: "matrix_o[59]"
		int aesl_tmp_467 = aesl_tmp_466;
		aesl_tmp_466 = 0;
     aesl_tmp_465.clear();
		while (!matrix_o[59].empty())
		{
			aesl_tmp_465.push_back(matrix_o[59].read());
			aesl_tmp_466++;
		}

		// pop output stream: "matrix_o[60]"
		int aesl_tmp_470 = aesl_tmp_469;
		aesl_tmp_469 = 0;
     aesl_tmp_468.clear();
		while (!matrix_o[60].empty())
		{
			aesl_tmp_468.push_back(matrix_o[60].read());
			aesl_tmp_469++;
		}

		// pop output stream: "matrix_o[61]"
		int aesl_tmp_473 = aesl_tmp_472;
		aesl_tmp_472 = 0;
     aesl_tmp_471.clear();
		while (!matrix_o[61].empty())
		{
			aesl_tmp_471.push_back(matrix_o[61].read());
			aesl_tmp_472++;
		}

		// pop output stream: "matrix_o[62]"
		int aesl_tmp_476 = aesl_tmp_475;
		aesl_tmp_475 = 0;
     aesl_tmp_474.clear();
		while (!matrix_o[62].empty())
		{
			aesl_tmp_474.push_back(matrix_o[62].read());
			aesl_tmp_475++;
		}

		// pop output stream: "matrix_o[63]"
		int aesl_tmp_479 = aesl_tmp_478;
		aesl_tmp_478 = 0;
     aesl_tmp_477.clear();
		while (!matrix_o[63].empty())
		{
			aesl_tmp_477.push_back(matrix_o[63].read());
			aesl_tmp_478++;
		}

		// pop output stream: "matrix_o[64]"
		int aesl_tmp_482 = aesl_tmp_481;
		aesl_tmp_481 = 0;
     aesl_tmp_480.clear();
		while (!matrix_o[64].empty())
		{
			aesl_tmp_480.push_back(matrix_o[64].read());
			aesl_tmp_481++;
		}

		// pop output stream: "matrix_o[65]"
		int aesl_tmp_485 = aesl_tmp_484;
		aesl_tmp_484 = 0;
     aesl_tmp_483.clear();
		while (!matrix_o[65].empty())
		{
			aesl_tmp_483.push_back(matrix_o[65].read());
			aesl_tmp_484++;
		}

		// pop output stream: "matrix_o[66]"
		int aesl_tmp_488 = aesl_tmp_487;
		aesl_tmp_487 = 0;
     aesl_tmp_486.clear();
		while (!matrix_o[66].empty())
		{
			aesl_tmp_486.push_back(matrix_o[66].read());
			aesl_tmp_487++;
		}

		// pop output stream: "matrix_o[67]"
		int aesl_tmp_491 = aesl_tmp_490;
		aesl_tmp_490 = 0;
     aesl_tmp_489.clear();
		while (!matrix_o[67].empty())
		{
			aesl_tmp_489.push_back(matrix_o[67].read());
			aesl_tmp_490++;
		}

		// pop output stream: "matrix_o[68]"
		int aesl_tmp_494 = aesl_tmp_493;
		aesl_tmp_493 = 0;
     aesl_tmp_492.clear();
		while (!matrix_o[68].empty())
		{
			aesl_tmp_492.push_back(matrix_o[68].read());
			aesl_tmp_493++;
		}

		// pop output stream: "matrix_o[69]"
		int aesl_tmp_497 = aesl_tmp_496;
		aesl_tmp_496 = 0;
     aesl_tmp_495.clear();
		while (!matrix_o[69].empty())
		{
			aesl_tmp_495.push_back(matrix_o[69].read());
			aesl_tmp_496++;
		}

		// pop output stream: "matrix_o[70]"
		int aesl_tmp_500 = aesl_tmp_499;
		aesl_tmp_499 = 0;
     aesl_tmp_498.clear();
		while (!matrix_o[70].empty())
		{
			aesl_tmp_498.push_back(matrix_o[70].read());
			aesl_tmp_499++;
		}

		// pop output stream: "matrix_o[71]"
		int aesl_tmp_503 = aesl_tmp_502;
		aesl_tmp_502 = 0;
     aesl_tmp_501.clear();
		while (!matrix_o[71].empty())
		{
			aesl_tmp_501.push_back(matrix_o[71].read());
			aesl_tmp_502++;
		}

		// pop output stream: "matrix_o[72]"
		int aesl_tmp_506 = aesl_tmp_505;
		aesl_tmp_505 = 0;
     aesl_tmp_504.clear();
		while (!matrix_o[72].empty())
		{
			aesl_tmp_504.push_back(matrix_o[72].read());
			aesl_tmp_505++;
		}

		// pop output stream: "matrix_o[73]"
		int aesl_tmp_509 = aesl_tmp_508;
		aesl_tmp_508 = 0;
     aesl_tmp_507.clear();
		while (!matrix_o[73].empty())
		{
			aesl_tmp_507.push_back(matrix_o[73].read());
			aesl_tmp_508++;
		}

		// pop output stream: "matrix_o[74]"
		int aesl_tmp_512 = aesl_tmp_511;
		aesl_tmp_511 = 0;
     aesl_tmp_510.clear();
		while (!matrix_o[74].empty())
		{
			aesl_tmp_510.push_back(matrix_o[74].read());
			aesl_tmp_511++;
		}

		// pop output stream: "matrix_o[75]"
		int aesl_tmp_515 = aesl_tmp_514;
		aesl_tmp_514 = 0;
     aesl_tmp_513.clear();
		while (!matrix_o[75].empty())
		{
			aesl_tmp_513.push_back(matrix_o[75].read());
			aesl_tmp_514++;
		}

		// pop output stream: "matrix_o[76]"
		int aesl_tmp_518 = aesl_tmp_517;
		aesl_tmp_517 = 0;
     aesl_tmp_516.clear();
		while (!matrix_o[76].empty())
		{
			aesl_tmp_516.push_back(matrix_o[76].read());
			aesl_tmp_517++;
		}

		// pop output stream: "matrix_o[77]"
		int aesl_tmp_521 = aesl_tmp_520;
		aesl_tmp_520 = 0;
     aesl_tmp_519.clear();
		while (!matrix_o[77].empty())
		{
			aesl_tmp_519.push_back(matrix_o[77].read());
			aesl_tmp_520++;
		}

		// pop output stream: "matrix_o[78]"
		int aesl_tmp_524 = aesl_tmp_523;
		aesl_tmp_523 = 0;
     aesl_tmp_522.clear();
		while (!matrix_o[78].empty())
		{
			aesl_tmp_522.push_back(matrix_o[78].read());
			aesl_tmp_523++;
		}

		// pop output stream: "matrix_o[79]"
		int aesl_tmp_527 = aesl_tmp_526;
		aesl_tmp_526 = 0;
     aesl_tmp_525.clear();
		while (!matrix_o[79].empty())
		{
			aesl_tmp_525.push_back(matrix_o[79].read());
			aesl_tmp_526++;
		}

		// pop output stream: "matrix_o[80]"
		int aesl_tmp_530 = aesl_tmp_529;
		aesl_tmp_529 = 0;
     aesl_tmp_528.clear();
		while (!matrix_o[80].empty())
		{
			aesl_tmp_528.push_back(matrix_o[80].read());
			aesl_tmp_529++;
		}

		// pop output stream: "matrix_o[81]"
		int aesl_tmp_533 = aesl_tmp_532;
		aesl_tmp_532 = 0;
     aesl_tmp_531.clear();
		while (!matrix_o[81].empty())
		{
			aesl_tmp_531.push_back(matrix_o[81].read());
			aesl_tmp_532++;
		}

		// pop output stream: "matrix_o[82]"
		int aesl_tmp_536 = aesl_tmp_535;
		aesl_tmp_535 = 0;
     aesl_tmp_534.clear();
		while (!matrix_o[82].empty())
		{
			aesl_tmp_534.push_back(matrix_o[82].read());
			aesl_tmp_535++;
		}

		// pop output stream: "matrix_o[83]"
		int aesl_tmp_539 = aesl_tmp_538;
		aesl_tmp_538 = 0;
     aesl_tmp_537.clear();
		while (!matrix_o[83].empty())
		{
			aesl_tmp_537.push_back(matrix_o[83].read());
			aesl_tmp_538++;
		}

		// pop output stream: "matrix_o[84]"
		int aesl_tmp_542 = aesl_tmp_541;
		aesl_tmp_541 = 0;
     aesl_tmp_540.clear();
		while (!matrix_o[84].empty())
		{
			aesl_tmp_540.push_back(matrix_o[84].read());
			aesl_tmp_541++;
		}

		// pop output stream: "matrix_o[85]"
		int aesl_tmp_545 = aesl_tmp_544;
		aesl_tmp_544 = 0;
     aesl_tmp_543.clear();
		while (!matrix_o[85].empty())
		{
			aesl_tmp_543.push_back(matrix_o[85].read());
			aesl_tmp_544++;
		}

		// pop output stream: "matrix_o[86]"
		int aesl_tmp_548 = aesl_tmp_547;
		aesl_tmp_547 = 0;
     aesl_tmp_546.clear();
		while (!matrix_o[86].empty())
		{
			aesl_tmp_546.push_back(matrix_o[86].read());
			aesl_tmp_547++;
		}

		// pop output stream: "matrix_o[87]"
		int aesl_tmp_551 = aesl_tmp_550;
		aesl_tmp_550 = 0;
     aesl_tmp_549.clear();
		while (!matrix_o[87].empty())
		{
			aesl_tmp_549.push_back(matrix_o[87].read());
			aesl_tmp_550++;
		}

		// pop output stream: "matrix_o[88]"
		int aesl_tmp_554 = aesl_tmp_553;
		aesl_tmp_553 = 0;
     aesl_tmp_552.clear();
		while (!matrix_o[88].empty())
		{
			aesl_tmp_552.push_back(matrix_o[88].read());
			aesl_tmp_553++;
		}

		// pop output stream: "matrix_o[89]"
		int aesl_tmp_557 = aesl_tmp_556;
		aesl_tmp_556 = 0;
     aesl_tmp_555.clear();
		while (!matrix_o[89].empty())
		{
			aesl_tmp_555.push_back(matrix_o[89].read());
			aesl_tmp_556++;
		}

		// pop output stream: "matrix_o[90]"
		int aesl_tmp_560 = aesl_tmp_559;
		aesl_tmp_559 = 0;
     aesl_tmp_558.clear();
		while (!matrix_o[90].empty())
		{
			aesl_tmp_558.push_back(matrix_o[90].read());
			aesl_tmp_559++;
		}

		// pop output stream: "matrix_o[91]"
		int aesl_tmp_563 = aesl_tmp_562;
		aesl_tmp_562 = 0;
     aesl_tmp_561.clear();
		while (!matrix_o[91].empty())
		{
			aesl_tmp_561.push_back(matrix_o[91].read());
			aesl_tmp_562++;
		}

		// pop output stream: "matrix_o[92]"
		int aesl_tmp_566 = aesl_tmp_565;
		aesl_tmp_565 = 0;
     aesl_tmp_564.clear();
		while (!matrix_o[92].empty())
		{
			aesl_tmp_564.push_back(matrix_o[92].read());
			aesl_tmp_565++;
		}

		// pop output stream: "matrix_o[93]"
		int aesl_tmp_569 = aesl_tmp_568;
		aesl_tmp_568 = 0;
     aesl_tmp_567.clear();
		while (!matrix_o[93].empty())
		{
			aesl_tmp_567.push_back(matrix_o[93].read());
			aesl_tmp_568++;
		}

		// pop output stream: "matrix_o[94]"
		int aesl_tmp_572 = aesl_tmp_571;
		aesl_tmp_571 = 0;
     aesl_tmp_570.clear();
		while (!matrix_o[94].empty())
		{
			aesl_tmp_570.push_back(matrix_o[94].read());
			aesl_tmp_571++;
		}

		// pop output stream: "matrix_o[95]"
		int aesl_tmp_575 = aesl_tmp_574;
		aesl_tmp_574 = 0;
     aesl_tmp_573.clear();
		while (!matrix_o[95].empty())
		{
			aesl_tmp_573.push_back(matrix_o[95].read());
			aesl_tmp_574++;
		}

		// pop output stream: "matrix_o[96]"
		int aesl_tmp_578 = aesl_tmp_577;
		aesl_tmp_577 = 0;
     aesl_tmp_576.clear();
		while (!matrix_o[96].empty())
		{
			aesl_tmp_576.push_back(matrix_o[96].read());
			aesl_tmp_577++;
		}

		// pop output stream: "matrix_o[97]"
		int aesl_tmp_581 = aesl_tmp_580;
		aesl_tmp_580 = 0;
     aesl_tmp_579.clear();
		while (!matrix_o[97].empty())
		{
			aesl_tmp_579.push_back(matrix_o[97].read());
			aesl_tmp_580++;
		}

		// pop output stream: "matrix_o[98]"
		int aesl_tmp_584 = aesl_tmp_583;
		aesl_tmp_583 = 0;
     aesl_tmp_582.clear();
		while (!matrix_o[98].empty())
		{
			aesl_tmp_582.push_back(matrix_o[98].read());
			aesl_tmp_583++;
		}

		// pop output stream: "matrix_o[99]"
		int aesl_tmp_587 = aesl_tmp_586;
		aesl_tmp_586 = 0;
     aesl_tmp_585.clear();
		while (!matrix_o[99].empty())
		{
			aesl_tmp_585.push_back(matrix_o[99].read());
			aesl_tmp_586++;
		}

		// pop output stream: "matrix_o[100]"
		int aesl_tmp_590 = aesl_tmp_589;
		aesl_tmp_589 = 0;
     aesl_tmp_588.clear();
		while (!matrix_o[100].empty())
		{
			aesl_tmp_588.push_back(matrix_o[100].read());
			aesl_tmp_589++;
		}

		// pop output stream: "matrix_o[101]"
		int aesl_tmp_593 = aesl_tmp_592;
		aesl_tmp_592 = 0;
     aesl_tmp_591.clear();
		while (!matrix_o[101].empty())
		{
			aesl_tmp_591.push_back(matrix_o[101].read());
			aesl_tmp_592++;
		}

		// pop output stream: "matrix_o[102]"
		int aesl_tmp_596 = aesl_tmp_595;
		aesl_tmp_595 = 0;
     aesl_tmp_594.clear();
		while (!matrix_o[102].empty())
		{
			aesl_tmp_594.push_back(matrix_o[102].read());
			aesl_tmp_595++;
		}

		// pop output stream: "matrix_o[103]"
		int aesl_tmp_599 = aesl_tmp_598;
		aesl_tmp_598 = 0;
     aesl_tmp_597.clear();
		while (!matrix_o[103].empty())
		{
			aesl_tmp_597.push_back(matrix_o[103].read());
			aesl_tmp_598++;
		}

		// pop output stream: "matrix_o[104]"
		int aesl_tmp_602 = aesl_tmp_601;
		aesl_tmp_601 = 0;
     aesl_tmp_600.clear();
		while (!matrix_o[104].empty())
		{
			aesl_tmp_600.push_back(matrix_o[104].read());
			aesl_tmp_601++;
		}

		// pop output stream: "matrix_o[105]"
		int aesl_tmp_605 = aesl_tmp_604;
		aesl_tmp_604 = 0;
     aesl_tmp_603.clear();
		while (!matrix_o[105].empty())
		{
			aesl_tmp_603.push_back(matrix_o[105].read());
			aesl_tmp_604++;
		}

		// pop output stream: "matrix_o[106]"
		int aesl_tmp_608 = aesl_tmp_607;
		aesl_tmp_607 = 0;
     aesl_tmp_606.clear();
		while (!matrix_o[106].empty())
		{
			aesl_tmp_606.push_back(matrix_o[106].read());
			aesl_tmp_607++;
		}

		// pop output stream: "matrix_o[107]"
		int aesl_tmp_611 = aesl_tmp_610;
		aesl_tmp_610 = 0;
     aesl_tmp_609.clear();
		while (!matrix_o[107].empty())
		{
			aesl_tmp_609.push_back(matrix_o[107].read());
			aesl_tmp_610++;
		}

		// pop output stream: "matrix_o[108]"
		int aesl_tmp_614 = aesl_tmp_613;
		aesl_tmp_613 = 0;
     aesl_tmp_612.clear();
		while (!matrix_o[108].empty())
		{
			aesl_tmp_612.push_back(matrix_o[108].read());
			aesl_tmp_613++;
		}

		// pop output stream: "matrix_o[109]"
		int aesl_tmp_617 = aesl_tmp_616;
		aesl_tmp_616 = 0;
     aesl_tmp_615.clear();
		while (!matrix_o[109].empty())
		{
			aesl_tmp_615.push_back(matrix_o[109].read());
			aesl_tmp_616++;
		}

		// pop output stream: "matrix_o[110]"
		int aesl_tmp_620 = aesl_tmp_619;
		aesl_tmp_619 = 0;
     aesl_tmp_618.clear();
		while (!matrix_o[110].empty())
		{
			aesl_tmp_618.push_back(matrix_o[110].read());
			aesl_tmp_619++;
		}

		// pop output stream: "matrix_o[111]"
		int aesl_tmp_623 = aesl_tmp_622;
		aesl_tmp_622 = 0;
     aesl_tmp_621.clear();
		while (!matrix_o[111].empty())
		{
			aesl_tmp_621.push_back(matrix_o[111].read());
			aesl_tmp_622++;
		}

		// pop output stream: "matrix_o[112]"
		int aesl_tmp_626 = aesl_tmp_625;
		aesl_tmp_625 = 0;
     aesl_tmp_624.clear();
		while (!matrix_o[112].empty())
		{
			aesl_tmp_624.push_back(matrix_o[112].read());
			aesl_tmp_625++;
		}

		// pop output stream: "matrix_o[113]"
		int aesl_tmp_629 = aesl_tmp_628;
		aesl_tmp_628 = 0;
     aesl_tmp_627.clear();
		while (!matrix_o[113].empty())
		{
			aesl_tmp_627.push_back(matrix_o[113].read());
			aesl_tmp_628++;
		}

		// pop output stream: "matrix_o[114]"
		int aesl_tmp_632 = aesl_tmp_631;
		aesl_tmp_631 = 0;
     aesl_tmp_630.clear();
		while (!matrix_o[114].empty())
		{
			aesl_tmp_630.push_back(matrix_o[114].read());
			aesl_tmp_631++;
		}

		// pop output stream: "matrix_o[115]"
		int aesl_tmp_635 = aesl_tmp_634;
		aesl_tmp_634 = 0;
     aesl_tmp_633.clear();
		while (!matrix_o[115].empty())
		{
			aesl_tmp_633.push_back(matrix_o[115].read());
			aesl_tmp_634++;
		}

		// pop output stream: "matrix_o[116]"
		int aesl_tmp_638 = aesl_tmp_637;
		aesl_tmp_637 = 0;
     aesl_tmp_636.clear();
		while (!matrix_o[116].empty())
		{
			aesl_tmp_636.push_back(matrix_o[116].read());
			aesl_tmp_637++;
		}

		// pop output stream: "matrix_o[117]"
		int aesl_tmp_641 = aesl_tmp_640;
		aesl_tmp_640 = 0;
     aesl_tmp_639.clear();
		while (!matrix_o[117].empty())
		{
			aesl_tmp_639.push_back(matrix_o[117].read());
			aesl_tmp_640++;
		}

		// pop output stream: "matrix_o[118]"
		int aesl_tmp_644 = aesl_tmp_643;
		aesl_tmp_643 = 0;
     aesl_tmp_642.clear();
		while (!matrix_o[118].empty())
		{
			aesl_tmp_642.push_back(matrix_o[118].read());
			aesl_tmp_643++;
		}

		// pop output stream: "matrix_o[119]"
		int aesl_tmp_647 = aesl_tmp_646;
		aesl_tmp_646 = 0;
     aesl_tmp_645.clear();
		while (!matrix_o[119].empty())
		{
			aesl_tmp_645.push_back(matrix_o[119].read());
			aesl_tmp_646++;
		}

		// pop output stream: "matrix_o[120]"
		int aesl_tmp_650 = aesl_tmp_649;
		aesl_tmp_649 = 0;
     aesl_tmp_648.clear();
		while (!matrix_o[120].empty())
		{
			aesl_tmp_648.push_back(matrix_o[120].read());
			aesl_tmp_649++;
		}

		// pop output stream: "matrix_o[121]"
		int aesl_tmp_653 = aesl_tmp_652;
		aesl_tmp_652 = 0;
     aesl_tmp_651.clear();
		while (!matrix_o[121].empty())
		{
			aesl_tmp_651.push_back(matrix_o[121].read());
			aesl_tmp_652++;
		}

		// pop output stream: "matrix_o[122]"
		int aesl_tmp_656 = aesl_tmp_655;
		aesl_tmp_655 = 0;
     aesl_tmp_654.clear();
		while (!matrix_o[122].empty())
		{
			aesl_tmp_654.push_back(matrix_o[122].read());
			aesl_tmp_655++;
		}

		// pop output stream: "matrix_o[123]"
		int aesl_tmp_659 = aesl_tmp_658;
		aesl_tmp_658 = 0;
     aesl_tmp_657.clear();
		while (!matrix_o[123].empty())
		{
			aesl_tmp_657.push_back(matrix_o[123].read());
			aesl_tmp_658++;
		}

		// pop output stream: "matrix_o[124]"
		int aesl_tmp_662 = aesl_tmp_661;
		aesl_tmp_661 = 0;
     aesl_tmp_660.clear();
		while (!matrix_o[124].empty())
		{
			aesl_tmp_660.push_back(matrix_o[124].read());
			aesl_tmp_661++;
		}

		// pop output stream: "matrix_o[125]"
		int aesl_tmp_665 = aesl_tmp_664;
		aesl_tmp_664 = 0;
     aesl_tmp_663.clear();
		while (!matrix_o[125].empty())
		{
			aesl_tmp_663.push_back(matrix_o[125].read());
			aesl_tmp_664++;
		}

		// pop output stream: "matrix_o[126]"
		int aesl_tmp_668 = aesl_tmp_667;
		aesl_tmp_667 = 0;
     aesl_tmp_666.clear();
		while (!matrix_o[126].empty())
		{
			aesl_tmp_666.push_back(matrix_o[126].read());
			aesl_tmp_667++;
		}

		// pop output stream: "matrix_o[127]"
		int aesl_tmp_671 = aesl_tmp_670;
		aesl_tmp_670 = 0;
     aesl_tmp_669.clear();
		while (!matrix_o[127].empty())
		{
			aesl_tmp_669.push_back(matrix_o[127].read());
			aesl_tmp_670++;
		}

		// [[transaction]]
		sprintf(tvin_matrix_i_0_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_0_V, tvin_matrix_i_0_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V, tvin_matrix_i_0_V);

		sc_bv<16>* matrix_i_0_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_1 - aesl_tmp_2];

		// RTL Name: matrix_i_0_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_1 - aesl_tmp_2 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_1 - aesl_tmp_2 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_0[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_0[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_0[i_0]
						if (&(aesl_tmp_0[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_0[i_0];
							matrix_i_0_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_1 - aesl_tmp_2; i++)
		{
			sprintf(tvin_matrix_i_0_V, "%s\n", (matrix_i_0_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_0_V, tvin_matrix_i_0_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_0_V = aesl_tmp_1;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V, stream_ingress_size_matrix_i_0_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V, "\n");

		for (int i = 0; i < aesl_tmp_1 - aesl_tmp_2; i++)
		{
			stream_ingress_size_matrix_i_0_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V, stream_ingress_size_matrix_i_0_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_1 - aesl_tmp_2, &tcl_file.matrix_i_0_V_depth);
		sprintf(tvin_matrix_i_0_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_0_V, tvin_matrix_i_0_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_0_V, tvin_matrix_i_0_V);

		// release memory allocation
		delete [] matrix_i_0_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_0_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, wrapc_stream_size_in_matrix_i_0_V);
		sprintf(wrapc_stream_size_in_matrix_i_0_V, "%d\n", aesl_tmp_1 - aesl_tmp_2);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, wrapc_stream_size_in_matrix_i_0_V);
		sprintf(wrapc_stream_size_in_matrix_i_0_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_0_V, wrapc_stream_size_in_matrix_i_0_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_1_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_1_V, tvin_matrix_i_1_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V, tvin_matrix_i_1_V);

		sc_bv<16>* matrix_i_1_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_4 - aesl_tmp_5];

		// RTL Name: matrix_i_1_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_4 - aesl_tmp_5 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_4 - aesl_tmp_5 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_3[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_3[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_3[i_0]
						if (&(aesl_tmp_3[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_3[i_0];
							matrix_i_1_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_4 - aesl_tmp_5; i++)
		{
			sprintf(tvin_matrix_i_1_V, "%s\n", (matrix_i_1_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_1_V, tvin_matrix_i_1_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_1_V = aesl_tmp_4;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V, stream_ingress_size_matrix_i_1_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V, "\n");

		for (int i = 0; i < aesl_tmp_4 - aesl_tmp_5; i++)
		{
			stream_ingress_size_matrix_i_1_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V, stream_ingress_size_matrix_i_1_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_4 - aesl_tmp_5, &tcl_file.matrix_i_1_V_depth);
		sprintf(tvin_matrix_i_1_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_1_V, tvin_matrix_i_1_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_1_V, tvin_matrix_i_1_V);

		// release memory allocation
		delete [] matrix_i_1_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_1_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_1_V, wrapc_stream_size_in_matrix_i_1_V);
		sprintf(wrapc_stream_size_in_matrix_i_1_V, "%d\n", aesl_tmp_4 - aesl_tmp_5);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_1_V, wrapc_stream_size_in_matrix_i_1_V);
		sprintf(wrapc_stream_size_in_matrix_i_1_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_1_V, wrapc_stream_size_in_matrix_i_1_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_2_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_2_V, tvin_matrix_i_2_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V, tvin_matrix_i_2_V);

		sc_bv<16>* matrix_i_2_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_7 - aesl_tmp_8];

		// RTL Name: matrix_i_2_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_7 - aesl_tmp_8 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_7 - aesl_tmp_8 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_6[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_6[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_6[i_0]
						if (&(aesl_tmp_6[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_6[i_0];
							matrix_i_2_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_7 - aesl_tmp_8; i++)
		{
			sprintf(tvin_matrix_i_2_V, "%s\n", (matrix_i_2_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_2_V, tvin_matrix_i_2_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_2_V = aesl_tmp_7;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V, stream_ingress_size_matrix_i_2_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V, "\n");

		for (int i = 0; i < aesl_tmp_7 - aesl_tmp_8; i++)
		{
			stream_ingress_size_matrix_i_2_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V, stream_ingress_size_matrix_i_2_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_7 - aesl_tmp_8, &tcl_file.matrix_i_2_V_depth);
		sprintf(tvin_matrix_i_2_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_2_V, tvin_matrix_i_2_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_2_V, tvin_matrix_i_2_V);

		// release memory allocation
		delete [] matrix_i_2_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_2_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_2_V, wrapc_stream_size_in_matrix_i_2_V);
		sprintf(wrapc_stream_size_in_matrix_i_2_V, "%d\n", aesl_tmp_7 - aesl_tmp_8);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_2_V, wrapc_stream_size_in_matrix_i_2_V);
		sprintf(wrapc_stream_size_in_matrix_i_2_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_2_V, wrapc_stream_size_in_matrix_i_2_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_3_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_3_V, tvin_matrix_i_3_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V, tvin_matrix_i_3_V);

		sc_bv<16>* matrix_i_3_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_10 - aesl_tmp_11];

		// RTL Name: matrix_i_3_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_10 - aesl_tmp_11 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_10 - aesl_tmp_11 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_9[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_9[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_9[i_0]
						if (&(aesl_tmp_9[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_9[i_0];
							matrix_i_3_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_10 - aesl_tmp_11; i++)
		{
			sprintf(tvin_matrix_i_3_V, "%s\n", (matrix_i_3_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_3_V, tvin_matrix_i_3_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_3_V = aesl_tmp_10;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V, stream_ingress_size_matrix_i_3_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V, "\n");

		for (int i = 0; i < aesl_tmp_10 - aesl_tmp_11; i++)
		{
			stream_ingress_size_matrix_i_3_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V, stream_ingress_size_matrix_i_3_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_10 - aesl_tmp_11, &tcl_file.matrix_i_3_V_depth);
		sprintf(tvin_matrix_i_3_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_3_V, tvin_matrix_i_3_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_3_V, tvin_matrix_i_3_V);

		// release memory allocation
		delete [] matrix_i_3_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_3_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_3_V, wrapc_stream_size_in_matrix_i_3_V);
		sprintf(wrapc_stream_size_in_matrix_i_3_V, "%d\n", aesl_tmp_10 - aesl_tmp_11);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_3_V, wrapc_stream_size_in_matrix_i_3_V);
		sprintf(wrapc_stream_size_in_matrix_i_3_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_3_V, wrapc_stream_size_in_matrix_i_3_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_4_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_4_V, tvin_matrix_i_4_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V, tvin_matrix_i_4_V);

		sc_bv<16>* matrix_i_4_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_13 - aesl_tmp_14];

		// RTL Name: matrix_i_4_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_13 - aesl_tmp_14 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_13 - aesl_tmp_14 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_12[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_12[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_12[i_0]
						if (&(aesl_tmp_12[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_12[i_0];
							matrix_i_4_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_13 - aesl_tmp_14; i++)
		{
			sprintf(tvin_matrix_i_4_V, "%s\n", (matrix_i_4_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_4_V, tvin_matrix_i_4_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_4_V = aesl_tmp_13;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V, stream_ingress_size_matrix_i_4_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V, "\n");

		for (int i = 0; i < aesl_tmp_13 - aesl_tmp_14; i++)
		{
			stream_ingress_size_matrix_i_4_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V, stream_ingress_size_matrix_i_4_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_13 - aesl_tmp_14, &tcl_file.matrix_i_4_V_depth);
		sprintf(tvin_matrix_i_4_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_4_V, tvin_matrix_i_4_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_4_V, tvin_matrix_i_4_V);

		// release memory allocation
		delete [] matrix_i_4_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_4_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_4_V, wrapc_stream_size_in_matrix_i_4_V);
		sprintf(wrapc_stream_size_in_matrix_i_4_V, "%d\n", aesl_tmp_13 - aesl_tmp_14);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_4_V, wrapc_stream_size_in_matrix_i_4_V);
		sprintf(wrapc_stream_size_in_matrix_i_4_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_4_V, wrapc_stream_size_in_matrix_i_4_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_5_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_5_V, tvin_matrix_i_5_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V, tvin_matrix_i_5_V);

		sc_bv<16>* matrix_i_5_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_16 - aesl_tmp_17];

		// RTL Name: matrix_i_5_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_16 - aesl_tmp_17 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_16 - aesl_tmp_17 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_15[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_15[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_15[i_0]
						if (&(aesl_tmp_15[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_15[i_0];
							matrix_i_5_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_16 - aesl_tmp_17; i++)
		{
			sprintf(tvin_matrix_i_5_V, "%s\n", (matrix_i_5_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_5_V, tvin_matrix_i_5_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_5_V = aesl_tmp_16;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V, stream_ingress_size_matrix_i_5_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V, "\n");

		for (int i = 0; i < aesl_tmp_16 - aesl_tmp_17; i++)
		{
			stream_ingress_size_matrix_i_5_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V, stream_ingress_size_matrix_i_5_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_16 - aesl_tmp_17, &tcl_file.matrix_i_5_V_depth);
		sprintf(tvin_matrix_i_5_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_5_V, tvin_matrix_i_5_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_5_V, tvin_matrix_i_5_V);

		// release memory allocation
		delete [] matrix_i_5_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_5_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_5_V, wrapc_stream_size_in_matrix_i_5_V);
		sprintf(wrapc_stream_size_in_matrix_i_5_V, "%d\n", aesl_tmp_16 - aesl_tmp_17);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_5_V, wrapc_stream_size_in_matrix_i_5_V);
		sprintf(wrapc_stream_size_in_matrix_i_5_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_5_V, wrapc_stream_size_in_matrix_i_5_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_6_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_6_V, tvin_matrix_i_6_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V, tvin_matrix_i_6_V);

		sc_bv<16>* matrix_i_6_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_19 - aesl_tmp_20];

		// RTL Name: matrix_i_6_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_19 - aesl_tmp_20 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_19 - aesl_tmp_20 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_18[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_18[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_18[i_0]
						if (&(aesl_tmp_18[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_18[i_0];
							matrix_i_6_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_19 - aesl_tmp_20; i++)
		{
			sprintf(tvin_matrix_i_6_V, "%s\n", (matrix_i_6_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_6_V, tvin_matrix_i_6_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_6_V = aesl_tmp_19;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V, stream_ingress_size_matrix_i_6_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V, "\n");

		for (int i = 0; i < aesl_tmp_19 - aesl_tmp_20; i++)
		{
			stream_ingress_size_matrix_i_6_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V, stream_ingress_size_matrix_i_6_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_19 - aesl_tmp_20, &tcl_file.matrix_i_6_V_depth);
		sprintf(tvin_matrix_i_6_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_6_V, tvin_matrix_i_6_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_6_V, tvin_matrix_i_6_V);

		// release memory allocation
		delete [] matrix_i_6_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_6_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_6_V, wrapc_stream_size_in_matrix_i_6_V);
		sprintf(wrapc_stream_size_in_matrix_i_6_V, "%d\n", aesl_tmp_19 - aesl_tmp_20);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_6_V, wrapc_stream_size_in_matrix_i_6_V);
		sprintf(wrapc_stream_size_in_matrix_i_6_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_6_V, wrapc_stream_size_in_matrix_i_6_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_7_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_7_V, tvin_matrix_i_7_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V, tvin_matrix_i_7_V);

		sc_bv<16>* matrix_i_7_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_22 - aesl_tmp_23];

		// RTL Name: matrix_i_7_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_22 - aesl_tmp_23 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_22 - aesl_tmp_23 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_21[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_21[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_21[i_0]
						if (&(aesl_tmp_21[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_21[i_0];
							matrix_i_7_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_22 - aesl_tmp_23; i++)
		{
			sprintf(tvin_matrix_i_7_V, "%s\n", (matrix_i_7_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_7_V, tvin_matrix_i_7_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_7_V = aesl_tmp_22;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V, stream_ingress_size_matrix_i_7_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V, "\n");

		for (int i = 0; i < aesl_tmp_22 - aesl_tmp_23; i++)
		{
			stream_ingress_size_matrix_i_7_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V, stream_ingress_size_matrix_i_7_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_22 - aesl_tmp_23, &tcl_file.matrix_i_7_V_depth);
		sprintf(tvin_matrix_i_7_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_7_V, tvin_matrix_i_7_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_7_V, tvin_matrix_i_7_V);

		// release memory allocation
		delete [] matrix_i_7_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_7_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_7_V, wrapc_stream_size_in_matrix_i_7_V);
		sprintf(wrapc_stream_size_in_matrix_i_7_V, "%d\n", aesl_tmp_22 - aesl_tmp_23);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_7_V, wrapc_stream_size_in_matrix_i_7_V);
		sprintf(wrapc_stream_size_in_matrix_i_7_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_7_V, wrapc_stream_size_in_matrix_i_7_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_8_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_8_V, tvin_matrix_i_8_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V, tvin_matrix_i_8_V);

		sc_bv<16>* matrix_i_8_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_25 - aesl_tmp_26];

		// RTL Name: matrix_i_8_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_25 - aesl_tmp_26 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_25 - aesl_tmp_26 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_24[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_24[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_24[i_0]
						if (&(aesl_tmp_24[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_24[i_0];
							matrix_i_8_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_25 - aesl_tmp_26; i++)
		{
			sprintf(tvin_matrix_i_8_V, "%s\n", (matrix_i_8_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_8_V, tvin_matrix_i_8_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_8_V = aesl_tmp_25;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V, stream_ingress_size_matrix_i_8_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V, "\n");

		for (int i = 0; i < aesl_tmp_25 - aesl_tmp_26; i++)
		{
			stream_ingress_size_matrix_i_8_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V, stream_ingress_size_matrix_i_8_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_25 - aesl_tmp_26, &tcl_file.matrix_i_8_V_depth);
		sprintf(tvin_matrix_i_8_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_8_V, tvin_matrix_i_8_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_8_V, tvin_matrix_i_8_V);

		// release memory allocation
		delete [] matrix_i_8_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_8_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_8_V, wrapc_stream_size_in_matrix_i_8_V);
		sprintf(wrapc_stream_size_in_matrix_i_8_V, "%d\n", aesl_tmp_25 - aesl_tmp_26);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_8_V, wrapc_stream_size_in_matrix_i_8_V);
		sprintf(wrapc_stream_size_in_matrix_i_8_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_8_V, wrapc_stream_size_in_matrix_i_8_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_9_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_9_V, tvin_matrix_i_9_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V, tvin_matrix_i_9_V);

		sc_bv<16>* matrix_i_9_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_28 - aesl_tmp_29];

		// RTL Name: matrix_i_9_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_28 - aesl_tmp_29 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_28 - aesl_tmp_29 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_27[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_27[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_27[i_0]
						if (&(aesl_tmp_27[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_27[i_0];
							matrix_i_9_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_28 - aesl_tmp_29; i++)
		{
			sprintf(tvin_matrix_i_9_V, "%s\n", (matrix_i_9_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_9_V, tvin_matrix_i_9_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_9_V = aesl_tmp_28;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V, stream_ingress_size_matrix_i_9_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V, "\n");

		for (int i = 0; i < aesl_tmp_28 - aesl_tmp_29; i++)
		{
			stream_ingress_size_matrix_i_9_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V, stream_ingress_size_matrix_i_9_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_28 - aesl_tmp_29, &tcl_file.matrix_i_9_V_depth);
		sprintf(tvin_matrix_i_9_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_9_V, tvin_matrix_i_9_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_9_V, tvin_matrix_i_9_V);

		// release memory allocation
		delete [] matrix_i_9_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_9_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_9_V, wrapc_stream_size_in_matrix_i_9_V);
		sprintf(wrapc_stream_size_in_matrix_i_9_V, "%d\n", aesl_tmp_28 - aesl_tmp_29);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_9_V, wrapc_stream_size_in_matrix_i_9_V);
		sprintf(wrapc_stream_size_in_matrix_i_9_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_9_V, wrapc_stream_size_in_matrix_i_9_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_10_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_10_V, tvin_matrix_i_10_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V, tvin_matrix_i_10_V);

		sc_bv<16>* matrix_i_10_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_31 - aesl_tmp_32];

		// RTL Name: matrix_i_10_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_31 - aesl_tmp_32 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_31 - aesl_tmp_32 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_30[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_30[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_30[i_0]
						if (&(aesl_tmp_30[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_30[i_0];
							matrix_i_10_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_31 - aesl_tmp_32; i++)
		{
			sprintf(tvin_matrix_i_10_V, "%s\n", (matrix_i_10_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_10_V, tvin_matrix_i_10_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_10_V = aesl_tmp_31;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V, stream_ingress_size_matrix_i_10_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V, "\n");

		for (int i = 0; i < aesl_tmp_31 - aesl_tmp_32; i++)
		{
			stream_ingress_size_matrix_i_10_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V, stream_ingress_size_matrix_i_10_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_31 - aesl_tmp_32, &tcl_file.matrix_i_10_V_depth);
		sprintf(tvin_matrix_i_10_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_10_V, tvin_matrix_i_10_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_10_V, tvin_matrix_i_10_V);

		// release memory allocation
		delete [] matrix_i_10_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_10_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_10_V, wrapc_stream_size_in_matrix_i_10_V);
		sprintf(wrapc_stream_size_in_matrix_i_10_V, "%d\n", aesl_tmp_31 - aesl_tmp_32);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_10_V, wrapc_stream_size_in_matrix_i_10_V);
		sprintf(wrapc_stream_size_in_matrix_i_10_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_10_V, wrapc_stream_size_in_matrix_i_10_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_11_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_11_V, tvin_matrix_i_11_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V, tvin_matrix_i_11_V);

		sc_bv<16>* matrix_i_11_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_34 - aesl_tmp_35];

		// RTL Name: matrix_i_11_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_34 - aesl_tmp_35 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_34 - aesl_tmp_35 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_33[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_33[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_33[i_0]
						if (&(aesl_tmp_33[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_33[i_0];
							matrix_i_11_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_34 - aesl_tmp_35; i++)
		{
			sprintf(tvin_matrix_i_11_V, "%s\n", (matrix_i_11_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_11_V, tvin_matrix_i_11_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_11_V = aesl_tmp_34;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V, stream_ingress_size_matrix_i_11_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V, "\n");

		for (int i = 0; i < aesl_tmp_34 - aesl_tmp_35; i++)
		{
			stream_ingress_size_matrix_i_11_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V, stream_ingress_size_matrix_i_11_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_34 - aesl_tmp_35, &tcl_file.matrix_i_11_V_depth);
		sprintf(tvin_matrix_i_11_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_11_V, tvin_matrix_i_11_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_11_V, tvin_matrix_i_11_V);

		// release memory allocation
		delete [] matrix_i_11_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_11_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_11_V, wrapc_stream_size_in_matrix_i_11_V);
		sprintf(wrapc_stream_size_in_matrix_i_11_V, "%d\n", aesl_tmp_34 - aesl_tmp_35);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_11_V, wrapc_stream_size_in_matrix_i_11_V);
		sprintf(wrapc_stream_size_in_matrix_i_11_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_11_V, wrapc_stream_size_in_matrix_i_11_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_12_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_12_V, tvin_matrix_i_12_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V, tvin_matrix_i_12_V);

		sc_bv<16>* matrix_i_12_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_37 - aesl_tmp_38];

		// RTL Name: matrix_i_12_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_37 - aesl_tmp_38 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_37 - aesl_tmp_38 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_36[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_36[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_36[i_0]
						if (&(aesl_tmp_36[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_36[i_0];
							matrix_i_12_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_37 - aesl_tmp_38; i++)
		{
			sprintf(tvin_matrix_i_12_V, "%s\n", (matrix_i_12_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_12_V, tvin_matrix_i_12_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_12_V = aesl_tmp_37;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V, stream_ingress_size_matrix_i_12_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V, "\n");

		for (int i = 0; i < aesl_tmp_37 - aesl_tmp_38; i++)
		{
			stream_ingress_size_matrix_i_12_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V, stream_ingress_size_matrix_i_12_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_37 - aesl_tmp_38, &tcl_file.matrix_i_12_V_depth);
		sprintf(tvin_matrix_i_12_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_12_V, tvin_matrix_i_12_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_12_V, tvin_matrix_i_12_V);

		// release memory allocation
		delete [] matrix_i_12_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_12_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_12_V, wrapc_stream_size_in_matrix_i_12_V);
		sprintf(wrapc_stream_size_in_matrix_i_12_V, "%d\n", aesl_tmp_37 - aesl_tmp_38);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_12_V, wrapc_stream_size_in_matrix_i_12_V);
		sprintf(wrapc_stream_size_in_matrix_i_12_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_12_V, wrapc_stream_size_in_matrix_i_12_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_13_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_13_V, tvin_matrix_i_13_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V, tvin_matrix_i_13_V);

		sc_bv<16>* matrix_i_13_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_40 - aesl_tmp_41];

		// RTL Name: matrix_i_13_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_40 - aesl_tmp_41 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_40 - aesl_tmp_41 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_39[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_39[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_39[i_0]
						if (&(aesl_tmp_39[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_39[i_0];
							matrix_i_13_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_40 - aesl_tmp_41; i++)
		{
			sprintf(tvin_matrix_i_13_V, "%s\n", (matrix_i_13_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_13_V, tvin_matrix_i_13_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_13_V = aesl_tmp_40;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V, stream_ingress_size_matrix_i_13_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V, "\n");

		for (int i = 0; i < aesl_tmp_40 - aesl_tmp_41; i++)
		{
			stream_ingress_size_matrix_i_13_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V, stream_ingress_size_matrix_i_13_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_40 - aesl_tmp_41, &tcl_file.matrix_i_13_V_depth);
		sprintf(tvin_matrix_i_13_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_13_V, tvin_matrix_i_13_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_13_V, tvin_matrix_i_13_V);

		// release memory allocation
		delete [] matrix_i_13_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_13_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_13_V, wrapc_stream_size_in_matrix_i_13_V);
		sprintf(wrapc_stream_size_in_matrix_i_13_V, "%d\n", aesl_tmp_40 - aesl_tmp_41);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_13_V, wrapc_stream_size_in_matrix_i_13_V);
		sprintf(wrapc_stream_size_in_matrix_i_13_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_13_V, wrapc_stream_size_in_matrix_i_13_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_14_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_14_V, tvin_matrix_i_14_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V, tvin_matrix_i_14_V);

		sc_bv<16>* matrix_i_14_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_43 - aesl_tmp_44];

		// RTL Name: matrix_i_14_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_43 - aesl_tmp_44 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_43 - aesl_tmp_44 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_42[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_42[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_42[i_0]
						if (&(aesl_tmp_42[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_42[i_0];
							matrix_i_14_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_43 - aesl_tmp_44; i++)
		{
			sprintf(tvin_matrix_i_14_V, "%s\n", (matrix_i_14_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_14_V, tvin_matrix_i_14_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_14_V = aesl_tmp_43;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V, stream_ingress_size_matrix_i_14_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V, "\n");

		for (int i = 0; i < aesl_tmp_43 - aesl_tmp_44; i++)
		{
			stream_ingress_size_matrix_i_14_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V, stream_ingress_size_matrix_i_14_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_43 - aesl_tmp_44, &tcl_file.matrix_i_14_V_depth);
		sprintf(tvin_matrix_i_14_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_14_V, tvin_matrix_i_14_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_14_V, tvin_matrix_i_14_V);

		// release memory allocation
		delete [] matrix_i_14_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_14_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_14_V, wrapc_stream_size_in_matrix_i_14_V);
		sprintf(wrapc_stream_size_in_matrix_i_14_V, "%d\n", aesl_tmp_43 - aesl_tmp_44);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_14_V, wrapc_stream_size_in_matrix_i_14_V);
		sprintf(wrapc_stream_size_in_matrix_i_14_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_14_V, wrapc_stream_size_in_matrix_i_14_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_15_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_15_V, tvin_matrix_i_15_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V, tvin_matrix_i_15_V);

		sc_bv<16>* matrix_i_15_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_46 - aesl_tmp_47];

		// RTL Name: matrix_i_15_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_46 - aesl_tmp_47 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_46 - aesl_tmp_47 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_45[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_45[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_45[i_0]
						if (&(aesl_tmp_45[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_45[i_0];
							matrix_i_15_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_46 - aesl_tmp_47; i++)
		{
			sprintf(tvin_matrix_i_15_V, "%s\n", (matrix_i_15_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_15_V, tvin_matrix_i_15_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_15_V = aesl_tmp_46;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V, stream_ingress_size_matrix_i_15_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V, "\n");

		for (int i = 0; i < aesl_tmp_46 - aesl_tmp_47; i++)
		{
			stream_ingress_size_matrix_i_15_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V, stream_ingress_size_matrix_i_15_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_46 - aesl_tmp_47, &tcl_file.matrix_i_15_V_depth);
		sprintf(tvin_matrix_i_15_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_15_V, tvin_matrix_i_15_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_15_V, tvin_matrix_i_15_V);

		// release memory allocation
		delete [] matrix_i_15_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_15_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_15_V, wrapc_stream_size_in_matrix_i_15_V);
		sprintf(wrapc_stream_size_in_matrix_i_15_V, "%d\n", aesl_tmp_46 - aesl_tmp_47);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_15_V, wrapc_stream_size_in_matrix_i_15_V);
		sprintf(wrapc_stream_size_in_matrix_i_15_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_15_V, wrapc_stream_size_in_matrix_i_15_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_16_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_16_V, tvin_matrix_i_16_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V, tvin_matrix_i_16_V);

		sc_bv<16>* matrix_i_16_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_49 - aesl_tmp_50];

		// RTL Name: matrix_i_16_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_49 - aesl_tmp_50 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_49 - aesl_tmp_50 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_48[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_48[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_48[i_0]
						if (&(aesl_tmp_48[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_48[i_0];
							matrix_i_16_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_49 - aesl_tmp_50; i++)
		{
			sprintf(tvin_matrix_i_16_V, "%s\n", (matrix_i_16_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_16_V, tvin_matrix_i_16_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_16_V = aesl_tmp_49;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V, stream_ingress_size_matrix_i_16_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V, "\n");

		for (int i = 0; i < aesl_tmp_49 - aesl_tmp_50; i++)
		{
			stream_ingress_size_matrix_i_16_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V, stream_ingress_size_matrix_i_16_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_49 - aesl_tmp_50, &tcl_file.matrix_i_16_V_depth);
		sprintf(tvin_matrix_i_16_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_16_V, tvin_matrix_i_16_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_16_V, tvin_matrix_i_16_V);

		// release memory allocation
		delete [] matrix_i_16_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_16_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_16_V, wrapc_stream_size_in_matrix_i_16_V);
		sprintf(wrapc_stream_size_in_matrix_i_16_V, "%d\n", aesl_tmp_49 - aesl_tmp_50);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_16_V, wrapc_stream_size_in_matrix_i_16_V);
		sprintf(wrapc_stream_size_in_matrix_i_16_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_16_V, wrapc_stream_size_in_matrix_i_16_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_17_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_17_V, tvin_matrix_i_17_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V, tvin_matrix_i_17_V);

		sc_bv<16>* matrix_i_17_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_52 - aesl_tmp_53];

		// RTL Name: matrix_i_17_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_52 - aesl_tmp_53 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_52 - aesl_tmp_53 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_51[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_51[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_51[i_0]
						if (&(aesl_tmp_51[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_51[i_0];
							matrix_i_17_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_52 - aesl_tmp_53; i++)
		{
			sprintf(tvin_matrix_i_17_V, "%s\n", (matrix_i_17_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_17_V, tvin_matrix_i_17_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_17_V = aesl_tmp_52;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V, stream_ingress_size_matrix_i_17_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V, "\n");

		for (int i = 0; i < aesl_tmp_52 - aesl_tmp_53; i++)
		{
			stream_ingress_size_matrix_i_17_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V, stream_ingress_size_matrix_i_17_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_52 - aesl_tmp_53, &tcl_file.matrix_i_17_V_depth);
		sprintf(tvin_matrix_i_17_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_17_V, tvin_matrix_i_17_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_17_V, tvin_matrix_i_17_V);

		// release memory allocation
		delete [] matrix_i_17_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_17_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_17_V, wrapc_stream_size_in_matrix_i_17_V);
		sprintf(wrapc_stream_size_in_matrix_i_17_V, "%d\n", aesl_tmp_52 - aesl_tmp_53);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_17_V, wrapc_stream_size_in_matrix_i_17_V);
		sprintf(wrapc_stream_size_in_matrix_i_17_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_17_V, wrapc_stream_size_in_matrix_i_17_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_18_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_18_V, tvin_matrix_i_18_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V, tvin_matrix_i_18_V);

		sc_bv<16>* matrix_i_18_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_55 - aesl_tmp_56];

		// RTL Name: matrix_i_18_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_55 - aesl_tmp_56 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_55 - aesl_tmp_56 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_54[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_54[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_54[i_0]
						if (&(aesl_tmp_54[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_54[i_0];
							matrix_i_18_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_55 - aesl_tmp_56; i++)
		{
			sprintf(tvin_matrix_i_18_V, "%s\n", (matrix_i_18_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_18_V, tvin_matrix_i_18_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_18_V = aesl_tmp_55;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V, stream_ingress_size_matrix_i_18_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V, "\n");

		for (int i = 0; i < aesl_tmp_55 - aesl_tmp_56; i++)
		{
			stream_ingress_size_matrix_i_18_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V, stream_ingress_size_matrix_i_18_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_55 - aesl_tmp_56, &tcl_file.matrix_i_18_V_depth);
		sprintf(tvin_matrix_i_18_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_18_V, tvin_matrix_i_18_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_18_V, tvin_matrix_i_18_V);

		// release memory allocation
		delete [] matrix_i_18_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_18_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_18_V, wrapc_stream_size_in_matrix_i_18_V);
		sprintf(wrapc_stream_size_in_matrix_i_18_V, "%d\n", aesl_tmp_55 - aesl_tmp_56);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_18_V, wrapc_stream_size_in_matrix_i_18_V);
		sprintf(wrapc_stream_size_in_matrix_i_18_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_18_V, wrapc_stream_size_in_matrix_i_18_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_19_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_19_V, tvin_matrix_i_19_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V, tvin_matrix_i_19_V);

		sc_bv<16>* matrix_i_19_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_58 - aesl_tmp_59];

		// RTL Name: matrix_i_19_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_58 - aesl_tmp_59 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_58 - aesl_tmp_59 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_57[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_57[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_57[i_0]
						if (&(aesl_tmp_57[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_57[i_0];
							matrix_i_19_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_58 - aesl_tmp_59; i++)
		{
			sprintf(tvin_matrix_i_19_V, "%s\n", (matrix_i_19_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_19_V, tvin_matrix_i_19_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_19_V = aesl_tmp_58;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V, stream_ingress_size_matrix_i_19_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V, "\n");

		for (int i = 0; i < aesl_tmp_58 - aesl_tmp_59; i++)
		{
			stream_ingress_size_matrix_i_19_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V, stream_ingress_size_matrix_i_19_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_58 - aesl_tmp_59, &tcl_file.matrix_i_19_V_depth);
		sprintf(tvin_matrix_i_19_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_19_V, tvin_matrix_i_19_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_19_V, tvin_matrix_i_19_V);

		// release memory allocation
		delete [] matrix_i_19_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_19_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_19_V, wrapc_stream_size_in_matrix_i_19_V);
		sprintf(wrapc_stream_size_in_matrix_i_19_V, "%d\n", aesl_tmp_58 - aesl_tmp_59);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_19_V, wrapc_stream_size_in_matrix_i_19_V);
		sprintf(wrapc_stream_size_in_matrix_i_19_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_19_V, wrapc_stream_size_in_matrix_i_19_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_20_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_20_V, tvin_matrix_i_20_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V, tvin_matrix_i_20_V);

		sc_bv<16>* matrix_i_20_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_61 - aesl_tmp_62];

		// RTL Name: matrix_i_20_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_61 - aesl_tmp_62 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_61 - aesl_tmp_62 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_60[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_60[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_60[i_0]
						if (&(aesl_tmp_60[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_60[i_0];
							matrix_i_20_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_61 - aesl_tmp_62; i++)
		{
			sprintf(tvin_matrix_i_20_V, "%s\n", (matrix_i_20_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_20_V, tvin_matrix_i_20_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_20_V = aesl_tmp_61;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V, stream_ingress_size_matrix_i_20_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V, "\n");

		for (int i = 0; i < aesl_tmp_61 - aesl_tmp_62; i++)
		{
			stream_ingress_size_matrix_i_20_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V, stream_ingress_size_matrix_i_20_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_61 - aesl_tmp_62, &tcl_file.matrix_i_20_V_depth);
		sprintf(tvin_matrix_i_20_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_20_V, tvin_matrix_i_20_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_20_V, tvin_matrix_i_20_V);

		// release memory allocation
		delete [] matrix_i_20_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_20_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_20_V, wrapc_stream_size_in_matrix_i_20_V);
		sprintf(wrapc_stream_size_in_matrix_i_20_V, "%d\n", aesl_tmp_61 - aesl_tmp_62);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_20_V, wrapc_stream_size_in_matrix_i_20_V);
		sprintf(wrapc_stream_size_in_matrix_i_20_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_20_V, wrapc_stream_size_in_matrix_i_20_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_21_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_21_V, tvin_matrix_i_21_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V, tvin_matrix_i_21_V);

		sc_bv<16>* matrix_i_21_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_64 - aesl_tmp_65];

		// RTL Name: matrix_i_21_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_64 - aesl_tmp_65 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_64 - aesl_tmp_65 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_63[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_63[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_63[i_0]
						if (&(aesl_tmp_63[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_63[i_0];
							matrix_i_21_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_64 - aesl_tmp_65; i++)
		{
			sprintf(tvin_matrix_i_21_V, "%s\n", (matrix_i_21_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_21_V, tvin_matrix_i_21_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_21_V = aesl_tmp_64;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V, stream_ingress_size_matrix_i_21_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V, "\n");

		for (int i = 0; i < aesl_tmp_64 - aesl_tmp_65; i++)
		{
			stream_ingress_size_matrix_i_21_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V, stream_ingress_size_matrix_i_21_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_64 - aesl_tmp_65, &tcl_file.matrix_i_21_V_depth);
		sprintf(tvin_matrix_i_21_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_21_V, tvin_matrix_i_21_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_21_V, tvin_matrix_i_21_V);

		// release memory allocation
		delete [] matrix_i_21_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_21_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_21_V, wrapc_stream_size_in_matrix_i_21_V);
		sprintf(wrapc_stream_size_in_matrix_i_21_V, "%d\n", aesl_tmp_64 - aesl_tmp_65);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_21_V, wrapc_stream_size_in_matrix_i_21_V);
		sprintf(wrapc_stream_size_in_matrix_i_21_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_21_V, wrapc_stream_size_in_matrix_i_21_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_22_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_22_V, tvin_matrix_i_22_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V, tvin_matrix_i_22_V);

		sc_bv<16>* matrix_i_22_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_67 - aesl_tmp_68];

		// RTL Name: matrix_i_22_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_67 - aesl_tmp_68 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_67 - aesl_tmp_68 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_66[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_66[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_66[i_0]
						if (&(aesl_tmp_66[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_66[i_0];
							matrix_i_22_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_67 - aesl_tmp_68; i++)
		{
			sprintf(tvin_matrix_i_22_V, "%s\n", (matrix_i_22_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_22_V, tvin_matrix_i_22_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_22_V = aesl_tmp_67;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V, stream_ingress_size_matrix_i_22_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V, "\n");

		for (int i = 0; i < aesl_tmp_67 - aesl_tmp_68; i++)
		{
			stream_ingress_size_matrix_i_22_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V, stream_ingress_size_matrix_i_22_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_67 - aesl_tmp_68, &tcl_file.matrix_i_22_V_depth);
		sprintf(tvin_matrix_i_22_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_22_V, tvin_matrix_i_22_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_22_V, tvin_matrix_i_22_V);

		// release memory allocation
		delete [] matrix_i_22_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_22_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_22_V, wrapc_stream_size_in_matrix_i_22_V);
		sprintf(wrapc_stream_size_in_matrix_i_22_V, "%d\n", aesl_tmp_67 - aesl_tmp_68);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_22_V, wrapc_stream_size_in_matrix_i_22_V);
		sprintf(wrapc_stream_size_in_matrix_i_22_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_22_V, wrapc_stream_size_in_matrix_i_22_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_23_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_23_V, tvin_matrix_i_23_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V, tvin_matrix_i_23_V);

		sc_bv<16>* matrix_i_23_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_70 - aesl_tmp_71];

		// RTL Name: matrix_i_23_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_70 - aesl_tmp_71 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_70 - aesl_tmp_71 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_69[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_69[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_69[i_0]
						if (&(aesl_tmp_69[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_69[i_0];
							matrix_i_23_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_70 - aesl_tmp_71; i++)
		{
			sprintf(tvin_matrix_i_23_V, "%s\n", (matrix_i_23_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_23_V, tvin_matrix_i_23_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_23_V = aesl_tmp_70;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V, stream_ingress_size_matrix_i_23_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V, "\n");

		for (int i = 0; i < aesl_tmp_70 - aesl_tmp_71; i++)
		{
			stream_ingress_size_matrix_i_23_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V, stream_ingress_size_matrix_i_23_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_70 - aesl_tmp_71, &tcl_file.matrix_i_23_V_depth);
		sprintf(tvin_matrix_i_23_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_23_V, tvin_matrix_i_23_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_23_V, tvin_matrix_i_23_V);

		// release memory allocation
		delete [] matrix_i_23_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_23_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_23_V, wrapc_stream_size_in_matrix_i_23_V);
		sprintf(wrapc_stream_size_in_matrix_i_23_V, "%d\n", aesl_tmp_70 - aesl_tmp_71);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_23_V, wrapc_stream_size_in_matrix_i_23_V);
		sprintf(wrapc_stream_size_in_matrix_i_23_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_23_V, wrapc_stream_size_in_matrix_i_23_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_24_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_24_V, tvin_matrix_i_24_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V, tvin_matrix_i_24_V);

		sc_bv<16>* matrix_i_24_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_73 - aesl_tmp_74];

		// RTL Name: matrix_i_24_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_73 - aesl_tmp_74 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_73 - aesl_tmp_74 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_72[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_72[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_72[i_0]
						if (&(aesl_tmp_72[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_72[i_0];
							matrix_i_24_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_73 - aesl_tmp_74; i++)
		{
			sprintf(tvin_matrix_i_24_V, "%s\n", (matrix_i_24_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_24_V, tvin_matrix_i_24_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_24_V = aesl_tmp_73;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V, stream_ingress_size_matrix_i_24_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V, "\n");

		for (int i = 0; i < aesl_tmp_73 - aesl_tmp_74; i++)
		{
			stream_ingress_size_matrix_i_24_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V, stream_ingress_size_matrix_i_24_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_73 - aesl_tmp_74, &tcl_file.matrix_i_24_V_depth);
		sprintf(tvin_matrix_i_24_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_24_V, tvin_matrix_i_24_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_24_V, tvin_matrix_i_24_V);

		// release memory allocation
		delete [] matrix_i_24_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_24_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_24_V, wrapc_stream_size_in_matrix_i_24_V);
		sprintf(wrapc_stream_size_in_matrix_i_24_V, "%d\n", aesl_tmp_73 - aesl_tmp_74);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_24_V, wrapc_stream_size_in_matrix_i_24_V);
		sprintf(wrapc_stream_size_in_matrix_i_24_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_24_V, wrapc_stream_size_in_matrix_i_24_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_25_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_25_V, tvin_matrix_i_25_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V, tvin_matrix_i_25_V);

		sc_bv<16>* matrix_i_25_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_76 - aesl_tmp_77];

		// RTL Name: matrix_i_25_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_76 - aesl_tmp_77 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_76 - aesl_tmp_77 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_75[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_75[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_75[i_0]
						if (&(aesl_tmp_75[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_75[i_0];
							matrix_i_25_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_76 - aesl_tmp_77; i++)
		{
			sprintf(tvin_matrix_i_25_V, "%s\n", (matrix_i_25_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_25_V, tvin_matrix_i_25_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_25_V = aesl_tmp_76;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V, stream_ingress_size_matrix_i_25_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V, "\n");

		for (int i = 0; i < aesl_tmp_76 - aesl_tmp_77; i++)
		{
			stream_ingress_size_matrix_i_25_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V, stream_ingress_size_matrix_i_25_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_76 - aesl_tmp_77, &tcl_file.matrix_i_25_V_depth);
		sprintf(tvin_matrix_i_25_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_25_V, tvin_matrix_i_25_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_25_V, tvin_matrix_i_25_V);

		// release memory allocation
		delete [] matrix_i_25_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_25_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_25_V, wrapc_stream_size_in_matrix_i_25_V);
		sprintf(wrapc_stream_size_in_matrix_i_25_V, "%d\n", aesl_tmp_76 - aesl_tmp_77);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_25_V, wrapc_stream_size_in_matrix_i_25_V);
		sprintf(wrapc_stream_size_in_matrix_i_25_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_25_V, wrapc_stream_size_in_matrix_i_25_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_26_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_26_V, tvin_matrix_i_26_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V, tvin_matrix_i_26_V);

		sc_bv<16>* matrix_i_26_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_79 - aesl_tmp_80];

		// RTL Name: matrix_i_26_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_79 - aesl_tmp_80 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_79 - aesl_tmp_80 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_78[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_78[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_78[i_0]
						if (&(aesl_tmp_78[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_78[i_0];
							matrix_i_26_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_79 - aesl_tmp_80; i++)
		{
			sprintf(tvin_matrix_i_26_V, "%s\n", (matrix_i_26_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_26_V, tvin_matrix_i_26_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_26_V = aesl_tmp_79;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V, stream_ingress_size_matrix_i_26_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V, "\n");

		for (int i = 0; i < aesl_tmp_79 - aesl_tmp_80; i++)
		{
			stream_ingress_size_matrix_i_26_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V, stream_ingress_size_matrix_i_26_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_79 - aesl_tmp_80, &tcl_file.matrix_i_26_V_depth);
		sprintf(tvin_matrix_i_26_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_26_V, tvin_matrix_i_26_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_26_V, tvin_matrix_i_26_V);

		// release memory allocation
		delete [] matrix_i_26_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_26_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_26_V, wrapc_stream_size_in_matrix_i_26_V);
		sprintf(wrapc_stream_size_in_matrix_i_26_V, "%d\n", aesl_tmp_79 - aesl_tmp_80);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_26_V, wrapc_stream_size_in_matrix_i_26_V);
		sprintf(wrapc_stream_size_in_matrix_i_26_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_26_V, wrapc_stream_size_in_matrix_i_26_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_27_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_27_V, tvin_matrix_i_27_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V, tvin_matrix_i_27_V);

		sc_bv<16>* matrix_i_27_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_82 - aesl_tmp_83];

		// RTL Name: matrix_i_27_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_82 - aesl_tmp_83 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_82 - aesl_tmp_83 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_81[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_81[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_81[i_0]
						if (&(aesl_tmp_81[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_81[i_0];
							matrix_i_27_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_82 - aesl_tmp_83; i++)
		{
			sprintf(tvin_matrix_i_27_V, "%s\n", (matrix_i_27_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_27_V, tvin_matrix_i_27_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_27_V = aesl_tmp_82;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V, stream_ingress_size_matrix_i_27_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V, "\n");

		for (int i = 0; i < aesl_tmp_82 - aesl_tmp_83; i++)
		{
			stream_ingress_size_matrix_i_27_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V, stream_ingress_size_matrix_i_27_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_82 - aesl_tmp_83, &tcl_file.matrix_i_27_V_depth);
		sprintf(tvin_matrix_i_27_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_27_V, tvin_matrix_i_27_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_27_V, tvin_matrix_i_27_V);

		// release memory allocation
		delete [] matrix_i_27_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_27_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_27_V, wrapc_stream_size_in_matrix_i_27_V);
		sprintf(wrapc_stream_size_in_matrix_i_27_V, "%d\n", aesl_tmp_82 - aesl_tmp_83);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_27_V, wrapc_stream_size_in_matrix_i_27_V);
		sprintf(wrapc_stream_size_in_matrix_i_27_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_27_V, wrapc_stream_size_in_matrix_i_27_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_28_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_28_V, tvin_matrix_i_28_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V, tvin_matrix_i_28_V);

		sc_bv<16>* matrix_i_28_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_85 - aesl_tmp_86];

		// RTL Name: matrix_i_28_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_85 - aesl_tmp_86 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_85 - aesl_tmp_86 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_84[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_84[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_84[i_0]
						if (&(aesl_tmp_84[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_84[i_0];
							matrix_i_28_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_85 - aesl_tmp_86; i++)
		{
			sprintf(tvin_matrix_i_28_V, "%s\n", (matrix_i_28_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_28_V, tvin_matrix_i_28_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_28_V = aesl_tmp_85;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V, stream_ingress_size_matrix_i_28_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V, "\n");

		for (int i = 0; i < aesl_tmp_85 - aesl_tmp_86; i++)
		{
			stream_ingress_size_matrix_i_28_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V, stream_ingress_size_matrix_i_28_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_85 - aesl_tmp_86, &tcl_file.matrix_i_28_V_depth);
		sprintf(tvin_matrix_i_28_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_28_V, tvin_matrix_i_28_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_28_V, tvin_matrix_i_28_V);

		// release memory allocation
		delete [] matrix_i_28_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_28_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_28_V, wrapc_stream_size_in_matrix_i_28_V);
		sprintf(wrapc_stream_size_in_matrix_i_28_V, "%d\n", aesl_tmp_85 - aesl_tmp_86);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_28_V, wrapc_stream_size_in_matrix_i_28_V);
		sprintf(wrapc_stream_size_in_matrix_i_28_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_28_V, wrapc_stream_size_in_matrix_i_28_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_29_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_29_V, tvin_matrix_i_29_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V, tvin_matrix_i_29_V);

		sc_bv<16>* matrix_i_29_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_88 - aesl_tmp_89];

		// RTL Name: matrix_i_29_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_88 - aesl_tmp_89 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_88 - aesl_tmp_89 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_87[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_87[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_87[i_0]
						if (&(aesl_tmp_87[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_87[i_0];
							matrix_i_29_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_88 - aesl_tmp_89; i++)
		{
			sprintf(tvin_matrix_i_29_V, "%s\n", (matrix_i_29_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_29_V, tvin_matrix_i_29_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_29_V = aesl_tmp_88;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V, stream_ingress_size_matrix_i_29_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V, "\n");

		for (int i = 0; i < aesl_tmp_88 - aesl_tmp_89; i++)
		{
			stream_ingress_size_matrix_i_29_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V, stream_ingress_size_matrix_i_29_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_88 - aesl_tmp_89, &tcl_file.matrix_i_29_V_depth);
		sprintf(tvin_matrix_i_29_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_29_V, tvin_matrix_i_29_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_29_V, tvin_matrix_i_29_V);

		// release memory allocation
		delete [] matrix_i_29_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_29_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_29_V, wrapc_stream_size_in_matrix_i_29_V);
		sprintf(wrapc_stream_size_in_matrix_i_29_V, "%d\n", aesl_tmp_88 - aesl_tmp_89);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_29_V, wrapc_stream_size_in_matrix_i_29_V);
		sprintf(wrapc_stream_size_in_matrix_i_29_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_29_V, wrapc_stream_size_in_matrix_i_29_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_30_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_30_V, tvin_matrix_i_30_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V, tvin_matrix_i_30_V);

		sc_bv<16>* matrix_i_30_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_91 - aesl_tmp_92];

		// RTL Name: matrix_i_30_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_91 - aesl_tmp_92 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_91 - aesl_tmp_92 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_90[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_90[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_90[i_0]
						if (&(aesl_tmp_90[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_90[i_0];
							matrix_i_30_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_91 - aesl_tmp_92; i++)
		{
			sprintf(tvin_matrix_i_30_V, "%s\n", (matrix_i_30_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_30_V, tvin_matrix_i_30_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_30_V = aesl_tmp_91;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V, stream_ingress_size_matrix_i_30_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V, "\n");

		for (int i = 0; i < aesl_tmp_91 - aesl_tmp_92; i++)
		{
			stream_ingress_size_matrix_i_30_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V, stream_ingress_size_matrix_i_30_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_91 - aesl_tmp_92, &tcl_file.matrix_i_30_V_depth);
		sprintf(tvin_matrix_i_30_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_30_V, tvin_matrix_i_30_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_30_V, tvin_matrix_i_30_V);

		// release memory allocation
		delete [] matrix_i_30_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_30_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_30_V, wrapc_stream_size_in_matrix_i_30_V);
		sprintf(wrapc_stream_size_in_matrix_i_30_V, "%d\n", aesl_tmp_91 - aesl_tmp_92);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_30_V, wrapc_stream_size_in_matrix_i_30_V);
		sprintf(wrapc_stream_size_in_matrix_i_30_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_30_V, wrapc_stream_size_in_matrix_i_30_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_31_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_31_V, tvin_matrix_i_31_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V, tvin_matrix_i_31_V);

		sc_bv<16>* matrix_i_31_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_94 - aesl_tmp_95];

		// RTL Name: matrix_i_31_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_94 - aesl_tmp_95 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_94 - aesl_tmp_95 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_93[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_93[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_93[i_0]
						if (&(aesl_tmp_93[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_93[i_0];
							matrix_i_31_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_94 - aesl_tmp_95; i++)
		{
			sprintf(tvin_matrix_i_31_V, "%s\n", (matrix_i_31_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_31_V, tvin_matrix_i_31_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_31_V = aesl_tmp_94;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V, stream_ingress_size_matrix_i_31_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V, "\n");

		for (int i = 0; i < aesl_tmp_94 - aesl_tmp_95; i++)
		{
			stream_ingress_size_matrix_i_31_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V, stream_ingress_size_matrix_i_31_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_94 - aesl_tmp_95, &tcl_file.matrix_i_31_V_depth);
		sprintf(tvin_matrix_i_31_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_31_V, tvin_matrix_i_31_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_31_V, tvin_matrix_i_31_V);

		// release memory allocation
		delete [] matrix_i_31_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_31_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_31_V, wrapc_stream_size_in_matrix_i_31_V);
		sprintf(wrapc_stream_size_in_matrix_i_31_V, "%d\n", aesl_tmp_94 - aesl_tmp_95);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_31_V, wrapc_stream_size_in_matrix_i_31_V);
		sprintf(wrapc_stream_size_in_matrix_i_31_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_31_V, wrapc_stream_size_in_matrix_i_31_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_32_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_32_V, tvin_matrix_i_32_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V, tvin_matrix_i_32_V);

		sc_bv<16>* matrix_i_32_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_97 - aesl_tmp_98];

		// RTL Name: matrix_i_32_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_97 - aesl_tmp_98 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_97 - aesl_tmp_98 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_96[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_96[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_96[i_0]
						if (&(aesl_tmp_96[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_96[i_0];
							matrix_i_32_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_97 - aesl_tmp_98; i++)
		{
			sprintf(tvin_matrix_i_32_V, "%s\n", (matrix_i_32_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_32_V, tvin_matrix_i_32_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_32_V = aesl_tmp_97;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V, stream_ingress_size_matrix_i_32_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V, "\n");

		for (int i = 0; i < aesl_tmp_97 - aesl_tmp_98; i++)
		{
			stream_ingress_size_matrix_i_32_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V, stream_ingress_size_matrix_i_32_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_97 - aesl_tmp_98, &tcl_file.matrix_i_32_V_depth);
		sprintf(tvin_matrix_i_32_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_32_V, tvin_matrix_i_32_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_32_V, tvin_matrix_i_32_V);

		// release memory allocation
		delete [] matrix_i_32_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_32_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_32_V, wrapc_stream_size_in_matrix_i_32_V);
		sprintf(wrapc_stream_size_in_matrix_i_32_V, "%d\n", aesl_tmp_97 - aesl_tmp_98);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_32_V, wrapc_stream_size_in_matrix_i_32_V);
		sprintf(wrapc_stream_size_in_matrix_i_32_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_32_V, wrapc_stream_size_in_matrix_i_32_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_33_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_33_V, tvin_matrix_i_33_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V, tvin_matrix_i_33_V);

		sc_bv<16>* matrix_i_33_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_100 - aesl_tmp_101];

		// RTL Name: matrix_i_33_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_100 - aesl_tmp_101 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_100 - aesl_tmp_101 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_99[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_99[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_99[i_0]
						if (&(aesl_tmp_99[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_99[i_0];
							matrix_i_33_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_100 - aesl_tmp_101; i++)
		{
			sprintf(tvin_matrix_i_33_V, "%s\n", (matrix_i_33_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_33_V, tvin_matrix_i_33_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_33_V = aesl_tmp_100;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V, stream_ingress_size_matrix_i_33_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V, "\n");

		for (int i = 0; i < aesl_tmp_100 - aesl_tmp_101; i++)
		{
			stream_ingress_size_matrix_i_33_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V, stream_ingress_size_matrix_i_33_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_100 - aesl_tmp_101, &tcl_file.matrix_i_33_V_depth);
		sprintf(tvin_matrix_i_33_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_33_V, tvin_matrix_i_33_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_33_V, tvin_matrix_i_33_V);

		// release memory allocation
		delete [] matrix_i_33_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_33_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_33_V, wrapc_stream_size_in_matrix_i_33_V);
		sprintf(wrapc_stream_size_in_matrix_i_33_V, "%d\n", aesl_tmp_100 - aesl_tmp_101);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_33_V, wrapc_stream_size_in_matrix_i_33_V);
		sprintf(wrapc_stream_size_in_matrix_i_33_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_33_V, wrapc_stream_size_in_matrix_i_33_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_34_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_34_V, tvin_matrix_i_34_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V, tvin_matrix_i_34_V);

		sc_bv<16>* matrix_i_34_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_103 - aesl_tmp_104];

		// RTL Name: matrix_i_34_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_103 - aesl_tmp_104 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_103 - aesl_tmp_104 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_102[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_102[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_102[i_0]
						if (&(aesl_tmp_102[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_102[i_0];
							matrix_i_34_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_103 - aesl_tmp_104; i++)
		{
			sprintf(tvin_matrix_i_34_V, "%s\n", (matrix_i_34_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_34_V, tvin_matrix_i_34_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_34_V = aesl_tmp_103;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V, stream_ingress_size_matrix_i_34_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V, "\n");

		for (int i = 0; i < aesl_tmp_103 - aesl_tmp_104; i++)
		{
			stream_ingress_size_matrix_i_34_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V, stream_ingress_size_matrix_i_34_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_103 - aesl_tmp_104, &tcl_file.matrix_i_34_V_depth);
		sprintf(tvin_matrix_i_34_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_34_V, tvin_matrix_i_34_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_34_V, tvin_matrix_i_34_V);

		// release memory allocation
		delete [] matrix_i_34_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_34_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_34_V, wrapc_stream_size_in_matrix_i_34_V);
		sprintf(wrapc_stream_size_in_matrix_i_34_V, "%d\n", aesl_tmp_103 - aesl_tmp_104);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_34_V, wrapc_stream_size_in_matrix_i_34_V);
		sprintf(wrapc_stream_size_in_matrix_i_34_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_34_V, wrapc_stream_size_in_matrix_i_34_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_35_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_35_V, tvin_matrix_i_35_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V, tvin_matrix_i_35_V);

		sc_bv<16>* matrix_i_35_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_106 - aesl_tmp_107];

		// RTL Name: matrix_i_35_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_106 - aesl_tmp_107 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_106 - aesl_tmp_107 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_105[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_105[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_105[i_0]
						if (&(aesl_tmp_105[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_105[i_0];
							matrix_i_35_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_106 - aesl_tmp_107; i++)
		{
			sprintf(tvin_matrix_i_35_V, "%s\n", (matrix_i_35_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_35_V, tvin_matrix_i_35_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_35_V = aesl_tmp_106;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V, stream_ingress_size_matrix_i_35_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V, "\n");

		for (int i = 0; i < aesl_tmp_106 - aesl_tmp_107; i++)
		{
			stream_ingress_size_matrix_i_35_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V, stream_ingress_size_matrix_i_35_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_106 - aesl_tmp_107, &tcl_file.matrix_i_35_V_depth);
		sprintf(tvin_matrix_i_35_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_35_V, tvin_matrix_i_35_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_35_V, tvin_matrix_i_35_V);

		// release memory allocation
		delete [] matrix_i_35_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_35_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_35_V, wrapc_stream_size_in_matrix_i_35_V);
		sprintf(wrapc_stream_size_in_matrix_i_35_V, "%d\n", aesl_tmp_106 - aesl_tmp_107);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_35_V, wrapc_stream_size_in_matrix_i_35_V);
		sprintf(wrapc_stream_size_in_matrix_i_35_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_35_V, wrapc_stream_size_in_matrix_i_35_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_36_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_36_V, tvin_matrix_i_36_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V, tvin_matrix_i_36_V);

		sc_bv<16>* matrix_i_36_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_109 - aesl_tmp_110];

		// RTL Name: matrix_i_36_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_109 - aesl_tmp_110 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_109 - aesl_tmp_110 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_108[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_108[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_108[i_0]
						if (&(aesl_tmp_108[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_108[i_0];
							matrix_i_36_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_109 - aesl_tmp_110; i++)
		{
			sprintf(tvin_matrix_i_36_V, "%s\n", (matrix_i_36_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_36_V, tvin_matrix_i_36_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_36_V = aesl_tmp_109;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V, stream_ingress_size_matrix_i_36_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V, "\n");

		for (int i = 0; i < aesl_tmp_109 - aesl_tmp_110; i++)
		{
			stream_ingress_size_matrix_i_36_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V, stream_ingress_size_matrix_i_36_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_109 - aesl_tmp_110, &tcl_file.matrix_i_36_V_depth);
		sprintf(tvin_matrix_i_36_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_36_V, tvin_matrix_i_36_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_36_V, tvin_matrix_i_36_V);

		// release memory allocation
		delete [] matrix_i_36_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_36_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_36_V, wrapc_stream_size_in_matrix_i_36_V);
		sprintf(wrapc_stream_size_in_matrix_i_36_V, "%d\n", aesl_tmp_109 - aesl_tmp_110);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_36_V, wrapc_stream_size_in_matrix_i_36_V);
		sprintf(wrapc_stream_size_in_matrix_i_36_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_36_V, wrapc_stream_size_in_matrix_i_36_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_37_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_37_V, tvin_matrix_i_37_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V, tvin_matrix_i_37_V);

		sc_bv<16>* matrix_i_37_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_112 - aesl_tmp_113];

		// RTL Name: matrix_i_37_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_112 - aesl_tmp_113 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_112 - aesl_tmp_113 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_111[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_111[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_111[i_0]
						if (&(aesl_tmp_111[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_111[i_0];
							matrix_i_37_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_112 - aesl_tmp_113; i++)
		{
			sprintf(tvin_matrix_i_37_V, "%s\n", (matrix_i_37_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_37_V, tvin_matrix_i_37_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_37_V = aesl_tmp_112;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V, stream_ingress_size_matrix_i_37_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V, "\n");

		for (int i = 0; i < aesl_tmp_112 - aesl_tmp_113; i++)
		{
			stream_ingress_size_matrix_i_37_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V, stream_ingress_size_matrix_i_37_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_112 - aesl_tmp_113, &tcl_file.matrix_i_37_V_depth);
		sprintf(tvin_matrix_i_37_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_37_V, tvin_matrix_i_37_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_37_V, tvin_matrix_i_37_V);

		// release memory allocation
		delete [] matrix_i_37_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_37_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_37_V, wrapc_stream_size_in_matrix_i_37_V);
		sprintf(wrapc_stream_size_in_matrix_i_37_V, "%d\n", aesl_tmp_112 - aesl_tmp_113);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_37_V, wrapc_stream_size_in_matrix_i_37_V);
		sprintf(wrapc_stream_size_in_matrix_i_37_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_37_V, wrapc_stream_size_in_matrix_i_37_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_38_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_38_V, tvin_matrix_i_38_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V, tvin_matrix_i_38_V);

		sc_bv<16>* matrix_i_38_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_115 - aesl_tmp_116];

		// RTL Name: matrix_i_38_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_115 - aesl_tmp_116 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_115 - aesl_tmp_116 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_114[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_114[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_114[i_0]
						if (&(aesl_tmp_114[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_114[i_0];
							matrix_i_38_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_115 - aesl_tmp_116; i++)
		{
			sprintf(tvin_matrix_i_38_V, "%s\n", (matrix_i_38_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_38_V, tvin_matrix_i_38_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_38_V = aesl_tmp_115;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V, stream_ingress_size_matrix_i_38_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V, "\n");

		for (int i = 0; i < aesl_tmp_115 - aesl_tmp_116; i++)
		{
			stream_ingress_size_matrix_i_38_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V, stream_ingress_size_matrix_i_38_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_115 - aesl_tmp_116, &tcl_file.matrix_i_38_V_depth);
		sprintf(tvin_matrix_i_38_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_38_V, tvin_matrix_i_38_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_38_V, tvin_matrix_i_38_V);

		// release memory allocation
		delete [] matrix_i_38_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_38_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_38_V, wrapc_stream_size_in_matrix_i_38_V);
		sprintf(wrapc_stream_size_in_matrix_i_38_V, "%d\n", aesl_tmp_115 - aesl_tmp_116);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_38_V, wrapc_stream_size_in_matrix_i_38_V);
		sprintf(wrapc_stream_size_in_matrix_i_38_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_38_V, wrapc_stream_size_in_matrix_i_38_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_39_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_39_V, tvin_matrix_i_39_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V, tvin_matrix_i_39_V);

		sc_bv<16>* matrix_i_39_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_118 - aesl_tmp_119];

		// RTL Name: matrix_i_39_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_118 - aesl_tmp_119 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_118 - aesl_tmp_119 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_117[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_117[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_117[i_0]
						if (&(aesl_tmp_117[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_117[i_0];
							matrix_i_39_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_118 - aesl_tmp_119; i++)
		{
			sprintf(tvin_matrix_i_39_V, "%s\n", (matrix_i_39_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_39_V, tvin_matrix_i_39_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_39_V = aesl_tmp_118;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V, stream_ingress_size_matrix_i_39_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V, "\n");

		for (int i = 0; i < aesl_tmp_118 - aesl_tmp_119; i++)
		{
			stream_ingress_size_matrix_i_39_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V, stream_ingress_size_matrix_i_39_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_118 - aesl_tmp_119, &tcl_file.matrix_i_39_V_depth);
		sprintf(tvin_matrix_i_39_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_39_V, tvin_matrix_i_39_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_39_V, tvin_matrix_i_39_V);

		// release memory allocation
		delete [] matrix_i_39_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_39_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_39_V, wrapc_stream_size_in_matrix_i_39_V);
		sprintf(wrapc_stream_size_in_matrix_i_39_V, "%d\n", aesl_tmp_118 - aesl_tmp_119);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_39_V, wrapc_stream_size_in_matrix_i_39_V);
		sprintf(wrapc_stream_size_in_matrix_i_39_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_39_V, wrapc_stream_size_in_matrix_i_39_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_40_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_40_V, tvin_matrix_i_40_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V, tvin_matrix_i_40_V);

		sc_bv<16>* matrix_i_40_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_121 - aesl_tmp_122];

		// RTL Name: matrix_i_40_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_121 - aesl_tmp_122 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_121 - aesl_tmp_122 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_120[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_120[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_120[i_0]
						if (&(aesl_tmp_120[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_120[i_0];
							matrix_i_40_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_121 - aesl_tmp_122; i++)
		{
			sprintf(tvin_matrix_i_40_V, "%s\n", (matrix_i_40_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_40_V, tvin_matrix_i_40_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_40_V = aesl_tmp_121;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V, stream_ingress_size_matrix_i_40_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V, "\n");

		for (int i = 0; i < aesl_tmp_121 - aesl_tmp_122; i++)
		{
			stream_ingress_size_matrix_i_40_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V, stream_ingress_size_matrix_i_40_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_121 - aesl_tmp_122, &tcl_file.matrix_i_40_V_depth);
		sprintf(tvin_matrix_i_40_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_40_V, tvin_matrix_i_40_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_40_V, tvin_matrix_i_40_V);

		// release memory allocation
		delete [] matrix_i_40_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_40_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_40_V, wrapc_stream_size_in_matrix_i_40_V);
		sprintf(wrapc_stream_size_in_matrix_i_40_V, "%d\n", aesl_tmp_121 - aesl_tmp_122);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_40_V, wrapc_stream_size_in_matrix_i_40_V);
		sprintf(wrapc_stream_size_in_matrix_i_40_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_40_V, wrapc_stream_size_in_matrix_i_40_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_41_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_41_V, tvin_matrix_i_41_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V, tvin_matrix_i_41_V);

		sc_bv<16>* matrix_i_41_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_124 - aesl_tmp_125];

		// RTL Name: matrix_i_41_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_124 - aesl_tmp_125 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_124 - aesl_tmp_125 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_123[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_123[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_123[i_0]
						if (&(aesl_tmp_123[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_123[i_0];
							matrix_i_41_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_124 - aesl_tmp_125; i++)
		{
			sprintf(tvin_matrix_i_41_V, "%s\n", (matrix_i_41_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_41_V, tvin_matrix_i_41_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_41_V = aesl_tmp_124;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V, stream_ingress_size_matrix_i_41_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V, "\n");

		for (int i = 0; i < aesl_tmp_124 - aesl_tmp_125; i++)
		{
			stream_ingress_size_matrix_i_41_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V, stream_ingress_size_matrix_i_41_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_124 - aesl_tmp_125, &tcl_file.matrix_i_41_V_depth);
		sprintf(tvin_matrix_i_41_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_41_V, tvin_matrix_i_41_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_41_V, tvin_matrix_i_41_V);

		// release memory allocation
		delete [] matrix_i_41_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_41_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_41_V, wrapc_stream_size_in_matrix_i_41_V);
		sprintf(wrapc_stream_size_in_matrix_i_41_V, "%d\n", aesl_tmp_124 - aesl_tmp_125);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_41_V, wrapc_stream_size_in_matrix_i_41_V);
		sprintf(wrapc_stream_size_in_matrix_i_41_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_41_V, wrapc_stream_size_in_matrix_i_41_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_42_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_42_V, tvin_matrix_i_42_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V, tvin_matrix_i_42_V);

		sc_bv<16>* matrix_i_42_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_127 - aesl_tmp_128];

		// RTL Name: matrix_i_42_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_127 - aesl_tmp_128 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_127 - aesl_tmp_128 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_126[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_126[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_126[i_0]
						if (&(aesl_tmp_126[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_126[i_0];
							matrix_i_42_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_127 - aesl_tmp_128; i++)
		{
			sprintf(tvin_matrix_i_42_V, "%s\n", (matrix_i_42_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_42_V, tvin_matrix_i_42_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_42_V = aesl_tmp_127;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V, stream_ingress_size_matrix_i_42_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V, "\n");

		for (int i = 0; i < aesl_tmp_127 - aesl_tmp_128; i++)
		{
			stream_ingress_size_matrix_i_42_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V, stream_ingress_size_matrix_i_42_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_127 - aesl_tmp_128, &tcl_file.matrix_i_42_V_depth);
		sprintf(tvin_matrix_i_42_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_42_V, tvin_matrix_i_42_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_42_V, tvin_matrix_i_42_V);

		// release memory allocation
		delete [] matrix_i_42_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_42_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_42_V, wrapc_stream_size_in_matrix_i_42_V);
		sprintf(wrapc_stream_size_in_matrix_i_42_V, "%d\n", aesl_tmp_127 - aesl_tmp_128);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_42_V, wrapc_stream_size_in_matrix_i_42_V);
		sprintf(wrapc_stream_size_in_matrix_i_42_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_42_V, wrapc_stream_size_in_matrix_i_42_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_43_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_43_V, tvin_matrix_i_43_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V, tvin_matrix_i_43_V);

		sc_bv<16>* matrix_i_43_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_130 - aesl_tmp_131];

		// RTL Name: matrix_i_43_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_130 - aesl_tmp_131 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_130 - aesl_tmp_131 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_129[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_129[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_129[i_0]
						if (&(aesl_tmp_129[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_129[i_0];
							matrix_i_43_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_130 - aesl_tmp_131; i++)
		{
			sprintf(tvin_matrix_i_43_V, "%s\n", (matrix_i_43_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_43_V, tvin_matrix_i_43_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_43_V = aesl_tmp_130;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V, stream_ingress_size_matrix_i_43_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V, "\n");

		for (int i = 0; i < aesl_tmp_130 - aesl_tmp_131; i++)
		{
			stream_ingress_size_matrix_i_43_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V, stream_ingress_size_matrix_i_43_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_130 - aesl_tmp_131, &tcl_file.matrix_i_43_V_depth);
		sprintf(tvin_matrix_i_43_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_43_V, tvin_matrix_i_43_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_43_V, tvin_matrix_i_43_V);

		// release memory allocation
		delete [] matrix_i_43_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_43_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_43_V, wrapc_stream_size_in_matrix_i_43_V);
		sprintf(wrapc_stream_size_in_matrix_i_43_V, "%d\n", aesl_tmp_130 - aesl_tmp_131);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_43_V, wrapc_stream_size_in_matrix_i_43_V);
		sprintf(wrapc_stream_size_in_matrix_i_43_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_43_V, wrapc_stream_size_in_matrix_i_43_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_44_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_44_V, tvin_matrix_i_44_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V, tvin_matrix_i_44_V);

		sc_bv<16>* matrix_i_44_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_133 - aesl_tmp_134];

		// RTL Name: matrix_i_44_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_133 - aesl_tmp_134 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_133 - aesl_tmp_134 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_132[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_132[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_132[i_0]
						if (&(aesl_tmp_132[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_132[i_0];
							matrix_i_44_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_133 - aesl_tmp_134; i++)
		{
			sprintf(tvin_matrix_i_44_V, "%s\n", (matrix_i_44_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_44_V, tvin_matrix_i_44_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_44_V = aesl_tmp_133;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V, stream_ingress_size_matrix_i_44_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V, "\n");

		for (int i = 0; i < aesl_tmp_133 - aesl_tmp_134; i++)
		{
			stream_ingress_size_matrix_i_44_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V, stream_ingress_size_matrix_i_44_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_133 - aesl_tmp_134, &tcl_file.matrix_i_44_V_depth);
		sprintf(tvin_matrix_i_44_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_44_V, tvin_matrix_i_44_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_44_V, tvin_matrix_i_44_V);

		// release memory allocation
		delete [] matrix_i_44_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_44_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_44_V, wrapc_stream_size_in_matrix_i_44_V);
		sprintf(wrapc_stream_size_in_matrix_i_44_V, "%d\n", aesl_tmp_133 - aesl_tmp_134);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_44_V, wrapc_stream_size_in_matrix_i_44_V);
		sprintf(wrapc_stream_size_in_matrix_i_44_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_44_V, wrapc_stream_size_in_matrix_i_44_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_45_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_45_V, tvin_matrix_i_45_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V, tvin_matrix_i_45_V);

		sc_bv<16>* matrix_i_45_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_136 - aesl_tmp_137];

		// RTL Name: matrix_i_45_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_136 - aesl_tmp_137 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_136 - aesl_tmp_137 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_135[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_135[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_135[i_0]
						if (&(aesl_tmp_135[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_135[i_0];
							matrix_i_45_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_136 - aesl_tmp_137; i++)
		{
			sprintf(tvin_matrix_i_45_V, "%s\n", (matrix_i_45_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_45_V, tvin_matrix_i_45_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_45_V = aesl_tmp_136;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V, stream_ingress_size_matrix_i_45_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V, "\n");

		for (int i = 0; i < aesl_tmp_136 - aesl_tmp_137; i++)
		{
			stream_ingress_size_matrix_i_45_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V, stream_ingress_size_matrix_i_45_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_136 - aesl_tmp_137, &tcl_file.matrix_i_45_V_depth);
		sprintf(tvin_matrix_i_45_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_45_V, tvin_matrix_i_45_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_45_V, tvin_matrix_i_45_V);

		// release memory allocation
		delete [] matrix_i_45_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_45_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_45_V, wrapc_stream_size_in_matrix_i_45_V);
		sprintf(wrapc_stream_size_in_matrix_i_45_V, "%d\n", aesl_tmp_136 - aesl_tmp_137);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_45_V, wrapc_stream_size_in_matrix_i_45_V);
		sprintf(wrapc_stream_size_in_matrix_i_45_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_45_V, wrapc_stream_size_in_matrix_i_45_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_46_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_46_V, tvin_matrix_i_46_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V, tvin_matrix_i_46_V);

		sc_bv<16>* matrix_i_46_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_139 - aesl_tmp_140];

		// RTL Name: matrix_i_46_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_139 - aesl_tmp_140 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_139 - aesl_tmp_140 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_138[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_138[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_138[i_0]
						if (&(aesl_tmp_138[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_138[i_0];
							matrix_i_46_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_139 - aesl_tmp_140; i++)
		{
			sprintf(tvin_matrix_i_46_V, "%s\n", (matrix_i_46_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_46_V, tvin_matrix_i_46_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_46_V = aesl_tmp_139;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V, stream_ingress_size_matrix_i_46_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V, "\n");

		for (int i = 0; i < aesl_tmp_139 - aesl_tmp_140; i++)
		{
			stream_ingress_size_matrix_i_46_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V, stream_ingress_size_matrix_i_46_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_139 - aesl_tmp_140, &tcl_file.matrix_i_46_V_depth);
		sprintf(tvin_matrix_i_46_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_46_V, tvin_matrix_i_46_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_46_V, tvin_matrix_i_46_V);

		// release memory allocation
		delete [] matrix_i_46_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_46_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_46_V, wrapc_stream_size_in_matrix_i_46_V);
		sprintf(wrapc_stream_size_in_matrix_i_46_V, "%d\n", aesl_tmp_139 - aesl_tmp_140);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_46_V, wrapc_stream_size_in_matrix_i_46_V);
		sprintf(wrapc_stream_size_in_matrix_i_46_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_46_V, wrapc_stream_size_in_matrix_i_46_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_47_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_47_V, tvin_matrix_i_47_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V, tvin_matrix_i_47_V);

		sc_bv<16>* matrix_i_47_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_142 - aesl_tmp_143];

		// RTL Name: matrix_i_47_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_142 - aesl_tmp_143 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_142 - aesl_tmp_143 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_141[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_141[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_141[i_0]
						if (&(aesl_tmp_141[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_141[i_0];
							matrix_i_47_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_142 - aesl_tmp_143; i++)
		{
			sprintf(tvin_matrix_i_47_V, "%s\n", (matrix_i_47_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_47_V, tvin_matrix_i_47_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_47_V = aesl_tmp_142;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V, stream_ingress_size_matrix_i_47_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V, "\n");

		for (int i = 0; i < aesl_tmp_142 - aesl_tmp_143; i++)
		{
			stream_ingress_size_matrix_i_47_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V, stream_ingress_size_matrix_i_47_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_142 - aesl_tmp_143, &tcl_file.matrix_i_47_V_depth);
		sprintf(tvin_matrix_i_47_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_47_V, tvin_matrix_i_47_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_47_V, tvin_matrix_i_47_V);

		// release memory allocation
		delete [] matrix_i_47_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_47_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_47_V, wrapc_stream_size_in_matrix_i_47_V);
		sprintf(wrapc_stream_size_in_matrix_i_47_V, "%d\n", aesl_tmp_142 - aesl_tmp_143);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_47_V, wrapc_stream_size_in_matrix_i_47_V);
		sprintf(wrapc_stream_size_in_matrix_i_47_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_47_V, wrapc_stream_size_in_matrix_i_47_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_48_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_48_V, tvin_matrix_i_48_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V, tvin_matrix_i_48_V);

		sc_bv<16>* matrix_i_48_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_145 - aesl_tmp_146];

		// RTL Name: matrix_i_48_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_145 - aesl_tmp_146 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_145 - aesl_tmp_146 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_144[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_144[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_144[i_0]
						if (&(aesl_tmp_144[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_144[i_0];
							matrix_i_48_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_145 - aesl_tmp_146; i++)
		{
			sprintf(tvin_matrix_i_48_V, "%s\n", (matrix_i_48_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_48_V, tvin_matrix_i_48_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_48_V = aesl_tmp_145;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V, stream_ingress_size_matrix_i_48_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V, "\n");

		for (int i = 0; i < aesl_tmp_145 - aesl_tmp_146; i++)
		{
			stream_ingress_size_matrix_i_48_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V, stream_ingress_size_matrix_i_48_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_145 - aesl_tmp_146, &tcl_file.matrix_i_48_V_depth);
		sprintf(tvin_matrix_i_48_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_48_V, tvin_matrix_i_48_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_48_V, tvin_matrix_i_48_V);

		// release memory allocation
		delete [] matrix_i_48_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_48_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_48_V, wrapc_stream_size_in_matrix_i_48_V);
		sprintf(wrapc_stream_size_in_matrix_i_48_V, "%d\n", aesl_tmp_145 - aesl_tmp_146);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_48_V, wrapc_stream_size_in_matrix_i_48_V);
		sprintf(wrapc_stream_size_in_matrix_i_48_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_48_V, wrapc_stream_size_in_matrix_i_48_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_49_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_49_V, tvin_matrix_i_49_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V, tvin_matrix_i_49_V);

		sc_bv<16>* matrix_i_49_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_148 - aesl_tmp_149];

		// RTL Name: matrix_i_49_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_148 - aesl_tmp_149 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_148 - aesl_tmp_149 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_147[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_147[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_147[i_0]
						if (&(aesl_tmp_147[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_147[i_0];
							matrix_i_49_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_148 - aesl_tmp_149; i++)
		{
			sprintf(tvin_matrix_i_49_V, "%s\n", (matrix_i_49_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_49_V, tvin_matrix_i_49_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_49_V = aesl_tmp_148;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V, stream_ingress_size_matrix_i_49_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V, "\n");

		for (int i = 0; i < aesl_tmp_148 - aesl_tmp_149; i++)
		{
			stream_ingress_size_matrix_i_49_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V, stream_ingress_size_matrix_i_49_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_148 - aesl_tmp_149, &tcl_file.matrix_i_49_V_depth);
		sprintf(tvin_matrix_i_49_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_49_V, tvin_matrix_i_49_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_49_V, tvin_matrix_i_49_V);

		// release memory allocation
		delete [] matrix_i_49_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_49_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_49_V, wrapc_stream_size_in_matrix_i_49_V);
		sprintf(wrapc_stream_size_in_matrix_i_49_V, "%d\n", aesl_tmp_148 - aesl_tmp_149);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_49_V, wrapc_stream_size_in_matrix_i_49_V);
		sprintf(wrapc_stream_size_in_matrix_i_49_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_49_V, wrapc_stream_size_in_matrix_i_49_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_50_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_50_V, tvin_matrix_i_50_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V, tvin_matrix_i_50_V);

		sc_bv<16>* matrix_i_50_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_151 - aesl_tmp_152];

		// RTL Name: matrix_i_50_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_151 - aesl_tmp_152 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_151 - aesl_tmp_152 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_150[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_150[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_150[i_0]
						if (&(aesl_tmp_150[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_150[i_0];
							matrix_i_50_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_151 - aesl_tmp_152; i++)
		{
			sprintf(tvin_matrix_i_50_V, "%s\n", (matrix_i_50_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_50_V, tvin_matrix_i_50_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_50_V = aesl_tmp_151;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V, stream_ingress_size_matrix_i_50_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V, "\n");

		for (int i = 0; i < aesl_tmp_151 - aesl_tmp_152; i++)
		{
			stream_ingress_size_matrix_i_50_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V, stream_ingress_size_matrix_i_50_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_151 - aesl_tmp_152, &tcl_file.matrix_i_50_V_depth);
		sprintf(tvin_matrix_i_50_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_50_V, tvin_matrix_i_50_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_50_V, tvin_matrix_i_50_V);

		// release memory allocation
		delete [] matrix_i_50_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_50_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_50_V, wrapc_stream_size_in_matrix_i_50_V);
		sprintf(wrapc_stream_size_in_matrix_i_50_V, "%d\n", aesl_tmp_151 - aesl_tmp_152);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_50_V, wrapc_stream_size_in_matrix_i_50_V);
		sprintf(wrapc_stream_size_in_matrix_i_50_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_50_V, wrapc_stream_size_in_matrix_i_50_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_51_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_51_V, tvin_matrix_i_51_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V, tvin_matrix_i_51_V);

		sc_bv<16>* matrix_i_51_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_154 - aesl_tmp_155];

		// RTL Name: matrix_i_51_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_154 - aesl_tmp_155 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_154 - aesl_tmp_155 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_153[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_153[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_153[i_0]
						if (&(aesl_tmp_153[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_153[i_0];
							matrix_i_51_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_154 - aesl_tmp_155; i++)
		{
			sprintf(tvin_matrix_i_51_V, "%s\n", (matrix_i_51_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_51_V, tvin_matrix_i_51_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_51_V = aesl_tmp_154;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V, stream_ingress_size_matrix_i_51_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V, "\n");

		for (int i = 0; i < aesl_tmp_154 - aesl_tmp_155; i++)
		{
			stream_ingress_size_matrix_i_51_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V, stream_ingress_size_matrix_i_51_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_154 - aesl_tmp_155, &tcl_file.matrix_i_51_V_depth);
		sprintf(tvin_matrix_i_51_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_51_V, tvin_matrix_i_51_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_51_V, tvin_matrix_i_51_V);

		// release memory allocation
		delete [] matrix_i_51_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_51_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_51_V, wrapc_stream_size_in_matrix_i_51_V);
		sprintf(wrapc_stream_size_in_matrix_i_51_V, "%d\n", aesl_tmp_154 - aesl_tmp_155);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_51_V, wrapc_stream_size_in_matrix_i_51_V);
		sprintf(wrapc_stream_size_in_matrix_i_51_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_51_V, wrapc_stream_size_in_matrix_i_51_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_52_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_52_V, tvin_matrix_i_52_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V, tvin_matrix_i_52_V);

		sc_bv<16>* matrix_i_52_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_157 - aesl_tmp_158];

		// RTL Name: matrix_i_52_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_157 - aesl_tmp_158 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_157 - aesl_tmp_158 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_156[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_156[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_156[i_0]
						if (&(aesl_tmp_156[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_156[i_0];
							matrix_i_52_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_157 - aesl_tmp_158; i++)
		{
			sprintf(tvin_matrix_i_52_V, "%s\n", (matrix_i_52_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_52_V, tvin_matrix_i_52_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_52_V = aesl_tmp_157;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V, stream_ingress_size_matrix_i_52_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V, "\n");

		for (int i = 0; i < aesl_tmp_157 - aesl_tmp_158; i++)
		{
			stream_ingress_size_matrix_i_52_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V, stream_ingress_size_matrix_i_52_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_157 - aesl_tmp_158, &tcl_file.matrix_i_52_V_depth);
		sprintf(tvin_matrix_i_52_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_52_V, tvin_matrix_i_52_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_52_V, tvin_matrix_i_52_V);

		// release memory allocation
		delete [] matrix_i_52_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_52_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_52_V, wrapc_stream_size_in_matrix_i_52_V);
		sprintf(wrapc_stream_size_in_matrix_i_52_V, "%d\n", aesl_tmp_157 - aesl_tmp_158);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_52_V, wrapc_stream_size_in_matrix_i_52_V);
		sprintf(wrapc_stream_size_in_matrix_i_52_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_52_V, wrapc_stream_size_in_matrix_i_52_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_53_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_53_V, tvin_matrix_i_53_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V, tvin_matrix_i_53_V);

		sc_bv<16>* matrix_i_53_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_160 - aesl_tmp_161];

		// RTL Name: matrix_i_53_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_160 - aesl_tmp_161 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_160 - aesl_tmp_161 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_159[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_159[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_159[i_0]
						if (&(aesl_tmp_159[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_159[i_0];
							matrix_i_53_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_160 - aesl_tmp_161; i++)
		{
			sprintf(tvin_matrix_i_53_V, "%s\n", (matrix_i_53_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_53_V, tvin_matrix_i_53_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_53_V = aesl_tmp_160;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V, stream_ingress_size_matrix_i_53_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V, "\n");

		for (int i = 0; i < aesl_tmp_160 - aesl_tmp_161; i++)
		{
			stream_ingress_size_matrix_i_53_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V, stream_ingress_size_matrix_i_53_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_160 - aesl_tmp_161, &tcl_file.matrix_i_53_V_depth);
		sprintf(tvin_matrix_i_53_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_53_V, tvin_matrix_i_53_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_53_V, tvin_matrix_i_53_V);

		// release memory allocation
		delete [] matrix_i_53_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_53_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_53_V, wrapc_stream_size_in_matrix_i_53_V);
		sprintf(wrapc_stream_size_in_matrix_i_53_V, "%d\n", aesl_tmp_160 - aesl_tmp_161);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_53_V, wrapc_stream_size_in_matrix_i_53_V);
		sprintf(wrapc_stream_size_in_matrix_i_53_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_53_V, wrapc_stream_size_in_matrix_i_53_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_54_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_54_V, tvin_matrix_i_54_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V, tvin_matrix_i_54_V);

		sc_bv<16>* matrix_i_54_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_163 - aesl_tmp_164];

		// RTL Name: matrix_i_54_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_163 - aesl_tmp_164 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_163 - aesl_tmp_164 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_162[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_162[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_162[i_0]
						if (&(aesl_tmp_162[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_162[i_0];
							matrix_i_54_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_163 - aesl_tmp_164; i++)
		{
			sprintf(tvin_matrix_i_54_V, "%s\n", (matrix_i_54_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_54_V, tvin_matrix_i_54_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_54_V = aesl_tmp_163;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V, stream_ingress_size_matrix_i_54_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V, "\n");

		for (int i = 0; i < aesl_tmp_163 - aesl_tmp_164; i++)
		{
			stream_ingress_size_matrix_i_54_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V, stream_ingress_size_matrix_i_54_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_163 - aesl_tmp_164, &tcl_file.matrix_i_54_V_depth);
		sprintf(tvin_matrix_i_54_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_54_V, tvin_matrix_i_54_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_54_V, tvin_matrix_i_54_V);

		// release memory allocation
		delete [] matrix_i_54_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_54_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_54_V, wrapc_stream_size_in_matrix_i_54_V);
		sprintf(wrapc_stream_size_in_matrix_i_54_V, "%d\n", aesl_tmp_163 - aesl_tmp_164);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_54_V, wrapc_stream_size_in_matrix_i_54_V);
		sprintf(wrapc_stream_size_in_matrix_i_54_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_54_V, wrapc_stream_size_in_matrix_i_54_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_55_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_55_V, tvin_matrix_i_55_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V, tvin_matrix_i_55_V);

		sc_bv<16>* matrix_i_55_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_166 - aesl_tmp_167];

		// RTL Name: matrix_i_55_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_166 - aesl_tmp_167 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_166 - aesl_tmp_167 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_165[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_165[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_165[i_0]
						if (&(aesl_tmp_165[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_165[i_0];
							matrix_i_55_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_166 - aesl_tmp_167; i++)
		{
			sprintf(tvin_matrix_i_55_V, "%s\n", (matrix_i_55_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_55_V, tvin_matrix_i_55_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_55_V = aesl_tmp_166;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V, stream_ingress_size_matrix_i_55_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V, "\n");

		for (int i = 0; i < aesl_tmp_166 - aesl_tmp_167; i++)
		{
			stream_ingress_size_matrix_i_55_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V, stream_ingress_size_matrix_i_55_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_166 - aesl_tmp_167, &tcl_file.matrix_i_55_V_depth);
		sprintf(tvin_matrix_i_55_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_55_V, tvin_matrix_i_55_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_55_V, tvin_matrix_i_55_V);

		// release memory allocation
		delete [] matrix_i_55_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_55_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_55_V, wrapc_stream_size_in_matrix_i_55_V);
		sprintf(wrapc_stream_size_in_matrix_i_55_V, "%d\n", aesl_tmp_166 - aesl_tmp_167);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_55_V, wrapc_stream_size_in_matrix_i_55_V);
		sprintf(wrapc_stream_size_in_matrix_i_55_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_55_V, wrapc_stream_size_in_matrix_i_55_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_56_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_56_V, tvin_matrix_i_56_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V, tvin_matrix_i_56_V);

		sc_bv<16>* matrix_i_56_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_169 - aesl_tmp_170];

		// RTL Name: matrix_i_56_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_169 - aesl_tmp_170 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_169 - aesl_tmp_170 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_168[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_168[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_168[i_0]
						if (&(aesl_tmp_168[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_168[i_0];
							matrix_i_56_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_169 - aesl_tmp_170; i++)
		{
			sprintf(tvin_matrix_i_56_V, "%s\n", (matrix_i_56_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_56_V, tvin_matrix_i_56_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_56_V = aesl_tmp_169;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V, stream_ingress_size_matrix_i_56_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V, "\n");

		for (int i = 0; i < aesl_tmp_169 - aesl_tmp_170; i++)
		{
			stream_ingress_size_matrix_i_56_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V, stream_ingress_size_matrix_i_56_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_169 - aesl_tmp_170, &tcl_file.matrix_i_56_V_depth);
		sprintf(tvin_matrix_i_56_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_56_V, tvin_matrix_i_56_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_56_V, tvin_matrix_i_56_V);

		// release memory allocation
		delete [] matrix_i_56_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_56_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_56_V, wrapc_stream_size_in_matrix_i_56_V);
		sprintf(wrapc_stream_size_in_matrix_i_56_V, "%d\n", aesl_tmp_169 - aesl_tmp_170);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_56_V, wrapc_stream_size_in_matrix_i_56_V);
		sprintf(wrapc_stream_size_in_matrix_i_56_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_56_V, wrapc_stream_size_in_matrix_i_56_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_57_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_57_V, tvin_matrix_i_57_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V, tvin_matrix_i_57_V);

		sc_bv<16>* matrix_i_57_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_172 - aesl_tmp_173];

		// RTL Name: matrix_i_57_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_172 - aesl_tmp_173 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_172 - aesl_tmp_173 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_171[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_171[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_171[i_0]
						if (&(aesl_tmp_171[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_171[i_0];
							matrix_i_57_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_172 - aesl_tmp_173; i++)
		{
			sprintf(tvin_matrix_i_57_V, "%s\n", (matrix_i_57_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_57_V, tvin_matrix_i_57_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_57_V = aesl_tmp_172;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V, stream_ingress_size_matrix_i_57_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V, "\n");

		for (int i = 0; i < aesl_tmp_172 - aesl_tmp_173; i++)
		{
			stream_ingress_size_matrix_i_57_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V, stream_ingress_size_matrix_i_57_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_172 - aesl_tmp_173, &tcl_file.matrix_i_57_V_depth);
		sprintf(tvin_matrix_i_57_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_57_V, tvin_matrix_i_57_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_57_V, tvin_matrix_i_57_V);

		// release memory allocation
		delete [] matrix_i_57_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_57_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_57_V, wrapc_stream_size_in_matrix_i_57_V);
		sprintf(wrapc_stream_size_in_matrix_i_57_V, "%d\n", aesl_tmp_172 - aesl_tmp_173);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_57_V, wrapc_stream_size_in_matrix_i_57_V);
		sprintf(wrapc_stream_size_in_matrix_i_57_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_57_V, wrapc_stream_size_in_matrix_i_57_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_58_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_58_V, tvin_matrix_i_58_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V, tvin_matrix_i_58_V);

		sc_bv<16>* matrix_i_58_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_175 - aesl_tmp_176];

		// RTL Name: matrix_i_58_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_175 - aesl_tmp_176 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_175 - aesl_tmp_176 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_174[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_174[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_174[i_0]
						if (&(aesl_tmp_174[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_174[i_0];
							matrix_i_58_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_175 - aesl_tmp_176; i++)
		{
			sprintf(tvin_matrix_i_58_V, "%s\n", (matrix_i_58_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_58_V, tvin_matrix_i_58_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_58_V = aesl_tmp_175;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V, stream_ingress_size_matrix_i_58_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V, "\n");

		for (int i = 0; i < aesl_tmp_175 - aesl_tmp_176; i++)
		{
			stream_ingress_size_matrix_i_58_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V, stream_ingress_size_matrix_i_58_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_175 - aesl_tmp_176, &tcl_file.matrix_i_58_V_depth);
		sprintf(tvin_matrix_i_58_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_58_V, tvin_matrix_i_58_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_58_V, tvin_matrix_i_58_V);

		// release memory allocation
		delete [] matrix_i_58_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_58_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_58_V, wrapc_stream_size_in_matrix_i_58_V);
		sprintf(wrapc_stream_size_in_matrix_i_58_V, "%d\n", aesl_tmp_175 - aesl_tmp_176);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_58_V, wrapc_stream_size_in_matrix_i_58_V);
		sprintf(wrapc_stream_size_in_matrix_i_58_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_58_V, wrapc_stream_size_in_matrix_i_58_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_59_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_59_V, tvin_matrix_i_59_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V, tvin_matrix_i_59_V);

		sc_bv<16>* matrix_i_59_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_178 - aesl_tmp_179];

		// RTL Name: matrix_i_59_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_178 - aesl_tmp_179 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_178 - aesl_tmp_179 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_177[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_177[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_177[i_0]
						if (&(aesl_tmp_177[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_177[i_0];
							matrix_i_59_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_178 - aesl_tmp_179; i++)
		{
			sprintf(tvin_matrix_i_59_V, "%s\n", (matrix_i_59_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_59_V, tvin_matrix_i_59_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_59_V = aesl_tmp_178;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V, stream_ingress_size_matrix_i_59_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V, "\n");

		for (int i = 0; i < aesl_tmp_178 - aesl_tmp_179; i++)
		{
			stream_ingress_size_matrix_i_59_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V, stream_ingress_size_matrix_i_59_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_178 - aesl_tmp_179, &tcl_file.matrix_i_59_V_depth);
		sprintf(tvin_matrix_i_59_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_59_V, tvin_matrix_i_59_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_59_V, tvin_matrix_i_59_V);

		// release memory allocation
		delete [] matrix_i_59_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_59_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_59_V, wrapc_stream_size_in_matrix_i_59_V);
		sprintf(wrapc_stream_size_in_matrix_i_59_V, "%d\n", aesl_tmp_178 - aesl_tmp_179);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_59_V, wrapc_stream_size_in_matrix_i_59_V);
		sprintf(wrapc_stream_size_in_matrix_i_59_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_59_V, wrapc_stream_size_in_matrix_i_59_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_60_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_60_V, tvin_matrix_i_60_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V, tvin_matrix_i_60_V);

		sc_bv<16>* matrix_i_60_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_181 - aesl_tmp_182];

		// RTL Name: matrix_i_60_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_181 - aesl_tmp_182 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_181 - aesl_tmp_182 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_180[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_180[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_180[i_0]
						if (&(aesl_tmp_180[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_180[i_0];
							matrix_i_60_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_181 - aesl_tmp_182; i++)
		{
			sprintf(tvin_matrix_i_60_V, "%s\n", (matrix_i_60_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_60_V, tvin_matrix_i_60_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_60_V = aesl_tmp_181;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V, stream_ingress_size_matrix_i_60_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V, "\n");

		for (int i = 0; i < aesl_tmp_181 - aesl_tmp_182; i++)
		{
			stream_ingress_size_matrix_i_60_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V, stream_ingress_size_matrix_i_60_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_181 - aesl_tmp_182, &tcl_file.matrix_i_60_V_depth);
		sprintf(tvin_matrix_i_60_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_60_V, tvin_matrix_i_60_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_60_V, tvin_matrix_i_60_V);

		// release memory allocation
		delete [] matrix_i_60_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_60_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_60_V, wrapc_stream_size_in_matrix_i_60_V);
		sprintf(wrapc_stream_size_in_matrix_i_60_V, "%d\n", aesl_tmp_181 - aesl_tmp_182);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_60_V, wrapc_stream_size_in_matrix_i_60_V);
		sprintf(wrapc_stream_size_in_matrix_i_60_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_60_V, wrapc_stream_size_in_matrix_i_60_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_61_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_61_V, tvin_matrix_i_61_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V, tvin_matrix_i_61_V);

		sc_bv<16>* matrix_i_61_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_184 - aesl_tmp_185];

		// RTL Name: matrix_i_61_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_184 - aesl_tmp_185 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_184 - aesl_tmp_185 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_183[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_183[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_183[i_0]
						if (&(aesl_tmp_183[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_183[i_0];
							matrix_i_61_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_184 - aesl_tmp_185; i++)
		{
			sprintf(tvin_matrix_i_61_V, "%s\n", (matrix_i_61_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_61_V, tvin_matrix_i_61_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_61_V = aesl_tmp_184;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V, stream_ingress_size_matrix_i_61_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V, "\n");

		for (int i = 0; i < aesl_tmp_184 - aesl_tmp_185; i++)
		{
			stream_ingress_size_matrix_i_61_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V, stream_ingress_size_matrix_i_61_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_184 - aesl_tmp_185, &tcl_file.matrix_i_61_V_depth);
		sprintf(tvin_matrix_i_61_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_61_V, tvin_matrix_i_61_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_61_V, tvin_matrix_i_61_V);

		// release memory allocation
		delete [] matrix_i_61_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_61_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_61_V, wrapc_stream_size_in_matrix_i_61_V);
		sprintf(wrapc_stream_size_in_matrix_i_61_V, "%d\n", aesl_tmp_184 - aesl_tmp_185);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_61_V, wrapc_stream_size_in_matrix_i_61_V);
		sprintf(wrapc_stream_size_in_matrix_i_61_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_61_V, wrapc_stream_size_in_matrix_i_61_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_62_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_62_V, tvin_matrix_i_62_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V, tvin_matrix_i_62_V);

		sc_bv<16>* matrix_i_62_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_187 - aesl_tmp_188];

		// RTL Name: matrix_i_62_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_187 - aesl_tmp_188 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_187 - aesl_tmp_188 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_186[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_186[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_186[i_0]
						if (&(aesl_tmp_186[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_186[i_0];
							matrix_i_62_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_187 - aesl_tmp_188; i++)
		{
			sprintf(tvin_matrix_i_62_V, "%s\n", (matrix_i_62_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_62_V, tvin_matrix_i_62_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_62_V = aesl_tmp_187;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V, stream_ingress_size_matrix_i_62_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V, "\n");

		for (int i = 0; i < aesl_tmp_187 - aesl_tmp_188; i++)
		{
			stream_ingress_size_matrix_i_62_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V, stream_ingress_size_matrix_i_62_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_187 - aesl_tmp_188, &tcl_file.matrix_i_62_V_depth);
		sprintf(tvin_matrix_i_62_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_62_V, tvin_matrix_i_62_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_62_V, tvin_matrix_i_62_V);

		// release memory allocation
		delete [] matrix_i_62_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_62_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_62_V, wrapc_stream_size_in_matrix_i_62_V);
		sprintf(wrapc_stream_size_in_matrix_i_62_V, "%d\n", aesl_tmp_187 - aesl_tmp_188);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_62_V, wrapc_stream_size_in_matrix_i_62_V);
		sprintf(wrapc_stream_size_in_matrix_i_62_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_62_V, wrapc_stream_size_in_matrix_i_62_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_63_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_63_V, tvin_matrix_i_63_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V, tvin_matrix_i_63_V);

		sc_bv<16>* matrix_i_63_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_190 - aesl_tmp_191];

		// RTL Name: matrix_i_63_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_190 - aesl_tmp_191 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_190 - aesl_tmp_191 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_189[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_189[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_189[i_0]
						if (&(aesl_tmp_189[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_189[i_0];
							matrix_i_63_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_190 - aesl_tmp_191; i++)
		{
			sprintf(tvin_matrix_i_63_V, "%s\n", (matrix_i_63_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_63_V, tvin_matrix_i_63_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_63_V = aesl_tmp_190;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V, stream_ingress_size_matrix_i_63_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V, "\n");

		for (int i = 0; i < aesl_tmp_190 - aesl_tmp_191; i++)
		{
			stream_ingress_size_matrix_i_63_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V, stream_ingress_size_matrix_i_63_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_190 - aesl_tmp_191, &tcl_file.matrix_i_63_V_depth);
		sprintf(tvin_matrix_i_63_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_63_V, tvin_matrix_i_63_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_63_V, tvin_matrix_i_63_V);

		// release memory allocation
		delete [] matrix_i_63_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_63_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_63_V, wrapc_stream_size_in_matrix_i_63_V);
		sprintf(wrapc_stream_size_in_matrix_i_63_V, "%d\n", aesl_tmp_190 - aesl_tmp_191);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_63_V, wrapc_stream_size_in_matrix_i_63_V);
		sprintf(wrapc_stream_size_in_matrix_i_63_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_63_V, wrapc_stream_size_in_matrix_i_63_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_64_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_64_V, tvin_matrix_i_64_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V, tvin_matrix_i_64_V);

		sc_bv<16>* matrix_i_64_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_193 - aesl_tmp_194];

		// RTL Name: matrix_i_64_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_193 - aesl_tmp_194 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_193 - aesl_tmp_194 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_192[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_192[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_192[i_0]
						if (&(aesl_tmp_192[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_192[i_0];
							matrix_i_64_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_193 - aesl_tmp_194; i++)
		{
			sprintf(tvin_matrix_i_64_V, "%s\n", (matrix_i_64_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_64_V, tvin_matrix_i_64_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_64_V = aesl_tmp_193;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V, stream_ingress_size_matrix_i_64_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V, "\n");

		for (int i = 0; i < aesl_tmp_193 - aesl_tmp_194; i++)
		{
			stream_ingress_size_matrix_i_64_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V, stream_ingress_size_matrix_i_64_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_193 - aesl_tmp_194, &tcl_file.matrix_i_64_V_depth);
		sprintf(tvin_matrix_i_64_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_64_V, tvin_matrix_i_64_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_64_V, tvin_matrix_i_64_V);

		// release memory allocation
		delete [] matrix_i_64_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_64_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_64_V, wrapc_stream_size_in_matrix_i_64_V);
		sprintf(wrapc_stream_size_in_matrix_i_64_V, "%d\n", aesl_tmp_193 - aesl_tmp_194);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_64_V, wrapc_stream_size_in_matrix_i_64_V);
		sprintf(wrapc_stream_size_in_matrix_i_64_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_64_V, wrapc_stream_size_in_matrix_i_64_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_65_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_65_V, tvin_matrix_i_65_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V, tvin_matrix_i_65_V);

		sc_bv<16>* matrix_i_65_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_196 - aesl_tmp_197];

		// RTL Name: matrix_i_65_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_196 - aesl_tmp_197 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_196 - aesl_tmp_197 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_195[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_195[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_195[i_0]
						if (&(aesl_tmp_195[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_195[i_0];
							matrix_i_65_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_196 - aesl_tmp_197; i++)
		{
			sprintf(tvin_matrix_i_65_V, "%s\n", (matrix_i_65_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_65_V, tvin_matrix_i_65_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_65_V = aesl_tmp_196;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V, stream_ingress_size_matrix_i_65_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V, "\n");

		for (int i = 0; i < aesl_tmp_196 - aesl_tmp_197; i++)
		{
			stream_ingress_size_matrix_i_65_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V, stream_ingress_size_matrix_i_65_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_196 - aesl_tmp_197, &tcl_file.matrix_i_65_V_depth);
		sprintf(tvin_matrix_i_65_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_65_V, tvin_matrix_i_65_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_65_V, tvin_matrix_i_65_V);

		// release memory allocation
		delete [] matrix_i_65_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_65_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_65_V, wrapc_stream_size_in_matrix_i_65_V);
		sprintf(wrapc_stream_size_in_matrix_i_65_V, "%d\n", aesl_tmp_196 - aesl_tmp_197);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_65_V, wrapc_stream_size_in_matrix_i_65_V);
		sprintf(wrapc_stream_size_in_matrix_i_65_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_65_V, wrapc_stream_size_in_matrix_i_65_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_66_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_66_V, tvin_matrix_i_66_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V, tvin_matrix_i_66_V);

		sc_bv<16>* matrix_i_66_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_199 - aesl_tmp_200];

		// RTL Name: matrix_i_66_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_199 - aesl_tmp_200 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_199 - aesl_tmp_200 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_198[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_198[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_198[i_0]
						if (&(aesl_tmp_198[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_198[i_0];
							matrix_i_66_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_199 - aesl_tmp_200; i++)
		{
			sprintf(tvin_matrix_i_66_V, "%s\n", (matrix_i_66_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_66_V, tvin_matrix_i_66_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_66_V = aesl_tmp_199;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V, stream_ingress_size_matrix_i_66_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V, "\n");

		for (int i = 0; i < aesl_tmp_199 - aesl_tmp_200; i++)
		{
			stream_ingress_size_matrix_i_66_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V, stream_ingress_size_matrix_i_66_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_199 - aesl_tmp_200, &tcl_file.matrix_i_66_V_depth);
		sprintf(tvin_matrix_i_66_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_66_V, tvin_matrix_i_66_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_66_V, tvin_matrix_i_66_V);

		// release memory allocation
		delete [] matrix_i_66_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_66_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_66_V, wrapc_stream_size_in_matrix_i_66_V);
		sprintf(wrapc_stream_size_in_matrix_i_66_V, "%d\n", aesl_tmp_199 - aesl_tmp_200);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_66_V, wrapc_stream_size_in_matrix_i_66_V);
		sprintf(wrapc_stream_size_in_matrix_i_66_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_66_V, wrapc_stream_size_in_matrix_i_66_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_67_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_67_V, tvin_matrix_i_67_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V, tvin_matrix_i_67_V);

		sc_bv<16>* matrix_i_67_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_202 - aesl_tmp_203];

		// RTL Name: matrix_i_67_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_202 - aesl_tmp_203 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_202 - aesl_tmp_203 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_201[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_201[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_201[i_0]
						if (&(aesl_tmp_201[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_201[i_0];
							matrix_i_67_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_202 - aesl_tmp_203; i++)
		{
			sprintf(tvin_matrix_i_67_V, "%s\n", (matrix_i_67_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_67_V, tvin_matrix_i_67_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_67_V = aesl_tmp_202;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V, stream_ingress_size_matrix_i_67_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V, "\n");

		for (int i = 0; i < aesl_tmp_202 - aesl_tmp_203; i++)
		{
			stream_ingress_size_matrix_i_67_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V, stream_ingress_size_matrix_i_67_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_202 - aesl_tmp_203, &tcl_file.matrix_i_67_V_depth);
		sprintf(tvin_matrix_i_67_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_67_V, tvin_matrix_i_67_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_67_V, tvin_matrix_i_67_V);

		// release memory allocation
		delete [] matrix_i_67_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_67_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_67_V, wrapc_stream_size_in_matrix_i_67_V);
		sprintf(wrapc_stream_size_in_matrix_i_67_V, "%d\n", aesl_tmp_202 - aesl_tmp_203);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_67_V, wrapc_stream_size_in_matrix_i_67_V);
		sprintf(wrapc_stream_size_in_matrix_i_67_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_67_V, wrapc_stream_size_in_matrix_i_67_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_68_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_68_V, tvin_matrix_i_68_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V, tvin_matrix_i_68_V);

		sc_bv<16>* matrix_i_68_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_205 - aesl_tmp_206];

		// RTL Name: matrix_i_68_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_205 - aesl_tmp_206 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_205 - aesl_tmp_206 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_204[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_204[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_204[i_0]
						if (&(aesl_tmp_204[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_204[i_0];
							matrix_i_68_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_205 - aesl_tmp_206; i++)
		{
			sprintf(tvin_matrix_i_68_V, "%s\n", (matrix_i_68_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_68_V, tvin_matrix_i_68_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_68_V = aesl_tmp_205;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V, stream_ingress_size_matrix_i_68_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V, "\n");

		for (int i = 0; i < aesl_tmp_205 - aesl_tmp_206; i++)
		{
			stream_ingress_size_matrix_i_68_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V, stream_ingress_size_matrix_i_68_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_205 - aesl_tmp_206, &tcl_file.matrix_i_68_V_depth);
		sprintf(tvin_matrix_i_68_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_68_V, tvin_matrix_i_68_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_68_V, tvin_matrix_i_68_V);

		// release memory allocation
		delete [] matrix_i_68_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_68_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_68_V, wrapc_stream_size_in_matrix_i_68_V);
		sprintf(wrapc_stream_size_in_matrix_i_68_V, "%d\n", aesl_tmp_205 - aesl_tmp_206);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_68_V, wrapc_stream_size_in_matrix_i_68_V);
		sprintf(wrapc_stream_size_in_matrix_i_68_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_68_V, wrapc_stream_size_in_matrix_i_68_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_69_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_69_V, tvin_matrix_i_69_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V, tvin_matrix_i_69_V);

		sc_bv<16>* matrix_i_69_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_208 - aesl_tmp_209];

		// RTL Name: matrix_i_69_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_208 - aesl_tmp_209 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_208 - aesl_tmp_209 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_207[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_207[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_207[i_0]
						if (&(aesl_tmp_207[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_207[i_0];
							matrix_i_69_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_208 - aesl_tmp_209; i++)
		{
			sprintf(tvin_matrix_i_69_V, "%s\n", (matrix_i_69_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_69_V, tvin_matrix_i_69_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_69_V = aesl_tmp_208;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V, stream_ingress_size_matrix_i_69_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V, "\n");

		for (int i = 0; i < aesl_tmp_208 - aesl_tmp_209; i++)
		{
			stream_ingress_size_matrix_i_69_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V, stream_ingress_size_matrix_i_69_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_208 - aesl_tmp_209, &tcl_file.matrix_i_69_V_depth);
		sprintf(tvin_matrix_i_69_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_69_V, tvin_matrix_i_69_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_69_V, tvin_matrix_i_69_V);

		// release memory allocation
		delete [] matrix_i_69_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_69_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_69_V, wrapc_stream_size_in_matrix_i_69_V);
		sprintf(wrapc_stream_size_in_matrix_i_69_V, "%d\n", aesl_tmp_208 - aesl_tmp_209);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_69_V, wrapc_stream_size_in_matrix_i_69_V);
		sprintf(wrapc_stream_size_in_matrix_i_69_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_69_V, wrapc_stream_size_in_matrix_i_69_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_70_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_70_V, tvin_matrix_i_70_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V, tvin_matrix_i_70_V);

		sc_bv<16>* matrix_i_70_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_211 - aesl_tmp_212];

		// RTL Name: matrix_i_70_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_211 - aesl_tmp_212 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_211 - aesl_tmp_212 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_210[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_210[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_210[i_0]
						if (&(aesl_tmp_210[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_210[i_0];
							matrix_i_70_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_211 - aesl_tmp_212; i++)
		{
			sprintf(tvin_matrix_i_70_V, "%s\n", (matrix_i_70_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_70_V, tvin_matrix_i_70_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_70_V = aesl_tmp_211;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V, stream_ingress_size_matrix_i_70_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V, "\n");

		for (int i = 0; i < aesl_tmp_211 - aesl_tmp_212; i++)
		{
			stream_ingress_size_matrix_i_70_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V, stream_ingress_size_matrix_i_70_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_211 - aesl_tmp_212, &tcl_file.matrix_i_70_V_depth);
		sprintf(tvin_matrix_i_70_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_70_V, tvin_matrix_i_70_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_70_V, tvin_matrix_i_70_V);

		// release memory allocation
		delete [] matrix_i_70_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_70_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_70_V, wrapc_stream_size_in_matrix_i_70_V);
		sprintf(wrapc_stream_size_in_matrix_i_70_V, "%d\n", aesl_tmp_211 - aesl_tmp_212);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_70_V, wrapc_stream_size_in_matrix_i_70_V);
		sprintf(wrapc_stream_size_in_matrix_i_70_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_70_V, wrapc_stream_size_in_matrix_i_70_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_71_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_71_V, tvin_matrix_i_71_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V, tvin_matrix_i_71_V);

		sc_bv<16>* matrix_i_71_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_214 - aesl_tmp_215];

		// RTL Name: matrix_i_71_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_214 - aesl_tmp_215 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_214 - aesl_tmp_215 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_213[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_213[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_213[i_0]
						if (&(aesl_tmp_213[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_213[i_0];
							matrix_i_71_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_214 - aesl_tmp_215; i++)
		{
			sprintf(tvin_matrix_i_71_V, "%s\n", (matrix_i_71_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_71_V, tvin_matrix_i_71_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_71_V = aesl_tmp_214;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V, stream_ingress_size_matrix_i_71_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V, "\n");

		for (int i = 0; i < aesl_tmp_214 - aesl_tmp_215; i++)
		{
			stream_ingress_size_matrix_i_71_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V, stream_ingress_size_matrix_i_71_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_214 - aesl_tmp_215, &tcl_file.matrix_i_71_V_depth);
		sprintf(tvin_matrix_i_71_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_71_V, tvin_matrix_i_71_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_71_V, tvin_matrix_i_71_V);

		// release memory allocation
		delete [] matrix_i_71_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_71_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_71_V, wrapc_stream_size_in_matrix_i_71_V);
		sprintf(wrapc_stream_size_in_matrix_i_71_V, "%d\n", aesl_tmp_214 - aesl_tmp_215);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_71_V, wrapc_stream_size_in_matrix_i_71_V);
		sprintf(wrapc_stream_size_in_matrix_i_71_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_71_V, wrapc_stream_size_in_matrix_i_71_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_72_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_72_V, tvin_matrix_i_72_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V, tvin_matrix_i_72_V);

		sc_bv<16>* matrix_i_72_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_217 - aesl_tmp_218];

		// RTL Name: matrix_i_72_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_217 - aesl_tmp_218 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_217 - aesl_tmp_218 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_216[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_216[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_216[i_0]
						if (&(aesl_tmp_216[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_216[i_0];
							matrix_i_72_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_217 - aesl_tmp_218; i++)
		{
			sprintf(tvin_matrix_i_72_V, "%s\n", (matrix_i_72_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_72_V, tvin_matrix_i_72_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_72_V = aesl_tmp_217;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V, stream_ingress_size_matrix_i_72_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V, "\n");

		for (int i = 0; i < aesl_tmp_217 - aesl_tmp_218; i++)
		{
			stream_ingress_size_matrix_i_72_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V, stream_ingress_size_matrix_i_72_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_217 - aesl_tmp_218, &tcl_file.matrix_i_72_V_depth);
		sprintf(tvin_matrix_i_72_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_72_V, tvin_matrix_i_72_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_72_V, tvin_matrix_i_72_V);

		// release memory allocation
		delete [] matrix_i_72_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_72_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_72_V, wrapc_stream_size_in_matrix_i_72_V);
		sprintf(wrapc_stream_size_in_matrix_i_72_V, "%d\n", aesl_tmp_217 - aesl_tmp_218);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_72_V, wrapc_stream_size_in_matrix_i_72_V);
		sprintf(wrapc_stream_size_in_matrix_i_72_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_72_V, wrapc_stream_size_in_matrix_i_72_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_73_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_73_V, tvin_matrix_i_73_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V, tvin_matrix_i_73_V);

		sc_bv<16>* matrix_i_73_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_220 - aesl_tmp_221];

		// RTL Name: matrix_i_73_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_220 - aesl_tmp_221 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_220 - aesl_tmp_221 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_219[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_219[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_219[i_0]
						if (&(aesl_tmp_219[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_219[i_0];
							matrix_i_73_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_220 - aesl_tmp_221; i++)
		{
			sprintf(tvin_matrix_i_73_V, "%s\n", (matrix_i_73_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_73_V, tvin_matrix_i_73_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_73_V = aesl_tmp_220;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V, stream_ingress_size_matrix_i_73_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V, "\n");

		for (int i = 0; i < aesl_tmp_220 - aesl_tmp_221; i++)
		{
			stream_ingress_size_matrix_i_73_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V, stream_ingress_size_matrix_i_73_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_220 - aesl_tmp_221, &tcl_file.matrix_i_73_V_depth);
		sprintf(tvin_matrix_i_73_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_73_V, tvin_matrix_i_73_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_73_V, tvin_matrix_i_73_V);

		// release memory allocation
		delete [] matrix_i_73_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_73_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_73_V, wrapc_stream_size_in_matrix_i_73_V);
		sprintf(wrapc_stream_size_in_matrix_i_73_V, "%d\n", aesl_tmp_220 - aesl_tmp_221);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_73_V, wrapc_stream_size_in_matrix_i_73_V);
		sprintf(wrapc_stream_size_in_matrix_i_73_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_73_V, wrapc_stream_size_in_matrix_i_73_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_74_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_74_V, tvin_matrix_i_74_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V, tvin_matrix_i_74_V);

		sc_bv<16>* matrix_i_74_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_223 - aesl_tmp_224];

		// RTL Name: matrix_i_74_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_223 - aesl_tmp_224 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_223 - aesl_tmp_224 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_222[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_222[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_222[i_0]
						if (&(aesl_tmp_222[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_222[i_0];
							matrix_i_74_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_223 - aesl_tmp_224; i++)
		{
			sprintf(tvin_matrix_i_74_V, "%s\n", (matrix_i_74_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_74_V, tvin_matrix_i_74_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_74_V = aesl_tmp_223;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V, stream_ingress_size_matrix_i_74_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V, "\n");

		for (int i = 0; i < aesl_tmp_223 - aesl_tmp_224; i++)
		{
			stream_ingress_size_matrix_i_74_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V, stream_ingress_size_matrix_i_74_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_223 - aesl_tmp_224, &tcl_file.matrix_i_74_V_depth);
		sprintf(tvin_matrix_i_74_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_74_V, tvin_matrix_i_74_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_74_V, tvin_matrix_i_74_V);

		// release memory allocation
		delete [] matrix_i_74_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_74_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_74_V, wrapc_stream_size_in_matrix_i_74_V);
		sprintf(wrapc_stream_size_in_matrix_i_74_V, "%d\n", aesl_tmp_223 - aesl_tmp_224);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_74_V, wrapc_stream_size_in_matrix_i_74_V);
		sprintf(wrapc_stream_size_in_matrix_i_74_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_74_V, wrapc_stream_size_in_matrix_i_74_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_75_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_75_V, tvin_matrix_i_75_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V, tvin_matrix_i_75_V);

		sc_bv<16>* matrix_i_75_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_226 - aesl_tmp_227];

		// RTL Name: matrix_i_75_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_226 - aesl_tmp_227 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_226 - aesl_tmp_227 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_225[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_225[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_225[i_0]
						if (&(aesl_tmp_225[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_225[i_0];
							matrix_i_75_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_226 - aesl_tmp_227; i++)
		{
			sprintf(tvin_matrix_i_75_V, "%s\n", (matrix_i_75_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_75_V, tvin_matrix_i_75_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_75_V = aesl_tmp_226;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V, stream_ingress_size_matrix_i_75_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V, "\n");

		for (int i = 0; i < aesl_tmp_226 - aesl_tmp_227; i++)
		{
			stream_ingress_size_matrix_i_75_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V, stream_ingress_size_matrix_i_75_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_226 - aesl_tmp_227, &tcl_file.matrix_i_75_V_depth);
		sprintf(tvin_matrix_i_75_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_75_V, tvin_matrix_i_75_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_75_V, tvin_matrix_i_75_V);

		// release memory allocation
		delete [] matrix_i_75_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_75_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_75_V, wrapc_stream_size_in_matrix_i_75_V);
		sprintf(wrapc_stream_size_in_matrix_i_75_V, "%d\n", aesl_tmp_226 - aesl_tmp_227);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_75_V, wrapc_stream_size_in_matrix_i_75_V);
		sprintf(wrapc_stream_size_in_matrix_i_75_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_75_V, wrapc_stream_size_in_matrix_i_75_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_76_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_76_V, tvin_matrix_i_76_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V, tvin_matrix_i_76_V);

		sc_bv<16>* matrix_i_76_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_229 - aesl_tmp_230];

		// RTL Name: matrix_i_76_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_229 - aesl_tmp_230 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_229 - aesl_tmp_230 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_228[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_228[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_228[i_0]
						if (&(aesl_tmp_228[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_228[i_0];
							matrix_i_76_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_229 - aesl_tmp_230; i++)
		{
			sprintf(tvin_matrix_i_76_V, "%s\n", (matrix_i_76_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_76_V, tvin_matrix_i_76_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_76_V = aesl_tmp_229;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V, stream_ingress_size_matrix_i_76_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V, "\n");

		for (int i = 0; i < aesl_tmp_229 - aesl_tmp_230; i++)
		{
			stream_ingress_size_matrix_i_76_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V, stream_ingress_size_matrix_i_76_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_229 - aesl_tmp_230, &tcl_file.matrix_i_76_V_depth);
		sprintf(tvin_matrix_i_76_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_76_V, tvin_matrix_i_76_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_76_V, tvin_matrix_i_76_V);

		// release memory allocation
		delete [] matrix_i_76_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_76_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_76_V, wrapc_stream_size_in_matrix_i_76_V);
		sprintf(wrapc_stream_size_in_matrix_i_76_V, "%d\n", aesl_tmp_229 - aesl_tmp_230);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_76_V, wrapc_stream_size_in_matrix_i_76_V);
		sprintf(wrapc_stream_size_in_matrix_i_76_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_76_V, wrapc_stream_size_in_matrix_i_76_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_77_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_77_V, tvin_matrix_i_77_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V, tvin_matrix_i_77_V);

		sc_bv<16>* matrix_i_77_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_232 - aesl_tmp_233];

		// RTL Name: matrix_i_77_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_232 - aesl_tmp_233 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_232 - aesl_tmp_233 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_231[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_231[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_231[i_0]
						if (&(aesl_tmp_231[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_231[i_0];
							matrix_i_77_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_232 - aesl_tmp_233; i++)
		{
			sprintf(tvin_matrix_i_77_V, "%s\n", (matrix_i_77_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_77_V, tvin_matrix_i_77_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_77_V = aesl_tmp_232;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V, stream_ingress_size_matrix_i_77_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V, "\n");

		for (int i = 0; i < aesl_tmp_232 - aesl_tmp_233; i++)
		{
			stream_ingress_size_matrix_i_77_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V, stream_ingress_size_matrix_i_77_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_232 - aesl_tmp_233, &tcl_file.matrix_i_77_V_depth);
		sprintf(tvin_matrix_i_77_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_77_V, tvin_matrix_i_77_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_77_V, tvin_matrix_i_77_V);

		// release memory allocation
		delete [] matrix_i_77_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_77_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_77_V, wrapc_stream_size_in_matrix_i_77_V);
		sprintf(wrapc_stream_size_in_matrix_i_77_V, "%d\n", aesl_tmp_232 - aesl_tmp_233);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_77_V, wrapc_stream_size_in_matrix_i_77_V);
		sprintf(wrapc_stream_size_in_matrix_i_77_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_77_V, wrapc_stream_size_in_matrix_i_77_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_78_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_78_V, tvin_matrix_i_78_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V, tvin_matrix_i_78_V);

		sc_bv<16>* matrix_i_78_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_235 - aesl_tmp_236];

		// RTL Name: matrix_i_78_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_235 - aesl_tmp_236 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_235 - aesl_tmp_236 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_234[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_234[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_234[i_0]
						if (&(aesl_tmp_234[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_234[i_0];
							matrix_i_78_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_235 - aesl_tmp_236; i++)
		{
			sprintf(tvin_matrix_i_78_V, "%s\n", (matrix_i_78_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_78_V, tvin_matrix_i_78_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_78_V = aesl_tmp_235;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V, stream_ingress_size_matrix_i_78_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V, "\n");

		for (int i = 0; i < aesl_tmp_235 - aesl_tmp_236; i++)
		{
			stream_ingress_size_matrix_i_78_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V, stream_ingress_size_matrix_i_78_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_235 - aesl_tmp_236, &tcl_file.matrix_i_78_V_depth);
		sprintf(tvin_matrix_i_78_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_78_V, tvin_matrix_i_78_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_78_V, tvin_matrix_i_78_V);

		// release memory allocation
		delete [] matrix_i_78_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_78_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_78_V, wrapc_stream_size_in_matrix_i_78_V);
		sprintf(wrapc_stream_size_in_matrix_i_78_V, "%d\n", aesl_tmp_235 - aesl_tmp_236);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_78_V, wrapc_stream_size_in_matrix_i_78_V);
		sprintf(wrapc_stream_size_in_matrix_i_78_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_78_V, wrapc_stream_size_in_matrix_i_78_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_79_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_79_V, tvin_matrix_i_79_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V, tvin_matrix_i_79_V);

		sc_bv<16>* matrix_i_79_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_238 - aesl_tmp_239];

		// RTL Name: matrix_i_79_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_238 - aesl_tmp_239 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_238 - aesl_tmp_239 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_237[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_237[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_237[i_0]
						if (&(aesl_tmp_237[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_237[i_0];
							matrix_i_79_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_238 - aesl_tmp_239; i++)
		{
			sprintf(tvin_matrix_i_79_V, "%s\n", (matrix_i_79_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_79_V, tvin_matrix_i_79_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_79_V = aesl_tmp_238;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V, stream_ingress_size_matrix_i_79_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V, "\n");

		for (int i = 0; i < aesl_tmp_238 - aesl_tmp_239; i++)
		{
			stream_ingress_size_matrix_i_79_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V, stream_ingress_size_matrix_i_79_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_238 - aesl_tmp_239, &tcl_file.matrix_i_79_V_depth);
		sprintf(tvin_matrix_i_79_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_79_V, tvin_matrix_i_79_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_79_V, tvin_matrix_i_79_V);

		// release memory allocation
		delete [] matrix_i_79_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_79_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_79_V, wrapc_stream_size_in_matrix_i_79_V);
		sprintf(wrapc_stream_size_in_matrix_i_79_V, "%d\n", aesl_tmp_238 - aesl_tmp_239);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_79_V, wrapc_stream_size_in_matrix_i_79_V);
		sprintf(wrapc_stream_size_in_matrix_i_79_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_79_V, wrapc_stream_size_in_matrix_i_79_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_80_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_80_V, tvin_matrix_i_80_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V, tvin_matrix_i_80_V);

		sc_bv<16>* matrix_i_80_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_241 - aesl_tmp_242];

		// RTL Name: matrix_i_80_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_241 - aesl_tmp_242 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_241 - aesl_tmp_242 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_240[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_240[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_240[i_0]
						if (&(aesl_tmp_240[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_240[i_0];
							matrix_i_80_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_241 - aesl_tmp_242; i++)
		{
			sprintf(tvin_matrix_i_80_V, "%s\n", (matrix_i_80_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_80_V, tvin_matrix_i_80_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_80_V = aesl_tmp_241;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V, stream_ingress_size_matrix_i_80_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V, "\n");

		for (int i = 0; i < aesl_tmp_241 - aesl_tmp_242; i++)
		{
			stream_ingress_size_matrix_i_80_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V, stream_ingress_size_matrix_i_80_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_241 - aesl_tmp_242, &tcl_file.matrix_i_80_V_depth);
		sprintf(tvin_matrix_i_80_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_80_V, tvin_matrix_i_80_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_80_V, tvin_matrix_i_80_V);

		// release memory allocation
		delete [] matrix_i_80_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_80_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_80_V, wrapc_stream_size_in_matrix_i_80_V);
		sprintf(wrapc_stream_size_in_matrix_i_80_V, "%d\n", aesl_tmp_241 - aesl_tmp_242);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_80_V, wrapc_stream_size_in_matrix_i_80_V);
		sprintf(wrapc_stream_size_in_matrix_i_80_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_80_V, wrapc_stream_size_in_matrix_i_80_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_81_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_81_V, tvin_matrix_i_81_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V, tvin_matrix_i_81_V);

		sc_bv<16>* matrix_i_81_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_244 - aesl_tmp_245];

		// RTL Name: matrix_i_81_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_244 - aesl_tmp_245 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_244 - aesl_tmp_245 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_243[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_243[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_243[i_0]
						if (&(aesl_tmp_243[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_243[i_0];
							matrix_i_81_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_244 - aesl_tmp_245; i++)
		{
			sprintf(tvin_matrix_i_81_V, "%s\n", (matrix_i_81_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_81_V, tvin_matrix_i_81_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_81_V = aesl_tmp_244;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V, stream_ingress_size_matrix_i_81_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V, "\n");

		for (int i = 0; i < aesl_tmp_244 - aesl_tmp_245; i++)
		{
			stream_ingress_size_matrix_i_81_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V, stream_ingress_size_matrix_i_81_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_244 - aesl_tmp_245, &tcl_file.matrix_i_81_V_depth);
		sprintf(tvin_matrix_i_81_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_81_V, tvin_matrix_i_81_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_81_V, tvin_matrix_i_81_V);

		// release memory allocation
		delete [] matrix_i_81_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_81_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_81_V, wrapc_stream_size_in_matrix_i_81_V);
		sprintf(wrapc_stream_size_in_matrix_i_81_V, "%d\n", aesl_tmp_244 - aesl_tmp_245);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_81_V, wrapc_stream_size_in_matrix_i_81_V);
		sprintf(wrapc_stream_size_in_matrix_i_81_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_81_V, wrapc_stream_size_in_matrix_i_81_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_82_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_82_V, tvin_matrix_i_82_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V, tvin_matrix_i_82_V);

		sc_bv<16>* matrix_i_82_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_247 - aesl_tmp_248];

		// RTL Name: matrix_i_82_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_247 - aesl_tmp_248 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_247 - aesl_tmp_248 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_246[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_246[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_246[i_0]
						if (&(aesl_tmp_246[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_246[i_0];
							matrix_i_82_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_247 - aesl_tmp_248; i++)
		{
			sprintf(tvin_matrix_i_82_V, "%s\n", (matrix_i_82_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_82_V, tvin_matrix_i_82_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_82_V = aesl_tmp_247;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V, stream_ingress_size_matrix_i_82_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V, "\n");

		for (int i = 0; i < aesl_tmp_247 - aesl_tmp_248; i++)
		{
			stream_ingress_size_matrix_i_82_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V, stream_ingress_size_matrix_i_82_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_247 - aesl_tmp_248, &tcl_file.matrix_i_82_V_depth);
		sprintf(tvin_matrix_i_82_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_82_V, tvin_matrix_i_82_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_82_V, tvin_matrix_i_82_V);

		// release memory allocation
		delete [] matrix_i_82_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_82_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_82_V, wrapc_stream_size_in_matrix_i_82_V);
		sprintf(wrapc_stream_size_in_matrix_i_82_V, "%d\n", aesl_tmp_247 - aesl_tmp_248);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_82_V, wrapc_stream_size_in_matrix_i_82_V);
		sprintf(wrapc_stream_size_in_matrix_i_82_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_82_V, wrapc_stream_size_in_matrix_i_82_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_83_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_83_V, tvin_matrix_i_83_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V, tvin_matrix_i_83_V);

		sc_bv<16>* matrix_i_83_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_250 - aesl_tmp_251];

		// RTL Name: matrix_i_83_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_250 - aesl_tmp_251 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_250 - aesl_tmp_251 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_249[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_249[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_249[i_0]
						if (&(aesl_tmp_249[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_249[i_0];
							matrix_i_83_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_250 - aesl_tmp_251; i++)
		{
			sprintf(tvin_matrix_i_83_V, "%s\n", (matrix_i_83_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_83_V, tvin_matrix_i_83_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_83_V = aesl_tmp_250;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V, stream_ingress_size_matrix_i_83_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V, "\n");

		for (int i = 0; i < aesl_tmp_250 - aesl_tmp_251; i++)
		{
			stream_ingress_size_matrix_i_83_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V, stream_ingress_size_matrix_i_83_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_250 - aesl_tmp_251, &tcl_file.matrix_i_83_V_depth);
		sprintf(tvin_matrix_i_83_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_83_V, tvin_matrix_i_83_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_83_V, tvin_matrix_i_83_V);

		// release memory allocation
		delete [] matrix_i_83_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_83_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_83_V, wrapc_stream_size_in_matrix_i_83_V);
		sprintf(wrapc_stream_size_in_matrix_i_83_V, "%d\n", aesl_tmp_250 - aesl_tmp_251);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_83_V, wrapc_stream_size_in_matrix_i_83_V);
		sprintf(wrapc_stream_size_in_matrix_i_83_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_83_V, wrapc_stream_size_in_matrix_i_83_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_84_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_84_V, tvin_matrix_i_84_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V, tvin_matrix_i_84_V);

		sc_bv<16>* matrix_i_84_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_253 - aesl_tmp_254];

		// RTL Name: matrix_i_84_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_253 - aesl_tmp_254 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_253 - aesl_tmp_254 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_252[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_252[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_252[i_0]
						if (&(aesl_tmp_252[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_252[i_0];
							matrix_i_84_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_253 - aesl_tmp_254; i++)
		{
			sprintf(tvin_matrix_i_84_V, "%s\n", (matrix_i_84_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_84_V, tvin_matrix_i_84_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_84_V = aesl_tmp_253;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V, stream_ingress_size_matrix_i_84_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V, "\n");

		for (int i = 0; i < aesl_tmp_253 - aesl_tmp_254; i++)
		{
			stream_ingress_size_matrix_i_84_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V, stream_ingress_size_matrix_i_84_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_253 - aesl_tmp_254, &tcl_file.matrix_i_84_V_depth);
		sprintf(tvin_matrix_i_84_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_84_V, tvin_matrix_i_84_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_84_V, tvin_matrix_i_84_V);

		// release memory allocation
		delete [] matrix_i_84_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_84_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_84_V, wrapc_stream_size_in_matrix_i_84_V);
		sprintf(wrapc_stream_size_in_matrix_i_84_V, "%d\n", aesl_tmp_253 - aesl_tmp_254);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_84_V, wrapc_stream_size_in_matrix_i_84_V);
		sprintf(wrapc_stream_size_in_matrix_i_84_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_84_V, wrapc_stream_size_in_matrix_i_84_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_85_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_85_V, tvin_matrix_i_85_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V, tvin_matrix_i_85_V);

		sc_bv<16>* matrix_i_85_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_256 - aesl_tmp_257];

		// RTL Name: matrix_i_85_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_256 - aesl_tmp_257 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_256 - aesl_tmp_257 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_255[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_255[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_255[i_0]
						if (&(aesl_tmp_255[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_255[i_0];
							matrix_i_85_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_256 - aesl_tmp_257; i++)
		{
			sprintf(tvin_matrix_i_85_V, "%s\n", (matrix_i_85_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_85_V, tvin_matrix_i_85_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_85_V = aesl_tmp_256;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V, stream_ingress_size_matrix_i_85_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V, "\n");

		for (int i = 0; i < aesl_tmp_256 - aesl_tmp_257; i++)
		{
			stream_ingress_size_matrix_i_85_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V, stream_ingress_size_matrix_i_85_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_256 - aesl_tmp_257, &tcl_file.matrix_i_85_V_depth);
		sprintf(tvin_matrix_i_85_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_85_V, tvin_matrix_i_85_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_85_V, tvin_matrix_i_85_V);

		// release memory allocation
		delete [] matrix_i_85_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_85_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_85_V, wrapc_stream_size_in_matrix_i_85_V);
		sprintf(wrapc_stream_size_in_matrix_i_85_V, "%d\n", aesl_tmp_256 - aesl_tmp_257);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_85_V, wrapc_stream_size_in_matrix_i_85_V);
		sprintf(wrapc_stream_size_in_matrix_i_85_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_85_V, wrapc_stream_size_in_matrix_i_85_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_86_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_86_V, tvin_matrix_i_86_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V, tvin_matrix_i_86_V);

		sc_bv<16>* matrix_i_86_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_259 - aesl_tmp_260];

		// RTL Name: matrix_i_86_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_259 - aesl_tmp_260 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_259 - aesl_tmp_260 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_258[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_258[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_258[i_0]
						if (&(aesl_tmp_258[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_258[i_0];
							matrix_i_86_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_259 - aesl_tmp_260; i++)
		{
			sprintf(tvin_matrix_i_86_V, "%s\n", (matrix_i_86_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_86_V, tvin_matrix_i_86_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_86_V = aesl_tmp_259;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V, stream_ingress_size_matrix_i_86_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V, "\n");

		for (int i = 0; i < aesl_tmp_259 - aesl_tmp_260; i++)
		{
			stream_ingress_size_matrix_i_86_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V, stream_ingress_size_matrix_i_86_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_259 - aesl_tmp_260, &tcl_file.matrix_i_86_V_depth);
		sprintf(tvin_matrix_i_86_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_86_V, tvin_matrix_i_86_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_86_V, tvin_matrix_i_86_V);

		// release memory allocation
		delete [] matrix_i_86_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_86_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_86_V, wrapc_stream_size_in_matrix_i_86_V);
		sprintf(wrapc_stream_size_in_matrix_i_86_V, "%d\n", aesl_tmp_259 - aesl_tmp_260);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_86_V, wrapc_stream_size_in_matrix_i_86_V);
		sprintf(wrapc_stream_size_in_matrix_i_86_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_86_V, wrapc_stream_size_in_matrix_i_86_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_87_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_87_V, tvin_matrix_i_87_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V, tvin_matrix_i_87_V);

		sc_bv<16>* matrix_i_87_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_262 - aesl_tmp_263];

		// RTL Name: matrix_i_87_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_262 - aesl_tmp_263 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_262 - aesl_tmp_263 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_261[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_261[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_261[i_0]
						if (&(aesl_tmp_261[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_261[i_0];
							matrix_i_87_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_262 - aesl_tmp_263; i++)
		{
			sprintf(tvin_matrix_i_87_V, "%s\n", (matrix_i_87_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_87_V, tvin_matrix_i_87_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_87_V = aesl_tmp_262;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V, stream_ingress_size_matrix_i_87_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V, "\n");

		for (int i = 0; i < aesl_tmp_262 - aesl_tmp_263; i++)
		{
			stream_ingress_size_matrix_i_87_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V, stream_ingress_size_matrix_i_87_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_262 - aesl_tmp_263, &tcl_file.matrix_i_87_V_depth);
		sprintf(tvin_matrix_i_87_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_87_V, tvin_matrix_i_87_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_87_V, tvin_matrix_i_87_V);

		// release memory allocation
		delete [] matrix_i_87_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_87_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_87_V, wrapc_stream_size_in_matrix_i_87_V);
		sprintf(wrapc_stream_size_in_matrix_i_87_V, "%d\n", aesl_tmp_262 - aesl_tmp_263);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_87_V, wrapc_stream_size_in_matrix_i_87_V);
		sprintf(wrapc_stream_size_in_matrix_i_87_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_87_V, wrapc_stream_size_in_matrix_i_87_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_88_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_88_V, tvin_matrix_i_88_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V, tvin_matrix_i_88_V);

		sc_bv<16>* matrix_i_88_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_265 - aesl_tmp_266];

		// RTL Name: matrix_i_88_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_265 - aesl_tmp_266 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_265 - aesl_tmp_266 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_264[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_264[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_264[i_0]
						if (&(aesl_tmp_264[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_264[i_0];
							matrix_i_88_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_265 - aesl_tmp_266; i++)
		{
			sprintf(tvin_matrix_i_88_V, "%s\n", (matrix_i_88_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_88_V, tvin_matrix_i_88_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_88_V = aesl_tmp_265;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V, stream_ingress_size_matrix_i_88_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V, "\n");

		for (int i = 0; i < aesl_tmp_265 - aesl_tmp_266; i++)
		{
			stream_ingress_size_matrix_i_88_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V, stream_ingress_size_matrix_i_88_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_265 - aesl_tmp_266, &tcl_file.matrix_i_88_V_depth);
		sprintf(tvin_matrix_i_88_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_88_V, tvin_matrix_i_88_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_88_V, tvin_matrix_i_88_V);

		// release memory allocation
		delete [] matrix_i_88_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_88_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_88_V, wrapc_stream_size_in_matrix_i_88_V);
		sprintf(wrapc_stream_size_in_matrix_i_88_V, "%d\n", aesl_tmp_265 - aesl_tmp_266);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_88_V, wrapc_stream_size_in_matrix_i_88_V);
		sprintf(wrapc_stream_size_in_matrix_i_88_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_88_V, wrapc_stream_size_in_matrix_i_88_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_89_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_89_V, tvin_matrix_i_89_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V, tvin_matrix_i_89_V);

		sc_bv<16>* matrix_i_89_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_268 - aesl_tmp_269];

		// RTL Name: matrix_i_89_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_268 - aesl_tmp_269 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_268 - aesl_tmp_269 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_267[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_267[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_267[i_0]
						if (&(aesl_tmp_267[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_267[i_0];
							matrix_i_89_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_268 - aesl_tmp_269; i++)
		{
			sprintf(tvin_matrix_i_89_V, "%s\n", (matrix_i_89_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_89_V, tvin_matrix_i_89_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_89_V = aesl_tmp_268;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V, stream_ingress_size_matrix_i_89_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V, "\n");

		for (int i = 0; i < aesl_tmp_268 - aesl_tmp_269; i++)
		{
			stream_ingress_size_matrix_i_89_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V, stream_ingress_size_matrix_i_89_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_268 - aesl_tmp_269, &tcl_file.matrix_i_89_V_depth);
		sprintf(tvin_matrix_i_89_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_89_V, tvin_matrix_i_89_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_89_V, tvin_matrix_i_89_V);

		// release memory allocation
		delete [] matrix_i_89_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_89_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_89_V, wrapc_stream_size_in_matrix_i_89_V);
		sprintf(wrapc_stream_size_in_matrix_i_89_V, "%d\n", aesl_tmp_268 - aesl_tmp_269);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_89_V, wrapc_stream_size_in_matrix_i_89_V);
		sprintf(wrapc_stream_size_in_matrix_i_89_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_89_V, wrapc_stream_size_in_matrix_i_89_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_90_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_90_V, tvin_matrix_i_90_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V, tvin_matrix_i_90_V);

		sc_bv<16>* matrix_i_90_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_271 - aesl_tmp_272];

		// RTL Name: matrix_i_90_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_271 - aesl_tmp_272 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_271 - aesl_tmp_272 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_270[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_270[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_270[i_0]
						if (&(aesl_tmp_270[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_270[i_0];
							matrix_i_90_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_271 - aesl_tmp_272; i++)
		{
			sprintf(tvin_matrix_i_90_V, "%s\n", (matrix_i_90_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_90_V, tvin_matrix_i_90_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_90_V = aesl_tmp_271;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V, stream_ingress_size_matrix_i_90_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V, "\n");

		for (int i = 0; i < aesl_tmp_271 - aesl_tmp_272; i++)
		{
			stream_ingress_size_matrix_i_90_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V, stream_ingress_size_matrix_i_90_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_271 - aesl_tmp_272, &tcl_file.matrix_i_90_V_depth);
		sprintf(tvin_matrix_i_90_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_90_V, tvin_matrix_i_90_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_90_V, tvin_matrix_i_90_V);

		// release memory allocation
		delete [] matrix_i_90_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_90_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_90_V, wrapc_stream_size_in_matrix_i_90_V);
		sprintf(wrapc_stream_size_in_matrix_i_90_V, "%d\n", aesl_tmp_271 - aesl_tmp_272);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_90_V, wrapc_stream_size_in_matrix_i_90_V);
		sprintf(wrapc_stream_size_in_matrix_i_90_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_90_V, wrapc_stream_size_in_matrix_i_90_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_91_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_91_V, tvin_matrix_i_91_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V, tvin_matrix_i_91_V);

		sc_bv<16>* matrix_i_91_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_274 - aesl_tmp_275];

		// RTL Name: matrix_i_91_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_274 - aesl_tmp_275 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_274 - aesl_tmp_275 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_273[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_273[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_273[i_0]
						if (&(aesl_tmp_273[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_273[i_0];
							matrix_i_91_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_274 - aesl_tmp_275; i++)
		{
			sprintf(tvin_matrix_i_91_V, "%s\n", (matrix_i_91_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_91_V, tvin_matrix_i_91_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_91_V = aesl_tmp_274;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V, stream_ingress_size_matrix_i_91_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V, "\n");

		for (int i = 0; i < aesl_tmp_274 - aesl_tmp_275; i++)
		{
			stream_ingress_size_matrix_i_91_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V, stream_ingress_size_matrix_i_91_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_274 - aesl_tmp_275, &tcl_file.matrix_i_91_V_depth);
		sprintf(tvin_matrix_i_91_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_91_V, tvin_matrix_i_91_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_91_V, tvin_matrix_i_91_V);

		// release memory allocation
		delete [] matrix_i_91_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_91_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_91_V, wrapc_stream_size_in_matrix_i_91_V);
		sprintf(wrapc_stream_size_in_matrix_i_91_V, "%d\n", aesl_tmp_274 - aesl_tmp_275);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_91_V, wrapc_stream_size_in_matrix_i_91_V);
		sprintf(wrapc_stream_size_in_matrix_i_91_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_91_V, wrapc_stream_size_in_matrix_i_91_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_92_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_92_V, tvin_matrix_i_92_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V, tvin_matrix_i_92_V);

		sc_bv<16>* matrix_i_92_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_277 - aesl_tmp_278];

		// RTL Name: matrix_i_92_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_277 - aesl_tmp_278 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_277 - aesl_tmp_278 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_276[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_276[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_276[i_0]
						if (&(aesl_tmp_276[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_276[i_0];
							matrix_i_92_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_277 - aesl_tmp_278; i++)
		{
			sprintf(tvin_matrix_i_92_V, "%s\n", (matrix_i_92_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_92_V, tvin_matrix_i_92_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_92_V = aesl_tmp_277;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V, stream_ingress_size_matrix_i_92_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V, "\n");

		for (int i = 0; i < aesl_tmp_277 - aesl_tmp_278; i++)
		{
			stream_ingress_size_matrix_i_92_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V, stream_ingress_size_matrix_i_92_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_277 - aesl_tmp_278, &tcl_file.matrix_i_92_V_depth);
		sprintf(tvin_matrix_i_92_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_92_V, tvin_matrix_i_92_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_92_V, tvin_matrix_i_92_V);

		// release memory allocation
		delete [] matrix_i_92_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_92_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_92_V, wrapc_stream_size_in_matrix_i_92_V);
		sprintf(wrapc_stream_size_in_matrix_i_92_V, "%d\n", aesl_tmp_277 - aesl_tmp_278);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_92_V, wrapc_stream_size_in_matrix_i_92_V);
		sprintf(wrapc_stream_size_in_matrix_i_92_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_92_V, wrapc_stream_size_in_matrix_i_92_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_93_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_93_V, tvin_matrix_i_93_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V, tvin_matrix_i_93_V);

		sc_bv<16>* matrix_i_93_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_280 - aesl_tmp_281];

		// RTL Name: matrix_i_93_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_280 - aesl_tmp_281 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_280 - aesl_tmp_281 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_279[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_279[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_279[i_0]
						if (&(aesl_tmp_279[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_279[i_0];
							matrix_i_93_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_280 - aesl_tmp_281; i++)
		{
			sprintf(tvin_matrix_i_93_V, "%s\n", (matrix_i_93_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_93_V, tvin_matrix_i_93_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_93_V = aesl_tmp_280;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V, stream_ingress_size_matrix_i_93_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V, "\n");

		for (int i = 0; i < aesl_tmp_280 - aesl_tmp_281; i++)
		{
			stream_ingress_size_matrix_i_93_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V, stream_ingress_size_matrix_i_93_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_280 - aesl_tmp_281, &tcl_file.matrix_i_93_V_depth);
		sprintf(tvin_matrix_i_93_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_93_V, tvin_matrix_i_93_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_93_V, tvin_matrix_i_93_V);

		// release memory allocation
		delete [] matrix_i_93_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_93_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_93_V, wrapc_stream_size_in_matrix_i_93_V);
		sprintf(wrapc_stream_size_in_matrix_i_93_V, "%d\n", aesl_tmp_280 - aesl_tmp_281);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_93_V, wrapc_stream_size_in_matrix_i_93_V);
		sprintf(wrapc_stream_size_in_matrix_i_93_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_93_V, wrapc_stream_size_in_matrix_i_93_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_94_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_94_V, tvin_matrix_i_94_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V, tvin_matrix_i_94_V);

		sc_bv<16>* matrix_i_94_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_283 - aesl_tmp_284];

		// RTL Name: matrix_i_94_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_283 - aesl_tmp_284 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_283 - aesl_tmp_284 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_282[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_282[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_282[i_0]
						if (&(aesl_tmp_282[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_282[i_0];
							matrix_i_94_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_283 - aesl_tmp_284; i++)
		{
			sprintf(tvin_matrix_i_94_V, "%s\n", (matrix_i_94_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_94_V, tvin_matrix_i_94_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_94_V = aesl_tmp_283;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V, stream_ingress_size_matrix_i_94_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V, "\n");

		for (int i = 0; i < aesl_tmp_283 - aesl_tmp_284; i++)
		{
			stream_ingress_size_matrix_i_94_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V, stream_ingress_size_matrix_i_94_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_283 - aesl_tmp_284, &tcl_file.matrix_i_94_V_depth);
		sprintf(tvin_matrix_i_94_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_94_V, tvin_matrix_i_94_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_94_V, tvin_matrix_i_94_V);

		// release memory allocation
		delete [] matrix_i_94_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_94_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_94_V, wrapc_stream_size_in_matrix_i_94_V);
		sprintf(wrapc_stream_size_in_matrix_i_94_V, "%d\n", aesl_tmp_283 - aesl_tmp_284);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_94_V, wrapc_stream_size_in_matrix_i_94_V);
		sprintf(wrapc_stream_size_in_matrix_i_94_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_94_V, wrapc_stream_size_in_matrix_i_94_V);

		// [[transaction]]
		sprintf(tvin_matrix_i_95_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_matrix_i_95_V, tvin_matrix_i_95_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V, tvin_matrix_i_95_V);

		sc_bv<16>* matrix_i_95_V_tvin_wrapc_buffer = new sc_bv<16>[aesl_tmp_286 - aesl_tmp_287];

		// RTL Name: matrix_i_95_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_i.V(15, 0)
				{
					// carray: (0) => (aesl_tmp_286 - aesl_tmp_287 - 1) @ (1)
					for (int i_0 = 0; i_0 <= aesl_tmp_286 - aesl_tmp_287 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_285[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_285[0]
						// regulate_c_name       : matrix_i_V
						// input_type_conversion : aesl_tmp_285[i_0]
						if (&(aesl_tmp_285[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_i_V_tmp_mem;
							matrix_i_V_tmp_mem = aesl_tmp_285[i_0];
							matrix_i_95_V_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_i_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_286 - aesl_tmp_287; i++)
		{
			sprintf(tvin_matrix_i_95_V, "%s\n", (matrix_i_95_V_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_matrix_i_95_V, tvin_matrix_i_95_V);
		}

		// dump stream ingress status to file
		sc_int<32> stream_ingress_size_matrix_i_95_V = aesl_tmp_286;
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V, stream_ingress_size_matrix_i_95_V.to_string().c_str());
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V, "\n");

		for (int i = 0; i < aesl_tmp_286 - aesl_tmp_287; i++)
		{
			stream_ingress_size_matrix_i_95_V--;
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V, stream_ingress_size_matrix_i_95_V.to_string().c_str());
			aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V, "\n");
		}

		tcl_file.set_num(aesl_tmp_286 - aesl_tmp_287, &tcl_file.matrix_i_95_V_depth);
		sprintf(tvin_matrix_i_95_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_matrix_i_95_V, tvin_matrix_i_95_V);
		aesl_fh.write(WRAPC_STREAM_INGRESS_STATUS_matrix_i_95_V, tvin_matrix_i_95_V);

		// release memory allocation
		delete [] matrix_i_95_V_tvin_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_in_matrix_i_95_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_95_V, wrapc_stream_size_in_matrix_i_95_V);
		sprintf(wrapc_stream_size_in_matrix_i_95_V, "%d\n", aesl_tmp_286 - aesl_tmp_287);
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_95_V, wrapc_stream_size_in_matrix_i_95_V);
		sprintf(wrapc_stream_size_in_matrix_i_95_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_IN_matrix_i_95_V, wrapc_stream_size_in_matrix_i_95_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_0_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_0_V, tvout_matrix_o_0_V);

		sc_bv<16>* matrix_o_0_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_289 - aesl_tmp_290];

		// RTL Name: matrix_o_0_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_290) => (aesl_tmp_289 - 1) @ (1)
					for (int i_0 = aesl_tmp_290; i_0 <= aesl_tmp_289 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_288[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_288[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_288[i_0]
						if (&(aesl_tmp_288[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_288[i_0];
							matrix_o_0_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_289 - aesl_tmp_290; i++)
		{
			sprintf(tvout_matrix_o_0_V, "%s\n", (matrix_o_0_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_0_V, tvout_matrix_o_0_V);
		}

		tcl_file.set_num(aesl_tmp_289 - aesl_tmp_290, &tcl_file.matrix_o_0_V_depth);
		sprintf(tvout_matrix_o_0_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_0_V, tvout_matrix_o_0_V);

		// release memory allocation
		delete [] matrix_o_0_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_0_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, wrapc_stream_size_out_matrix_o_0_V);
		sprintf(wrapc_stream_size_out_matrix_o_0_V, "%d\n", aesl_tmp_289 - aesl_tmp_290);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, wrapc_stream_size_out_matrix_o_0_V);
		sprintf(wrapc_stream_size_out_matrix_o_0_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_0_V, wrapc_stream_size_out_matrix_o_0_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_1_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_1_V, tvout_matrix_o_1_V);

		sc_bv<16>* matrix_o_1_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_292 - aesl_tmp_293];

		// RTL Name: matrix_o_1_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_293) => (aesl_tmp_292 - 1) @ (1)
					for (int i_0 = aesl_tmp_293; i_0 <= aesl_tmp_292 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_291[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_291[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_291[i_0]
						if (&(aesl_tmp_291[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_291[i_0];
							matrix_o_1_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_292 - aesl_tmp_293; i++)
		{
			sprintf(tvout_matrix_o_1_V, "%s\n", (matrix_o_1_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_1_V, tvout_matrix_o_1_V);
		}

		tcl_file.set_num(aesl_tmp_292 - aesl_tmp_293, &tcl_file.matrix_o_1_V_depth);
		sprintf(tvout_matrix_o_1_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_1_V, tvout_matrix_o_1_V);

		// release memory allocation
		delete [] matrix_o_1_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_1_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_1_V, wrapc_stream_size_out_matrix_o_1_V);
		sprintf(wrapc_stream_size_out_matrix_o_1_V, "%d\n", aesl_tmp_292 - aesl_tmp_293);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_1_V, wrapc_stream_size_out_matrix_o_1_V);
		sprintf(wrapc_stream_size_out_matrix_o_1_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_1_V, wrapc_stream_size_out_matrix_o_1_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_2_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_2_V, tvout_matrix_o_2_V);

		sc_bv<16>* matrix_o_2_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_295 - aesl_tmp_296];

		// RTL Name: matrix_o_2_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_296) => (aesl_tmp_295 - 1) @ (1)
					for (int i_0 = aesl_tmp_296; i_0 <= aesl_tmp_295 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_294[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_294[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_294[i_0]
						if (&(aesl_tmp_294[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_294[i_0];
							matrix_o_2_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_295 - aesl_tmp_296; i++)
		{
			sprintf(tvout_matrix_o_2_V, "%s\n", (matrix_o_2_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_2_V, tvout_matrix_o_2_V);
		}

		tcl_file.set_num(aesl_tmp_295 - aesl_tmp_296, &tcl_file.matrix_o_2_V_depth);
		sprintf(tvout_matrix_o_2_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_2_V, tvout_matrix_o_2_V);

		// release memory allocation
		delete [] matrix_o_2_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_2_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_2_V, wrapc_stream_size_out_matrix_o_2_V);
		sprintf(wrapc_stream_size_out_matrix_o_2_V, "%d\n", aesl_tmp_295 - aesl_tmp_296);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_2_V, wrapc_stream_size_out_matrix_o_2_V);
		sprintf(wrapc_stream_size_out_matrix_o_2_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_2_V, wrapc_stream_size_out_matrix_o_2_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_3_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_3_V, tvout_matrix_o_3_V);

		sc_bv<16>* matrix_o_3_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_298 - aesl_tmp_299];

		// RTL Name: matrix_o_3_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_299) => (aesl_tmp_298 - 1) @ (1)
					for (int i_0 = aesl_tmp_299; i_0 <= aesl_tmp_298 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_297[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_297[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_297[i_0]
						if (&(aesl_tmp_297[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_297[i_0];
							matrix_o_3_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_298 - aesl_tmp_299; i++)
		{
			sprintf(tvout_matrix_o_3_V, "%s\n", (matrix_o_3_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_3_V, tvout_matrix_o_3_V);
		}

		tcl_file.set_num(aesl_tmp_298 - aesl_tmp_299, &tcl_file.matrix_o_3_V_depth);
		sprintf(tvout_matrix_o_3_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_3_V, tvout_matrix_o_3_V);

		// release memory allocation
		delete [] matrix_o_3_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_3_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_3_V, wrapc_stream_size_out_matrix_o_3_V);
		sprintf(wrapc_stream_size_out_matrix_o_3_V, "%d\n", aesl_tmp_298 - aesl_tmp_299);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_3_V, wrapc_stream_size_out_matrix_o_3_V);
		sprintf(wrapc_stream_size_out_matrix_o_3_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_3_V, wrapc_stream_size_out_matrix_o_3_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_4_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_4_V, tvout_matrix_o_4_V);

		sc_bv<16>* matrix_o_4_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_301 - aesl_tmp_302];

		// RTL Name: matrix_o_4_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_302) => (aesl_tmp_301 - 1) @ (1)
					for (int i_0 = aesl_tmp_302; i_0 <= aesl_tmp_301 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_300[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_300[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_300[i_0]
						if (&(aesl_tmp_300[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_300[i_0];
							matrix_o_4_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_301 - aesl_tmp_302; i++)
		{
			sprintf(tvout_matrix_o_4_V, "%s\n", (matrix_o_4_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_4_V, tvout_matrix_o_4_V);
		}

		tcl_file.set_num(aesl_tmp_301 - aesl_tmp_302, &tcl_file.matrix_o_4_V_depth);
		sprintf(tvout_matrix_o_4_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_4_V, tvout_matrix_o_4_V);

		// release memory allocation
		delete [] matrix_o_4_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_4_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_4_V, wrapc_stream_size_out_matrix_o_4_V);
		sprintf(wrapc_stream_size_out_matrix_o_4_V, "%d\n", aesl_tmp_301 - aesl_tmp_302);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_4_V, wrapc_stream_size_out_matrix_o_4_V);
		sprintf(wrapc_stream_size_out_matrix_o_4_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_4_V, wrapc_stream_size_out_matrix_o_4_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_5_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_5_V, tvout_matrix_o_5_V);

		sc_bv<16>* matrix_o_5_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_304 - aesl_tmp_305];

		// RTL Name: matrix_o_5_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_305) => (aesl_tmp_304 - 1) @ (1)
					for (int i_0 = aesl_tmp_305; i_0 <= aesl_tmp_304 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_303[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_303[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_303[i_0]
						if (&(aesl_tmp_303[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_303[i_0];
							matrix_o_5_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_304 - aesl_tmp_305; i++)
		{
			sprintf(tvout_matrix_o_5_V, "%s\n", (matrix_o_5_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_5_V, tvout_matrix_o_5_V);
		}

		tcl_file.set_num(aesl_tmp_304 - aesl_tmp_305, &tcl_file.matrix_o_5_V_depth);
		sprintf(tvout_matrix_o_5_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_5_V, tvout_matrix_o_5_V);

		// release memory allocation
		delete [] matrix_o_5_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_5_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_5_V, wrapc_stream_size_out_matrix_o_5_V);
		sprintf(wrapc_stream_size_out_matrix_o_5_V, "%d\n", aesl_tmp_304 - aesl_tmp_305);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_5_V, wrapc_stream_size_out_matrix_o_5_V);
		sprintf(wrapc_stream_size_out_matrix_o_5_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_5_V, wrapc_stream_size_out_matrix_o_5_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_6_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_6_V, tvout_matrix_o_6_V);

		sc_bv<16>* matrix_o_6_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_307 - aesl_tmp_308];

		// RTL Name: matrix_o_6_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_308) => (aesl_tmp_307 - 1) @ (1)
					for (int i_0 = aesl_tmp_308; i_0 <= aesl_tmp_307 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_306[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_306[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_306[i_0]
						if (&(aesl_tmp_306[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_306[i_0];
							matrix_o_6_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_307 - aesl_tmp_308; i++)
		{
			sprintf(tvout_matrix_o_6_V, "%s\n", (matrix_o_6_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_6_V, tvout_matrix_o_6_V);
		}

		tcl_file.set_num(aesl_tmp_307 - aesl_tmp_308, &tcl_file.matrix_o_6_V_depth);
		sprintf(tvout_matrix_o_6_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_6_V, tvout_matrix_o_6_V);

		// release memory allocation
		delete [] matrix_o_6_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_6_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_6_V, wrapc_stream_size_out_matrix_o_6_V);
		sprintf(wrapc_stream_size_out_matrix_o_6_V, "%d\n", aesl_tmp_307 - aesl_tmp_308);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_6_V, wrapc_stream_size_out_matrix_o_6_V);
		sprintf(wrapc_stream_size_out_matrix_o_6_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_6_V, wrapc_stream_size_out_matrix_o_6_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_7_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_7_V, tvout_matrix_o_7_V);

		sc_bv<16>* matrix_o_7_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_310 - aesl_tmp_311];

		// RTL Name: matrix_o_7_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_311) => (aesl_tmp_310 - 1) @ (1)
					for (int i_0 = aesl_tmp_311; i_0 <= aesl_tmp_310 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_309[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_309[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_309[i_0]
						if (&(aesl_tmp_309[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_309[i_0];
							matrix_o_7_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_310 - aesl_tmp_311; i++)
		{
			sprintf(tvout_matrix_o_7_V, "%s\n", (matrix_o_7_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_7_V, tvout_matrix_o_7_V);
		}

		tcl_file.set_num(aesl_tmp_310 - aesl_tmp_311, &tcl_file.matrix_o_7_V_depth);
		sprintf(tvout_matrix_o_7_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_7_V, tvout_matrix_o_7_V);

		// release memory allocation
		delete [] matrix_o_7_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_7_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_7_V, wrapc_stream_size_out_matrix_o_7_V);
		sprintf(wrapc_stream_size_out_matrix_o_7_V, "%d\n", aesl_tmp_310 - aesl_tmp_311);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_7_V, wrapc_stream_size_out_matrix_o_7_V);
		sprintf(wrapc_stream_size_out_matrix_o_7_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_7_V, wrapc_stream_size_out_matrix_o_7_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_8_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_8_V, tvout_matrix_o_8_V);

		sc_bv<16>* matrix_o_8_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_313 - aesl_tmp_314];

		// RTL Name: matrix_o_8_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_314) => (aesl_tmp_313 - 1) @ (1)
					for (int i_0 = aesl_tmp_314; i_0 <= aesl_tmp_313 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_312[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_312[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_312[i_0]
						if (&(aesl_tmp_312[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_312[i_0];
							matrix_o_8_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_313 - aesl_tmp_314; i++)
		{
			sprintf(tvout_matrix_o_8_V, "%s\n", (matrix_o_8_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_8_V, tvout_matrix_o_8_V);
		}

		tcl_file.set_num(aesl_tmp_313 - aesl_tmp_314, &tcl_file.matrix_o_8_V_depth);
		sprintf(tvout_matrix_o_8_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_8_V, tvout_matrix_o_8_V);

		// release memory allocation
		delete [] matrix_o_8_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_8_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_8_V, wrapc_stream_size_out_matrix_o_8_V);
		sprintf(wrapc_stream_size_out_matrix_o_8_V, "%d\n", aesl_tmp_313 - aesl_tmp_314);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_8_V, wrapc_stream_size_out_matrix_o_8_V);
		sprintf(wrapc_stream_size_out_matrix_o_8_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_8_V, wrapc_stream_size_out_matrix_o_8_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_9_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_9_V, tvout_matrix_o_9_V);

		sc_bv<16>* matrix_o_9_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_316 - aesl_tmp_317];

		// RTL Name: matrix_o_9_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_317) => (aesl_tmp_316 - 1) @ (1)
					for (int i_0 = aesl_tmp_317; i_0 <= aesl_tmp_316 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_315[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_315[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_315[i_0]
						if (&(aesl_tmp_315[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_315[i_0];
							matrix_o_9_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_316 - aesl_tmp_317; i++)
		{
			sprintf(tvout_matrix_o_9_V, "%s\n", (matrix_o_9_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_9_V, tvout_matrix_o_9_V);
		}

		tcl_file.set_num(aesl_tmp_316 - aesl_tmp_317, &tcl_file.matrix_o_9_V_depth);
		sprintf(tvout_matrix_o_9_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_9_V, tvout_matrix_o_9_V);

		// release memory allocation
		delete [] matrix_o_9_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_9_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_9_V, wrapc_stream_size_out_matrix_o_9_V);
		sprintf(wrapc_stream_size_out_matrix_o_9_V, "%d\n", aesl_tmp_316 - aesl_tmp_317);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_9_V, wrapc_stream_size_out_matrix_o_9_V);
		sprintf(wrapc_stream_size_out_matrix_o_9_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_9_V, wrapc_stream_size_out_matrix_o_9_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_10_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_10_V, tvout_matrix_o_10_V);

		sc_bv<16>* matrix_o_10_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_319 - aesl_tmp_320];

		// RTL Name: matrix_o_10_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_320) => (aesl_tmp_319 - 1) @ (1)
					for (int i_0 = aesl_tmp_320; i_0 <= aesl_tmp_319 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_318[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_318[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_318[i_0]
						if (&(aesl_tmp_318[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_318[i_0];
							matrix_o_10_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_319 - aesl_tmp_320; i++)
		{
			sprintf(tvout_matrix_o_10_V, "%s\n", (matrix_o_10_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_10_V, tvout_matrix_o_10_V);
		}

		tcl_file.set_num(aesl_tmp_319 - aesl_tmp_320, &tcl_file.matrix_o_10_V_depth);
		sprintf(tvout_matrix_o_10_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_10_V, tvout_matrix_o_10_V);

		// release memory allocation
		delete [] matrix_o_10_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_10_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_10_V, wrapc_stream_size_out_matrix_o_10_V);
		sprintf(wrapc_stream_size_out_matrix_o_10_V, "%d\n", aesl_tmp_319 - aesl_tmp_320);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_10_V, wrapc_stream_size_out_matrix_o_10_V);
		sprintf(wrapc_stream_size_out_matrix_o_10_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_10_V, wrapc_stream_size_out_matrix_o_10_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_11_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_11_V, tvout_matrix_o_11_V);

		sc_bv<16>* matrix_o_11_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_322 - aesl_tmp_323];

		// RTL Name: matrix_o_11_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_323) => (aesl_tmp_322 - 1) @ (1)
					for (int i_0 = aesl_tmp_323; i_0 <= aesl_tmp_322 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_321[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_321[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_321[i_0]
						if (&(aesl_tmp_321[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_321[i_0];
							matrix_o_11_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_322 - aesl_tmp_323; i++)
		{
			sprintf(tvout_matrix_o_11_V, "%s\n", (matrix_o_11_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_11_V, tvout_matrix_o_11_V);
		}

		tcl_file.set_num(aesl_tmp_322 - aesl_tmp_323, &tcl_file.matrix_o_11_V_depth);
		sprintf(tvout_matrix_o_11_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_11_V, tvout_matrix_o_11_V);

		// release memory allocation
		delete [] matrix_o_11_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_11_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_11_V, wrapc_stream_size_out_matrix_o_11_V);
		sprintf(wrapc_stream_size_out_matrix_o_11_V, "%d\n", aesl_tmp_322 - aesl_tmp_323);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_11_V, wrapc_stream_size_out_matrix_o_11_V);
		sprintf(wrapc_stream_size_out_matrix_o_11_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_11_V, wrapc_stream_size_out_matrix_o_11_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_12_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_12_V, tvout_matrix_o_12_V);

		sc_bv<16>* matrix_o_12_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_325 - aesl_tmp_326];

		// RTL Name: matrix_o_12_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_326) => (aesl_tmp_325 - 1) @ (1)
					for (int i_0 = aesl_tmp_326; i_0 <= aesl_tmp_325 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_324[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_324[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_324[i_0]
						if (&(aesl_tmp_324[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_324[i_0];
							matrix_o_12_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_325 - aesl_tmp_326; i++)
		{
			sprintf(tvout_matrix_o_12_V, "%s\n", (matrix_o_12_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_12_V, tvout_matrix_o_12_V);
		}

		tcl_file.set_num(aesl_tmp_325 - aesl_tmp_326, &tcl_file.matrix_o_12_V_depth);
		sprintf(tvout_matrix_o_12_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_12_V, tvout_matrix_o_12_V);

		// release memory allocation
		delete [] matrix_o_12_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_12_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_12_V, wrapc_stream_size_out_matrix_o_12_V);
		sprintf(wrapc_stream_size_out_matrix_o_12_V, "%d\n", aesl_tmp_325 - aesl_tmp_326);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_12_V, wrapc_stream_size_out_matrix_o_12_V);
		sprintf(wrapc_stream_size_out_matrix_o_12_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_12_V, wrapc_stream_size_out_matrix_o_12_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_13_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_13_V, tvout_matrix_o_13_V);

		sc_bv<16>* matrix_o_13_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_328 - aesl_tmp_329];

		// RTL Name: matrix_o_13_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_329) => (aesl_tmp_328 - 1) @ (1)
					for (int i_0 = aesl_tmp_329; i_0 <= aesl_tmp_328 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_327[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_327[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_327[i_0]
						if (&(aesl_tmp_327[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_327[i_0];
							matrix_o_13_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_328 - aesl_tmp_329; i++)
		{
			sprintf(tvout_matrix_o_13_V, "%s\n", (matrix_o_13_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_13_V, tvout_matrix_o_13_V);
		}

		tcl_file.set_num(aesl_tmp_328 - aesl_tmp_329, &tcl_file.matrix_o_13_V_depth);
		sprintf(tvout_matrix_o_13_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_13_V, tvout_matrix_o_13_V);

		// release memory allocation
		delete [] matrix_o_13_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_13_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_13_V, wrapc_stream_size_out_matrix_o_13_V);
		sprintf(wrapc_stream_size_out_matrix_o_13_V, "%d\n", aesl_tmp_328 - aesl_tmp_329);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_13_V, wrapc_stream_size_out_matrix_o_13_V);
		sprintf(wrapc_stream_size_out_matrix_o_13_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_13_V, wrapc_stream_size_out_matrix_o_13_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_14_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_14_V, tvout_matrix_o_14_V);

		sc_bv<16>* matrix_o_14_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_331 - aesl_tmp_332];

		// RTL Name: matrix_o_14_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_332) => (aesl_tmp_331 - 1) @ (1)
					for (int i_0 = aesl_tmp_332; i_0 <= aesl_tmp_331 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_330[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_330[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_330[i_0]
						if (&(aesl_tmp_330[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_330[i_0];
							matrix_o_14_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_331 - aesl_tmp_332; i++)
		{
			sprintf(tvout_matrix_o_14_V, "%s\n", (matrix_o_14_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_14_V, tvout_matrix_o_14_V);
		}

		tcl_file.set_num(aesl_tmp_331 - aesl_tmp_332, &tcl_file.matrix_o_14_V_depth);
		sprintf(tvout_matrix_o_14_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_14_V, tvout_matrix_o_14_V);

		// release memory allocation
		delete [] matrix_o_14_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_14_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_14_V, wrapc_stream_size_out_matrix_o_14_V);
		sprintf(wrapc_stream_size_out_matrix_o_14_V, "%d\n", aesl_tmp_331 - aesl_tmp_332);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_14_V, wrapc_stream_size_out_matrix_o_14_V);
		sprintf(wrapc_stream_size_out_matrix_o_14_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_14_V, wrapc_stream_size_out_matrix_o_14_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_15_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_15_V, tvout_matrix_o_15_V);

		sc_bv<16>* matrix_o_15_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_334 - aesl_tmp_335];

		// RTL Name: matrix_o_15_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_335) => (aesl_tmp_334 - 1) @ (1)
					for (int i_0 = aesl_tmp_335; i_0 <= aesl_tmp_334 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_333[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_333[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_333[i_0]
						if (&(aesl_tmp_333[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_333[i_0];
							matrix_o_15_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_334 - aesl_tmp_335; i++)
		{
			sprintf(tvout_matrix_o_15_V, "%s\n", (matrix_o_15_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_15_V, tvout_matrix_o_15_V);
		}

		tcl_file.set_num(aesl_tmp_334 - aesl_tmp_335, &tcl_file.matrix_o_15_V_depth);
		sprintf(tvout_matrix_o_15_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_15_V, tvout_matrix_o_15_V);

		// release memory allocation
		delete [] matrix_o_15_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_15_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_15_V, wrapc_stream_size_out_matrix_o_15_V);
		sprintf(wrapc_stream_size_out_matrix_o_15_V, "%d\n", aesl_tmp_334 - aesl_tmp_335);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_15_V, wrapc_stream_size_out_matrix_o_15_V);
		sprintf(wrapc_stream_size_out_matrix_o_15_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_15_V, wrapc_stream_size_out_matrix_o_15_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_16_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_16_V, tvout_matrix_o_16_V);

		sc_bv<16>* matrix_o_16_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_337 - aesl_tmp_338];

		// RTL Name: matrix_o_16_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_338) => (aesl_tmp_337 - 1) @ (1)
					for (int i_0 = aesl_tmp_338; i_0 <= aesl_tmp_337 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_336[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_336[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_336[i_0]
						if (&(aesl_tmp_336[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_336[i_0];
							matrix_o_16_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_337 - aesl_tmp_338; i++)
		{
			sprintf(tvout_matrix_o_16_V, "%s\n", (matrix_o_16_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_16_V, tvout_matrix_o_16_V);
		}

		tcl_file.set_num(aesl_tmp_337 - aesl_tmp_338, &tcl_file.matrix_o_16_V_depth);
		sprintf(tvout_matrix_o_16_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_16_V, tvout_matrix_o_16_V);

		// release memory allocation
		delete [] matrix_o_16_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_16_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_16_V, wrapc_stream_size_out_matrix_o_16_V);
		sprintf(wrapc_stream_size_out_matrix_o_16_V, "%d\n", aesl_tmp_337 - aesl_tmp_338);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_16_V, wrapc_stream_size_out_matrix_o_16_V);
		sprintf(wrapc_stream_size_out_matrix_o_16_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_16_V, wrapc_stream_size_out_matrix_o_16_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_17_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_17_V, tvout_matrix_o_17_V);

		sc_bv<16>* matrix_o_17_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_340 - aesl_tmp_341];

		// RTL Name: matrix_o_17_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_341) => (aesl_tmp_340 - 1) @ (1)
					for (int i_0 = aesl_tmp_341; i_0 <= aesl_tmp_340 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_339[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_339[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_339[i_0]
						if (&(aesl_tmp_339[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_339[i_0];
							matrix_o_17_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_340 - aesl_tmp_341; i++)
		{
			sprintf(tvout_matrix_o_17_V, "%s\n", (matrix_o_17_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_17_V, tvout_matrix_o_17_V);
		}

		tcl_file.set_num(aesl_tmp_340 - aesl_tmp_341, &tcl_file.matrix_o_17_V_depth);
		sprintf(tvout_matrix_o_17_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_17_V, tvout_matrix_o_17_V);

		// release memory allocation
		delete [] matrix_o_17_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_17_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_17_V, wrapc_stream_size_out_matrix_o_17_V);
		sprintf(wrapc_stream_size_out_matrix_o_17_V, "%d\n", aesl_tmp_340 - aesl_tmp_341);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_17_V, wrapc_stream_size_out_matrix_o_17_V);
		sprintf(wrapc_stream_size_out_matrix_o_17_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_17_V, wrapc_stream_size_out_matrix_o_17_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_18_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_18_V, tvout_matrix_o_18_V);

		sc_bv<16>* matrix_o_18_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_343 - aesl_tmp_344];

		// RTL Name: matrix_o_18_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_344) => (aesl_tmp_343 - 1) @ (1)
					for (int i_0 = aesl_tmp_344; i_0 <= aesl_tmp_343 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_342[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_342[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_342[i_0]
						if (&(aesl_tmp_342[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_342[i_0];
							matrix_o_18_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_343 - aesl_tmp_344; i++)
		{
			sprintf(tvout_matrix_o_18_V, "%s\n", (matrix_o_18_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_18_V, tvout_matrix_o_18_V);
		}

		tcl_file.set_num(aesl_tmp_343 - aesl_tmp_344, &tcl_file.matrix_o_18_V_depth);
		sprintf(tvout_matrix_o_18_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_18_V, tvout_matrix_o_18_V);

		// release memory allocation
		delete [] matrix_o_18_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_18_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_18_V, wrapc_stream_size_out_matrix_o_18_V);
		sprintf(wrapc_stream_size_out_matrix_o_18_V, "%d\n", aesl_tmp_343 - aesl_tmp_344);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_18_V, wrapc_stream_size_out_matrix_o_18_V);
		sprintf(wrapc_stream_size_out_matrix_o_18_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_18_V, wrapc_stream_size_out_matrix_o_18_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_19_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_19_V, tvout_matrix_o_19_V);

		sc_bv<16>* matrix_o_19_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_346 - aesl_tmp_347];

		// RTL Name: matrix_o_19_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_347) => (aesl_tmp_346 - 1) @ (1)
					for (int i_0 = aesl_tmp_347; i_0 <= aesl_tmp_346 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_345[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_345[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_345[i_0]
						if (&(aesl_tmp_345[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_345[i_0];
							matrix_o_19_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_346 - aesl_tmp_347; i++)
		{
			sprintf(tvout_matrix_o_19_V, "%s\n", (matrix_o_19_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_19_V, tvout_matrix_o_19_V);
		}

		tcl_file.set_num(aesl_tmp_346 - aesl_tmp_347, &tcl_file.matrix_o_19_V_depth);
		sprintf(tvout_matrix_o_19_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_19_V, tvout_matrix_o_19_V);

		// release memory allocation
		delete [] matrix_o_19_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_19_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_19_V, wrapc_stream_size_out_matrix_o_19_V);
		sprintf(wrapc_stream_size_out_matrix_o_19_V, "%d\n", aesl_tmp_346 - aesl_tmp_347);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_19_V, wrapc_stream_size_out_matrix_o_19_V);
		sprintf(wrapc_stream_size_out_matrix_o_19_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_19_V, wrapc_stream_size_out_matrix_o_19_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_20_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_20_V, tvout_matrix_o_20_V);

		sc_bv<16>* matrix_o_20_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_349 - aesl_tmp_350];

		// RTL Name: matrix_o_20_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_350) => (aesl_tmp_349 - 1) @ (1)
					for (int i_0 = aesl_tmp_350; i_0 <= aesl_tmp_349 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_348[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_348[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_348[i_0]
						if (&(aesl_tmp_348[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_348[i_0];
							matrix_o_20_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_349 - aesl_tmp_350; i++)
		{
			sprintf(tvout_matrix_o_20_V, "%s\n", (matrix_o_20_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_20_V, tvout_matrix_o_20_V);
		}

		tcl_file.set_num(aesl_tmp_349 - aesl_tmp_350, &tcl_file.matrix_o_20_V_depth);
		sprintf(tvout_matrix_o_20_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_20_V, tvout_matrix_o_20_V);

		// release memory allocation
		delete [] matrix_o_20_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_20_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_20_V, wrapc_stream_size_out_matrix_o_20_V);
		sprintf(wrapc_stream_size_out_matrix_o_20_V, "%d\n", aesl_tmp_349 - aesl_tmp_350);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_20_V, wrapc_stream_size_out_matrix_o_20_V);
		sprintf(wrapc_stream_size_out_matrix_o_20_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_20_V, wrapc_stream_size_out_matrix_o_20_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_21_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_21_V, tvout_matrix_o_21_V);

		sc_bv<16>* matrix_o_21_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_352 - aesl_tmp_353];

		// RTL Name: matrix_o_21_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_353) => (aesl_tmp_352 - 1) @ (1)
					for (int i_0 = aesl_tmp_353; i_0 <= aesl_tmp_352 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_351[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_351[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_351[i_0]
						if (&(aesl_tmp_351[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_351[i_0];
							matrix_o_21_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_352 - aesl_tmp_353; i++)
		{
			sprintf(tvout_matrix_o_21_V, "%s\n", (matrix_o_21_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_21_V, tvout_matrix_o_21_V);
		}

		tcl_file.set_num(aesl_tmp_352 - aesl_tmp_353, &tcl_file.matrix_o_21_V_depth);
		sprintf(tvout_matrix_o_21_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_21_V, tvout_matrix_o_21_V);

		// release memory allocation
		delete [] matrix_o_21_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_21_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_21_V, wrapc_stream_size_out_matrix_o_21_V);
		sprintf(wrapc_stream_size_out_matrix_o_21_V, "%d\n", aesl_tmp_352 - aesl_tmp_353);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_21_V, wrapc_stream_size_out_matrix_o_21_V);
		sprintf(wrapc_stream_size_out_matrix_o_21_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_21_V, wrapc_stream_size_out_matrix_o_21_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_22_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_22_V, tvout_matrix_o_22_V);

		sc_bv<16>* matrix_o_22_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_355 - aesl_tmp_356];

		// RTL Name: matrix_o_22_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_356) => (aesl_tmp_355 - 1) @ (1)
					for (int i_0 = aesl_tmp_356; i_0 <= aesl_tmp_355 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_354[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_354[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_354[i_0]
						if (&(aesl_tmp_354[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_354[i_0];
							matrix_o_22_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_355 - aesl_tmp_356; i++)
		{
			sprintf(tvout_matrix_o_22_V, "%s\n", (matrix_o_22_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_22_V, tvout_matrix_o_22_V);
		}

		tcl_file.set_num(aesl_tmp_355 - aesl_tmp_356, &tcl_file.matrix_o_22_V_depth);
		sprintf(tvout_matrix_o_22_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_22_V, tvout_matrix_o_22_V);

		// release memory allocation
		delete [] matrix_o_22_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_22_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_22_V, wrapc_stream_size_out_matrix_o_22_V);
		sprintf(wrapc_stream_size_out_matrix_o_22_V, "%d\n", aesl_tmp_355 - aesl_tmp_356);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_22_V, wrapc_stream_size_out_matrix_o_22_V);
		sprintf(wrapc_stream_size_out_matrix_o_22_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_22_V, wrapc_stream_size_out_matrix_o_22_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_23_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_23_V, tvout_matrix_o_23_V);

		sc_bv<16>* matrix_o_23_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_358 - aesl_tmp_359];

		// RTL Name: matrix_o_23_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_359) => (aesl_tmp_358 - 1) @ (1)
					for (int i_0 = aesl_tmp_359; i_0 <= aesl_tmp_358 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_357[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_357[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_357[i_0]
						if (&(aesl_tmp_357[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_357[i_0];
							matrix_o_23_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_358 - aesl_tmp_359; i++)
		{
			sprintf(tvout_matrix_o_23_V, "%s\n", (matrix_o_23_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_23_V, tvout_matrix_o_23_V);
		}

		tcl_file.set_num(aesl_tmp_358 - aesl_tmp_359, &tcl_file.matrix_o_23_V_depth);
		sprintf(tvout_matrix_o_23_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_23_V, tvout_matrix_o_23_V);

		// release memory allocation
		delete [] matrix_o_23_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_23_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_23_V, wrapc_stream_size_out_matrix_o_23_V);
		sprintf(wrapc_stream_size_out_matrix_o_23_V, "%d\n", aesl_tmp_358 - aesl_tmp_359);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_23_V, wrapc_stream_size_out_matrix_o_23_V);
		sprintf(wrapc_stream_size_out_matrix_o_23_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_23_V, wrapc_stream_size_out_matrix_o_23_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_24_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_24_V, tvout_matrix_o_24_V);

		sc_bv<16>* matrix_o_24_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_361 - aesl_tmp_362];

		// RTL Name: matrix_o_24_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_362) => (aesl_tmp_361 - 1) @ (1)
					for (int i_0 = aesl_tmp_362; i_0 <= aesl_tmp_361 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_360[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_360[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_360[i_0]
						if (&(aesl_tmp_360[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_360[i_0];
							matrix_o_24_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_361 - aesl_tmp_362; i++)
		{
			sprintf(tvout_matrix_o_24_V, "%s\n", (matrix_o_24_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_24_V, tvout_matrix_o_24_V);
		}

		tcl_file.set_num(aesl_tmp_361 - aesl_tmp_362, &tcl_file.matrix_o_24_V_depth);
		sprintf(tvout_matrix_o_24_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_24_V, tvout_matrix_o_24_V);

		// release memory allocation
		delete [] matrix_o_24_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_24_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_24_V, wrapc_stream_size_out_matrix_o_24_V);
		sprintf(wrapc_stream_size_out_matrix_o_24_V, "%d\n", aesl_tmp_361 - aesl_tmp_362);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_24_V, wrapc_stream_size_out_matrix_o_24_V);
		sprintf(wrapc_stream_size_out_matrix_o_24_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_24_V, wrapc_stream_size_out_matrix_o_24_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_25_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_25_V, tvout_matrix_o_25_V);

		sc_bv<16>* matrix_o_25_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_364 - aesl_tmp_365];

		// RTL Name: matrix_o_25_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_365) => (aesl_tmp_364 - 1) @ (1)
					for (int i_0 = aesl_tmp_365; i_0 <= aesl_tmp_364 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_363[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_363[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_363[i_0]
						if (&(aesl_tmp_363[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_363[i_0];
							matrix_o_25_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_364 - aesl_tmp_365; i++)
		{
			sprintf(tvout_matrix_o_25_V, "%s\n", (matrix_o_25_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_25_V, tvout_matrix_o_25_V);
		}

		tcl_file.set_num(aesl_tmp_364 - aesl_tmp_365, &tcl_file.matrix_o_25_V_depth);
		sprintf(tvout_matrix_o_25_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_25_V, tvout_matrix_o_25_V);

		// release memory allocation
		delete [] matrix_o_25_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_25_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_25_V, wrapc_stream_size_out_matrix_o_25_V);
		sprintf(wrapc_stream_size_out_matrix_o_25_V, "%d\n", aesl_tmp_364 - aesl_tmp_365);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_25_V, wrapc_stream_size_out_matrix_o_25_V);
		sprintf(wrapc_stream_size_out_matrix_o_25_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_25_V, wrapc_stream_size_out_matrix_o_25_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_26_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_26_V, tvout_matrix_o_26_V);

		sc_bv<16>* matrix_o_26_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_367 - aesl_tmp_368];

		// RTL Name: matrix_o_26_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_368) => (aesl_tmp_367 - 1) @ (1)
					for (int i_0 = aesl_tmp_368; i_0 <= aesl_tmp_367 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_366[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_366[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_366[i_0]
						if (&(aesl_tmp_366[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_366[i_0];
							matrix_o_26_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_367 - aesl_tmp_368; i++)
		{
			sprintf(tvout_matrix_o_26_V, "%s\n", (matrix_o_26_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_26_V, tvout_matrix_o_26_V);
		}

		tcl_file.set_num(aesl_tmp_367 - aesl_tmp_368, &tcl_file.matrix_o_26_V_depth);
		sprintf(tvout_matrix_o_26_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_26_V, tvout_matrix_o_26_V);

		// release memory allocation
		delete [] matrix_o_26_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_26_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_26_V, wrapc_stream_size_out_matrix_o_26_V);
		sprintf(wrapc_stream_size_out_matrix_o_26_V, "%d\n", aesl_tmp_367 - aesl_tmp_368);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_26_V, wrapc_stream_size_out_matrix_o_26_V);
		sprintf(wrapc_stream_size_out_matrix_o_26_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_26_V, wrapc_stream_size_out_matrix_o_26_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_27_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_27_V, tvout_matrix_o_27_V);

		sc_bv<16>* matrix_o_27_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_370 - aesl_tmp_371];

		// RTL Name: matrix_o_27_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_371) => (aesl_tmp_370 - 1) @ (1)
					for (int i_0 = aesl_tmp_371; i_0 <= aesl_tmp_370 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_369[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_369[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_369[i_0]
						if (&(aesl_tmp_369[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_369[i_0];
							matrix_o_27_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_370 - aesl_tmp_371; i++)
		{
			sprintf(tvout_matrix_o_27_V, "%s\n", (matrix_o_27_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_27_V, tvout_matrix_o_27_V);
		}

		tcl_file.set_num(aesl_tmp_370 - aesl_tmp_371, &tcl_file.matrix_o_27_V_depth);
		sprintf(tvout_matrix_o_27_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_27_V, tvout_matrix_o_27_V);

		// release memory allocation
		delete [] matrix_o_27_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_27_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_27_V, wrapc_stream_size_out_matrix_o_27_V);
		sprintf(wrapc_stream_size_out_matrix_o_27_V, "%d\n", aesl_tmp_370 - aesl_tmp_371);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_27_V, wrapc_stream_size_out_matrix_o_27_V);
		sprintf(wrapc_stream_size_out_matrix_o_27_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_27_V, wrapc_stream_size_out_matrix_o_27_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_28_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_28_V, tvout_matrix_o_28_V);

		sc_bv<16>* matrix_o_28_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_373 - aesl_tmp_374];

		// RTL Name: matrix_o_28_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_374) => (aesl_tmp_373 - 1) @ (1)
					for (int i_0 = aesl_tmp_374; i_0 <= aesl_tmp_373 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_372[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_372[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_372[i_0]
						if (&(aesl_tmp_372[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_372[i_0];
							matrix_o_28_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_373 - aesl_tmp_374; i++)
		{
			sprintf(tvout_matrix_o_28_V, "%s\n", (matrix_o_28_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_28_V, tvout_matrix_o_28_V);
		}

		tcl_file.set_num(aesl_tmp_373 - aesl_tmp_374, &tcl_file.matrix_o_28_V_depth);
		sprintf(tvout_matrix_o_28_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_28_V, tvout_matrix_o_28_V);

		// release memory allocation
		delete [] matrix_o_28_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_28_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_28_V, wrapc_stream_size_out_matrix_o_28_V);
		sprintf(wrapc_stream_size_out_matrix_o_28_V, "%d\n", aesl_tmp_373 - aesl_tmp_374);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_28_V, wrapc_stream_size_out_matrix_o_28_V);
		sprintf(wrapc_stream_size_out_matrix_o_28_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_28_V, wrapc_stream_size_out_matrix_o_28_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_29_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_29_V, tvout_matrix_o_29_V);

		sc_bv<16>* matrix_o_29_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_376 - aesl_tmp_377];

		// RTL Name: matrix_o_29_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_377) => (aesl_tmp_376 - 1) @ (1)
					for (int i_0 = aesl_tmp_377; i_0 <= aesl_tmp_376 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_375[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_375[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_375[i_0]
						if (&(aesl_tmp_375[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_375[i_0];
							matrix_o_29_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_376 - aesl_tmp_377; i++)
		{
			sprintf(tvout_matrix_o_29_V, "%s\n", (matrix_o_29_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_29_V, tvout_matrix_o_29_V);
		}

		tcl_file.set_num(aesl_tmp_376 - aesl_tmp_377, &tcl_file.matrix_o_29_V_depth);
		sprintf(tvout_matrix_o_29_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_29_V, tvout_matrix_o_29_V);

		// release memory allocation
		delete [] matrix_o_29_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_29_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_29_V, wrapc_stream_size_out_matrix_o_29_V);
		sprintf(wrapc_stream_size_out_matrix_o_29_V, "%d\n", aesl_tmp_376 - aesl_tmp_377);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_29_V, wrapc_stream_size_out_matrix_o_29_V);
		sprintf(wrapc_stream_size_out_matrix_o_29_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_29_V, wrapc_stream_size_out_matrix_o_29_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_30_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_30_V, tvout_matrix_o_30_V);

		sc_bv<16>* matrix_o_30_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_379 - aesl_tmp_380];

		// RTL Name: matrix_o_30_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_380) => (aesl_tmp_379 - 1) @ (1)
					for (int i_0 = aesl_tmp_380; i_0 <= aesl_tmp_379 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_378[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_378[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_378[i_0]
						if (&(aesl_tmp_378[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_378[i_0];
							matrix_o_30_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_379 - aesl_tmp_380; i++)
		{
			sprintf(tvout_matrix_o_30_V, "%s\n", (matrix_o_30_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_30_V, tvout_matrix_o_30_V);
		}

		tcl_file.set_num(aesl_tmp_379 - aesl_tmp_380, &tcl_file.matrix_o_30_V_depth);
		sprintf(tvout_matrix_o_30_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_30_V, tvout_matrix_o_30_V);

		// release memory allocation
		delete [] matrix_o_30_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_30_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_30_V, wrapc_stream_size_out_matrix_o_30_V);
		sprintf(wrapc_stream_size_out_matrix_o_30_V, "%d\n", aesl_tmp_379 - aesl_tmp_380);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_30_V, wrapc_stream_size_out_matrix_o_30_V);
		sprintf(wrapc_stream_size_out_matrix_o_30_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_30_V, wrapc_stream_size_out_matrix_o_30_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_31_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_31_V, tvout_matrix_o_31_V);

		sc_bv<16>* matrix_o_31_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_382 - aesl_tmp_383];

		// RTL Name: matrix_o_31_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_383) => (aesl_tmp_382 - 1) @ (1)
					for (int i_0 = aesl_tmp_383; i_0 <= aesl_tmp_382 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_381[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_381[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_381[i_0]
						if (&(aesl_tmp_381[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_381[i_0];
							matrix_o_31_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_382 - aesl_tmp_383; i++)
		{
			sprintf(tvout_matrix_o_31_V, "%s\n", (matrix_o_31_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_31_V, tvout_matrix_o_31_V);
		}

		tcl_file.set_num(aesl_tmp_382 - aesl_tmp_383, &tcl_file.matrix_o_31_V_depth);
		sprintf(tvout_matrix_o_31_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_31_V, tvout_matrix_o_31_V);

		// release memory allocation
		delete [] matrix_o_31_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_31_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_31_V, wrapc_stream_size_out_matrix_o_31_V);
		sprintf(wrapc_stream_size_out_matrix_o_31_V, "%d\n", aesl_tmp_382 - aesl_tmp_383);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_31_V, wrapc_stream_size_out_matrix_o_31_V);
		sprintf(wrapc_stream_size_out_matrix_o_31_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_31_V, wrapc_stream_size_out_matrix_o_31_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_32_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_32_V, tvout_matrix_o_32_V);

		sc_bv<16>* matrix_o_32_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_385 - aesl_tmp_386];

		// RTL Name: matrix_o_32_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_386) => (aesl_tmp_385 - 1) @ (1)
					for (int i_0 = aesl_tmp_386; i_0 <= aesl_tmp_385 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_384[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_384[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_384[i_0]
						if (&(aesl_tmp_384[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_384[i_0];
							matrix_o_32_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_385 - aesl_tmp_386; i++)
		{
			sprintf(tvout_matrix_o_32_V, "%s\n", (matrix_o_32_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_32_V, tvout_matrix_o_32_V);
		}

		tcl_file.set_num(aesl_tmp_385 - aesl_tmp_386, &tcl_file.matrix_o_32_V_depth);
		sprintf(tvout_matrix_o_32_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_32_V, tvout_matrix_o_32_V);

		// release memory allocation
		delete [] matrix_o_32_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_32_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_32_V, wrapc_stream_size_out_matrix_o_32_V);
		sprintf(wrapc_stream_size_out_matrix_o_32_V, "%d\n", aesl_tmp_385 - aesl_tmp_386);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_32_V, wrapc_stream_size_out_matrix_o_32_V);
		sprintf(wrapc_stream_size_out_matrix_o_32_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_32_V, wrapc_stream_size_out_matrix_o_32_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_33_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_33_V, tvout_matrix_o_33_V);

		sc_bv<16>* matrix_o_33_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_388 - aesl_tmp_389];

		// RTL Name: matrix_o_33_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_389) => (aesl_tmp_388 - 1) @ (1)
					for (int i_0 = aesl_tmp_389; i_0 <= aesl_tmp_388 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_387[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_387[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_387[i_0]
						if (&(aesl_tmp_387[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_387[i_0];
							matrix_o_33_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_388 - aesl_tmp_389; i++)
		{
			sprintf(tvout_matrix_o_33_V, "%s\n", (matrix_o_33_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_33_V, tvout_matrix_o_33_V);
		}

		tcl_file.set_num(aesl_tmp_388 - aesl_tmp_389, &tcl_file.matrix_o_33_V_depth);
		sprintf(tvout_matrix_o_33_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_33_V, tvout_matrix_o_33_V);

		// release memory allocation
		delete [] matrix_o_33_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_33_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_33_V, wrapc_stream_size_out_matrix_o_33_V);
		sprintf(wrapc_stream_size_out_matrix_o_33_V, "%d\n", aesl_tmp_388 - aesl_tmp_389);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_33_V, wrapc_stream_size_out_matrix_o_33_V);
		sprintf(wrapc_stream_size_out_matrix_o_33_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_33_V, wrapc_stream_size_out_matrix_o_33_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_34_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_34_V, tvout_matrix_o_34_V);

		sc_bv<16>* matrix_o_34_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_391 - aesl_tmp_392];

		// RTL Name: matrix_o_34_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_392) => (aesl_tmp_391 - 1) @ (1)
					for (int i_0 = aesl_tmp_392; i_0 <= aesl_tmp_391 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_390[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_390[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_390[i_0]
						if (&(aesl_tmp_390[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_390[i_0];
							matrix_o_34_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_391 - aesl_tmp_392; i++)
		{
			sprintf(tvout_matrix_o_34_V, "%s\n", (matrix_o_34_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_34_V, tvout_matrix_o_34_V);
		}

		tcl_file.set_num(aesl_tmp_391 - aesl_tmp_392, &tcl_file.matrix_o_34_V_depth);
		sprintf(tvout_matrix_o_34_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_34_V, tvout_matrix_o_34_V);

		// release memory allocation
		delete [] matrix_o_34_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_34_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_34_V, wrapc_stream_size_out_matrix_o_34_V);
		sprintf(wrapc_stream_size_out_matrix_o_34_V, "%d\n", aesl_tmp_391 - aesl_tmp_392);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_34_V, wrapc_stream_size_out_matrix_o_34_V);
		sprintf(wrapc_stream_size_out_matrix_o_34_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_34_V, wrapc_stream_size_out_matrix_o_34_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_35_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_35_V, tvout_matrix_o_35_V);

		sc_bv<16>* matrix_o_35_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_394 - aesl_tmp_395];

		// RTL Name: matrix_o_35_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_395) => (aesl_tmp_394 - 1) @ (1)
					for (int i_0 = aesl_tmp_395; i_0 <= aesl_tmp_394 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_393[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_393[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_393[i_0]
						if (&(aesl_tmp_393[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_393[i_0];
							matrix_o_35_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_394 - aesl_tmp_395; i++)
		{
			sprintf(tvout_matrix_o_35_V, "%s\n", (matrix_o_35_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_35_V, tvout_matrix_o_35_V);
		}

		tcl_file.set_num(aesl_tmp_394 - aesl_tmp_395, &tcl_file.matrix_o_35_V_depth);
		sprintf(tvout_matrix_o_35_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_35_V, tvout_matrix_o_35_V);

		// release memory allocation
		delete [] matrix_o_35_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_35_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_35_V, wrapc_stream_size_out_matrix_o_35_V);
		sprintf(wrapc_stream_size_out_matrix_o_35_V, "%d\n", aesl_tmp_394 - aesl_tmp_395);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_35_V, wrapc_stream_size_out_matrix_o_35_V);
		sprintf(wrapc_stream_size_out_matrix_o_35_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_35_V, wrapc_stream_size_out_matrix_o_35_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_36_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_36_V, tvout_matrix_o_36_V);

		sc_bv<16>* matrix_o_36_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_397 - aesl_tmp_398];

		// RTL Name: matrix_o_36_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_398) => (aesl_tmp_397 - 1) @ (1)
					for (int i_0 = aesl_tmp_398; i_0 <= aesl_tmp_397 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_396[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_396[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_396[i_0]
						if (&(aesl_tmp_396[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_396[i_0];
							matrix_o_36_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_397 - aesl_tmp_398; i++)
		{
			sprintf(tvout_matrix_o_36_V, "%s\n", (matrix_o_36_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_36_V, tvout_matrix_o_36_V);
		}

		tcl_file.set_num(aesl_tmp_397 - aesl_tmp_398, &tcl_file.matrix_o_36_V_depth);
		sprintf(tvout_matrix_o_36_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_36_V, tvout_matrix_o_36_V);

		// release memory allocation
		delete [] matrix_o_36_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_36_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_36_V, wrapc_stream_size_out_matrix_o_36_V);
		sprintf(wrapc_stream_size_out_matrix_o_36_V, "%d\n", aesl_tmp_397 - aesl_tmp_398);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_36_V, wrapc_stream_size_out_matrix_o_36_V);
		sprintf(wrapc_stream_size_out_matrix_o_36_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_36_V, wrapc_stream_size_out_matrix_o_36_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_37_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_37_V, tvout_matrix_o_37_V);

		sc_bv<16>* matrix_o_37_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_400 - aesl_tmp_401];

		// RTL Name: matrix_o_37_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_401) => (aesl_tmp_400 - 1) @ (1)
					for (int i_0 = aesl_tmp_401; i_0 <= aesl_tmp_400 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_399[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_399[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_399[i_0]
						if (&(aesl_tmp_399[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_399[i_0];
							matrix_o_37_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_400 - aesl_tmp_401; i++)
		{
			sprintf(tvout_matrix_o_37_V, "%s\n", (matrix_o_37_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_37_V, tvout_matrix_o_37_V);
		}

		tcl_file.set_num(aesl_tmp_400 - aesl_tmp_401, &tcl_file.matrix_o_37_V_depth);
		sprintf(tvout_matrix_o_37_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_37_V, tvout_matrix_o_37_V);

		// release memory allocation
		delete [] matrix_o_37_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_37_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_37_V, wrapc_stream_size_out_matrix_o_37_V);
		sprintf(wrapc_stream_size_out_matrix_o_37_V, "%d\n", aesl_tmp_400 - aesl_tmp_401);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_37_V, wrapc_stream_size_out_matrix_o_37_V);
		sprintf(wrapc_stream_size_out_matrix_o_37_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_37_V, wrapc_stream_size_out_matrix_o_37_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_38_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_38_V, tvout_matrix_o_38_V);

		sc_bv<16>* matrix_o_38_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_403 - aesl_tmp_404];

		// RTL Name: matrix_o_38_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_404) => (aesl_tmp_403 - 1) @ (1)
					for (int i_0 = aesl_tmp_404; i_0 <= aesl_tmp_403 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_402[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_402[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_402[i_0]
						if (&(aesl_tmp_402[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_402[i_0];
							matrix_o_38_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_403 - aesl_tmp_404; i++)
		{
			sprintf(tvout_matrix_o_38_V, "%s\n", (matrix_o_38_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_38_V, tvout_matrix_o_38_V);
		}

		tcl_file.set_num(aesl_tmp_403 - aesl_tmp_404, &tcl_file.matrix_o_38_V_depth);
		sprintf(tvout_matrix_o_38_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_38_V, tvout_matrix_o_38_V);

		// release memory allocation
		delete [] matrix_o_38_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_38_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_38_V, wrapc_stream_size_out_matrix_o_38_V);
		sprintf(wrapc_stream_size_out_matrix_o_38_V, "%d\n", aesl_tmp_403 - aesl_tmp_404);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_38_V, wrapc_stream_size_out_matrix_o_38_V);
		sprintf(wrapc_stream_size_out_matrix_o_38_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_38_V, wrapc_stream_size_out_matrix_o_38_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_39_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_39_V, tvout_matrix_o_39_V);

		sc_bv<16>* matrix_o_39_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_406 - aesl_tmp_407];

		// RTL Name: matrix_o_39_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_407) => (aesl_tmp_406 - 1) @ (1)
					for (int i_0 = aesl_tmp_407; i_0 <= aesl_tmp_406 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_405[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_405[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_405[i_0]
						if (&(aesl_tmp_405[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_405[i_0];
							matrix_o_39_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_406 - aesl_tmp_407; i++)
		{
			sprintf(tvout_matrix_o_39_V, "%s\n", (matrix_o_39_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_39_V, tvout_matrix_o_39_V);
		}

		tcl_file.set_num(aesl_tmp_406 - aesl_tmp_407, &tcl_file.matrix_o_39_V_depth);
		sprintf(tvout_matrix_o_39_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_39_V, tvout_matrix_o_39_V);

		// release memory allocation
		delete [] matrix_o_39_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_39_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_39_V, wrapc_stream_size_out_matrix_o_39_V);
		sprintf(wrapc_stream_size_out_matrix_o_39_V, "%d\n", aesl_tmp_406 - aesl_tmp_407);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_39_V, wrapc_stream_size_out_matrix_o_39_V);
		sprintf(wrapc_stream_size_out_matrix_o_39_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_39_V, wrapc_stream_size_out_matrix_o_39_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_40_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_40_V, tvout_matrix_o_40_V);

		sc_bv<16>* matrix_o_40_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_409 - aesl_tmp_410];

		// RTL Name: matrix_o_40_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_410) => (aesl_tmp_409 - 1) @ (1)
					for (int i_0 = aesl_tmp_410; i_0 <= aesl_tmp_409 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_408[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_408[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_408[i_0]
						if (&(aesl_tmp_408[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_408[i_0];
							matrix_o_40_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_409 - aesl_tmp_410; i++)
		{
			sprintf(tvout_matrix_o_40_V, "%s\n", (matrix_o_40_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_40_V, tvout_matrix_o_40_V);
		}

		tcl_file.set_num(aesl_tmp_409 - aesl_tmp_410, &tcl_file.matrix_o_40_V_depth);
		sprintf(tvout_matrix_o_40_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_40_V, tvout_matrix_o_40_V);

		// release memory allocation
		delete [] matrix_o_40_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_40_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_40_V, wrapc_stream_size_out_matrix_o_40_V);
		sprintf(wrapc_stream_size_out_matrix_o_40_V, "%d\n", aesl_tmp_409 - aesl_tmp_410);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_40_V, wrapc_stream_size_out_matrix_o_40_V);
		sprintf(wrapc_stream_size_out_matrix_o_40_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_40_V, wrapc_stream_size_out_matrix_o_40_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_41_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_41_V, tvout_matrix_o_41_V);

		sc_bv<16>* matrix_o_41_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_412 - aesl_tmp_413];

		// RTL Name: matrix_o_41_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_413) => (aesl_tmp_412 - 1) @ (1)
					for (int i_0 = aesl_tmp_413; i_0 <= aesl_tmp_412 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_411[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_411[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_411[i_0]
						if (&(aesl_tmp_411[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_411[i_0];
							matrix_o_41_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_412 - aesl_tmp_413; i++)
		{
			sprintf(tvout_matrix_o_41_V, "%s\n", (matrix_o_41_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_41_V, tvout_matrix_o_41_V);
		}

		tcl_file.set_num(aesl_tmp_412 - aesl_tmp_413, &tcl_file.matrix_o_41_V_depth);
		sprintf(tvout_matrix_o_41_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_41_V, tvout_matrix_o_41_V);

		// release memory allocation
		delete [] matrix_o_41_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_41_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_41_V, wrapc_stream_size_out_matrix_o_41_V);
		sprintf(wrapc_stream_size_out_matrix_o_41_V, "%d\n", aesl_tmp_412 - aesl_tmp_413);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_41_V, wrapc_stream_size_out_matrix_o_41_V);
		sprintf(wrapc_stream_size_out_matrix_o_41_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_41_V, wrapc_stream_size_out_matrix_o_41_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_42_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_42_V, tvout_matrix_o_42_V);

		sc_bv<16>* matrix_o_42_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_415 - aesl_tmp_416];

		// RTL Name: matrix_o_42_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_416) => (aesl_tmp_415 - 1) @ (1)
					for (int i_0 = aesl_tmp_416; i_0 <= aesl_tmp_415 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_414[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_414[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_414[i_0]
						if (&(aesl_tmp_414[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_414[i_0];
							matrix_o_42_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_415 - aesl_tmp_416; i++)
		{
			sprintf(tvout_matrix_o_42_V, "%s\n", (matrix_o_42_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_42_V, tvout_matrix_o_42_V);
		}

		tcl_file.set_num(aesl_tmp_415 - aesl_tmp_416, &tcl_file.matrix_o_42_V_depth);
		sprintf(tvout_matrix_o_42_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_42_V, tvout_matrix_o_42_V);

		// release memory allocation
		delete [] matrix_o_42_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_42_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_42_V, wrapc_stream_size_out_matrix_o_42_V);
		sprintf(wrapc_stream_size_out_matrix_o_42_V, "%d\n", aesl_tmp_415 - aesl_tmp_416);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_42_V, wrapc_stream_size_out_matrix_o_42_V);
		sprintf(wrapc_stream_size_out_matrix_o_42_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_42_V, wrapc_stream_size_out_matrix_o_42_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_43_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_43_V, tvout_matrix_o_43_V);

		sc_bv<16>* matrix_o_43_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_418 - aesl_tmp_419];

		// RTL Name: matrix_o_43_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_419) => (aesl_tmp_418 - 1) @ (1)
					for (int i_0 = aesl_tmp_419; i_0 <= aesl_tmp_418 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_417[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_417[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_417[i_0]
						if (&(aesl_tmp_417[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_417[i_0];
							matrix_o_43_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_418 - aesl_tmp_419; i++)
		{
			sprintf(tvout_matrix_o_43_V, "%s\n", (matrix_o_43_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_43_V, tvout_matrix_o_43_V);
		}

		tcl_file.set_num(aesl_tmp_418 - aesl_tmp_419, &tcl_file.matrix_o_43_V_depth);
		sprintf(tvout_matrix_o_43_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_43_V, tvout_matrix_o_43_V);

		// release memory allocation
		delete [] matrix_o_43_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_43_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_43_V, wrapc_stream_size_out_matrix_o_43_V);
		sprintf(wrapc_stream_size_out_matrix_o_43_V, "%d\n", aesl_tmp_418 - aesl_tmp_419);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_43_V, wrapc_stream_size_out_matrix_o_43_V);
		sprintf(wrapc_stream_size_out_matrix_o_43_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_43_V, wrapc_stream_size_out_matrix_o_43_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_44_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_44_V, tvout_matrix_o_44_V);

		sc_bv<16>* matrix_o_44_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_421 - aesl_tmp_422];

		// RTL Name: matrix_o_44_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_422) => (aesl_tmp_421 - 1) @ (1)
					for (int i_0 = aesl_tmp_422; i_0 <= aesl_tmp_421 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_420[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_420[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_420[i_0]
						if (&(aesl_tmp_420[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_420[i_0];
							matrix_o_44_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_421 - aesl_tmp_422; i++)
		{
			sprintf(tvout_matrix_o_44_V, "%s\n", (matrix_o_44_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_44_V, tvout_matrix_o_44_V);
		}

		tcl_file.set_num(aesl_tmp_421 - aesl_tmp_422, &tcl_file.matrix_o_44_V_depth);
		sprintf(tvout_matrix_o_44_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_44_V, tvout_matrix_o_44_V);

		// release memory allocation
		delete [] matrix_o_44_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_44_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_44_V, wrapc_stream_size_out_matrix_o_44_V);
		sprintf(wrapc_stream_size_out_matrix_o_44_V, "%d\n", aesl_tmp_421 - aesl_tmp_422);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_44_V, wrapc_stream_size_out_matrix_o_44_V);
		sprintf(wrapc_stream_size_out_matrix_o_44_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_44_V, wrapc_stream_size_out_matrix_o_44_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_45_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_45_V, tvout_matrix_o_45_V);

		sc_bv<16>* matrix_o_45_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_424 - aesl_tmp_425];

		// RTL Name: matrix_o_45_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_425) => (aesl_tmp_424 - 1) @ (1)
					for (int i_0 = aesl_tmp_425; i_0 <= aesl_tmp_424 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_423[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_423[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_423[i_0]
						if (&(aesl_tmp_423[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_423[i_0];
							matrix_o_45_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_424 - aesl_tmp_425; i++)
		{
			sprintf(tvout_matrix_o_45_V, "%s\n", (matrix_o_45_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_45_V, tvout_matrix_o_45_V);
		}

		tcl_file.set_num(aesl_tmp_424 - aesl_tmp_425, &tcl_file.matrix_o_45_V_depth);
		sprintf(tvout_matrix_o_45_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_45_V, tvout_matrix_o_45_V);

		// release memory allocation
		delete [] matrix_o_45_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_45_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_45_V, wrapc_stream_size_out_matrix_o_45_V);
		sprintf(wrapc_stream_size_out_matrix_o_45_V, "%d\n", aesl_tmp_424 - aesl_tmp_425);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_45_V, wrapc_stream_size_out_matrix_o_45_V);
		sprintf(wrapc_stream_size_out_matrix_o_45_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_45_V, wrapc_stream_size_out_matrix_o_45_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_46_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_46_V, tvout_matrix_o_46_V);

		sc_bv<16>* matrix_o_46_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_427 - aesl_tmp_428];

		// RTL Name: matrix_o_46_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_428) => (aesl_tmp_427 - 1) @ (1)
					for (int i_0 = aesl_tmp_428; i_0 <= aesl_tmp_427 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_426[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_426[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_426[i_0]
						if (&(aesl_tmp_426[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_426[i_0];
							matrix_o_46_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_427 - aesl_tmp_428; i++)
		{
			sprintf(tvout_matrix_o_46_V, "%s\n", (matrix_o_46_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_46_V, tvout_matrix_o_46_V);
		}

		tcl_file.set_num(aesl_tmp_427 - aesl_tmp_428, &tcl_file.matrix_o_46_V_depth);
		sprintf(tvout_matrix_o_46_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_46_V, tvout_matrix_o_46_V);

		// release memory allocation
		delete [] matrix_o_46_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_46_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_46_V, wrapc_stream_size_out_matrix_o_46_V);
		sprintf(wrapc_stream_size_out_matrix_o_46_V, "%d\n", aesl_tmp_427 - aesl_tmp_428);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_46_V, wrapc_stream_size_out_matrix_o_46_V);
		sprintf(wrapc_stream_size_out_matrix_o_46_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_46_V, wrapc_stream_size_out_matrix_o_46_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_47_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_47_V, tvout_matrix_o_47_V);

		sc_bv<16>* matrix_o_47_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_430 - aesl_tmp_431];

		// RTL Name: matrix_o_47_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_431) => (aesl_tmp_430 - 1) @ (1)
					for (int i_0 = aesl_tmp_431; i_0 <= aesl_tmp_430 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_429[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_429[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_429[i_0]
						if (&(aesl_tmp_429[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_429[i_0];
							matrix_o_47_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_430 - aesl_tmp_431; i++)
		{
			sprintf(tvout_matrix_o_47_V, "%s\n", (matrix_o_47_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_47_V, tvout_matrix_o_47_V);
		}

		tcl_file.set_num(aesl_tmp_430 - aesl_tmp_431, &tcl_file.matrix_o_47_V_depth);
		sprintf(tvout_matrix_o_47_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_47_V, tvout_matrix_o_47_V);

		// release memory allocation
		delete [] matrix_o_47_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_47_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_47_V, wrapc_stream_size_out_matrix_o_47_V);
		sprintf(wrapc_stream_size_out_matrix_o_47_V, "%d\n", aesl_tmp_430 - aesl_tmp_431);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_47_V, wrapc_stream_size_out_matrix_o_47_V);
		sprintf(wrapc_stream_size_out_matrix_o_47_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_47_V, wrapc_stream_size_out_matrix_o_47_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_48_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_48_V, tvout_matrix_o_48_V);

		sc_bv<16>* matrix_o_48_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_433 - aesl_tmp_434];

		// RTL Name: matrix_o_48_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_434) => (aesl_tmp_433 - 1) @ (1)
					for (int i_0 = aesl_tmp_434; i_0 <= aesl_tmp_433 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_432[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_432[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_432[i_0]
						if (&(aesl_tmp_432[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_432[i_0];
							matrix_o_48_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_433 - aesl_tmp_434; i++)
		{
			sprintf(tvout_matrix_o_48_V, "%s\n", (matrix_o_48_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_48_V, tvout_matrix_o_48_V);
		}

		tcl_file.set_num(aesl_tmp_433 - aesl_tmp_434, &tcl_file.matrix_o_48_V_depth);
		sprintf(tvout_matrix_o_48_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_48_V, tvout_matrix_o_48_V);

		// release memory allocation
		delete [] matrix_o_48_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_48_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_48_V, wrapc_stream_size_out_matrix_o_48_V);
		sprintf(wrapc_stream_size_out_matrix_o_48_V, "%d\n", aesl_tmp_433 - aesl_tmp_434);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_48_V, wrapc_stream_size_out_matrix_o_48_V);
		sprintf(wrapc_stream_size_out_matrix_o_48_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_48_V, wrapc_stream_size_out_matrix_o_48_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_49_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_49_V, tvout_matrix_o_49_V);

		sc_bv<16>* matrix_o_49_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_436 - aesl_tmp_437];

		// RTL Name: matrix_o_49_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_437) => (aesl_tmp_436 - 1) @ (1)
					for (int i_0 = aesl_tmp_437; i_0 <= aesl_tmp_436 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_435[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_435[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_435[i_0]
						if (&(aesl_tmp_435[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_435[i_0];
							matrix_o_49_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_436 - aesl_tmp_437; i++)
		{
			sprintf(tvout_matrix_o_49_V, "%s\n", (matrix_o_49_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_49_V, tvout_matrix_o_49_V);
		}

		tcl_file.set_num(aesl_tmp_436 - aesl_tmp_437, &tcl_file.matrix_o_49_V_depth);
		sprintf(tvout_matrix_o_49_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_49_V, tvout_matrix_o_49_V);

		// release memory allocation
		delete [] matrix_o_49_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_49_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_49_V, wrapc_stream_size_out_matrix_o_49_V);
		sprintf(wrapc_stream_size_out_matrix_o_49_V, "%d\n", aesl_tmp_436 - aesl_tmp_437);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_49_V, wrapc_stream_size_out_matrix_o_49_V);
		sprintf(wrapc_stream_size_out_matrix_o_49_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_49_V, wrapc_stream_size_out_matrix_o_49_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_50_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_50_V, tvout_matrix_o_50_V);

		sc_bv<16>* matrix_o_50_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_439 - aesl_tmp_440];

		// RTL Name: matrix_o_50_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_440) => (aesl_tmp_439 - 1) @ (1)
					for (int i_0 = aesl_tmp_440; i_0 <= aesl_tmp_439 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_438[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_438[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_438[i_0]
						if (&(aesl_tmp_438[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_438[i_0];
							matrix_o_50_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_439 - aesl_tmp_440; i++)
		{
			sprintf(tvout_matrix_o_50_V, "%s\n", (matrix_o_50_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_50_V, tvout_matrix_o_50_V);
		}

		tcl_file.set_num(aesl_tmp_439 - aesl_tmp_440, &tcl_file.matrix_o_50_V_depth);
		sprintf(tvout_matrix_o_50_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_50_V, tvout_matrix_o_50_V);

		// release memory allocation
		delete [] matrix_o_50_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_50_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_50_V, wrapc_stream_size_out_matrix_o_50_V);
		sprintf(wrapc_stream_size_out_matrix_o_50_V, "%d\n", aesl_tmp_439 - aesl_tmp_440);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_50_V, wrapc_stream_size_out_matrix_o_50_V);
		sprintf(wrapc_stream_size_out_matrix_o_50_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_50_V, wrapc_stream_size_out_matrix_o_50_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_51_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_51_V, tvout_matrix_o_51_V);

		sc_bv<16>* matrix_o_51_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_442 - aesl_tmp_443];

		// RTL Name: matrix_o_51_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_443) => (aesl_tmp_442 - 1) @ (1)
					for (int i_0 = aesl_tmp_443; i_0 <= aesl_tmp_442 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_441[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_441[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_441[i_0]
						if (&(aesl_tmp_441[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_441[i_0];
							matrix_o_51_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_442 - aesl_tmp_443; i++)
		{
			sprintf(tvout_matrix_o_51_V, "%s\n", (matrix_o_51_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_51_V, tvout_matrix_o_51_V);
		}

		tcl_file.set_num(aesl_tmp_442 - aesl_tmp_443, &tcl_file.matrix_o_51_V_depth);
		sprintf(tvout_matrix_o_51_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_51_V, tvout_matrix_o_51_V);

		// release memory allocation
		delete [] matrix_o_51_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_51_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_51_V, wrapc_stream_size_out_matrix_o_51_V);
		sprintf(wrapc_stream_size_out_matrix_o_51_V, "%d\n", aesl_tmp_442 - aesl_tmp_443);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_51_V, wrapc_stream_size_out_matrix_o_51_V);
		sprintf(wrapc_stream_size_out_matrix_o_51_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_51_V, wrapc_stream_size_out_matrix_o_51_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_52_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_52_V, tvout_matrix_o_52_V);

		sc_bv<16>* matrix_o_52_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_445 - aesl_tmp_446];

		// RTL Name: matrix_o_52_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_446) => (aesl_tmp_445 - 1) @ (1)
					for (int i_0 = aesl_tmp_446; i_0 <= aesl_tmp_445 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_444[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_444[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_444[i_0]
						if (&(aesl_tmp_444[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_444[i_0];
							matrix_o_52_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_445 - aesl_tmp_446; i++)
		{
			sprintf(tvout_matrix_o_52_V, "%s\n", (matrix_o_52_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_52_V, tvout_matrix_o_52_V);
		}

		tcl_file.set_num(aesl_tmp_445 - aesl_tmp_446, &tcl_file.matrix_o_52_V_depth);
		sprintf(tvout_matrix_o_52_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_52_V, tvout_matrix_o_52_V);

		// release memory allocation
		delete [] matrix_o_52_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_52_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_52_V, wrapc_stream_size_out_matrix_o_52_V);
		sprintf(wrapc_stream_size_out_matrix_o_52_V, "%d\n", aesl_tmp_445 - aesl_tmp_446);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_52_V, wrapc_stream_size_out_matrix_o_52_V);
		sprintf(wrapc_stream_size_out_matrix_o_52_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_52_V, wrapc_stream_size_out_matrix_o_52_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_53_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_53_V, tvout_matrix_o_53_V);

		sc_bv<16>* matrix_o_53_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_448 - aesl_tmp_449];

		// RTL Name: matrix_o_53_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_449) => (aesl_tmp_448 - 1) @ (1)
					for (int i_0 = aesl_tmp_449; i_0 <= aesl_tmp_448 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_447[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_447[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_447[i_0]
						if (&(aesl_tmp_447[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_447[i_0];
							matrix_o_53_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_448 - aesl_tmp_449; i++)
		{
			sprintf(tvout_matrix_o_53_V, "%s\n", (matrix_o_53_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_53_V, tvout_matrix_o_53_V);
		}

		tcl_file.set_num(aesl_tmp_448 - aesl_tmp_449, &tcl_file.matrix_o_53_V_depth);
		sprintf(tvout_matrix_o_53_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_53_V, tvout_matrix_o_53_V);

		// release memory allocation
		delete [] matrix_o_53_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_53_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_53_V, wrapc_stream_size_out_matrix_o_53_V);
		sprintf(wrapc_stream_size_out_matrix_o_53_V, "%d\n", aesl_tmp_448 - aesl_tmp_449);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_53_V, wrapc_stream_size_out_matrix_o_53_V);
		sprintf(wrapc_stream_size_out_matrix_o_53_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_53_V, wrapc_stream_size_out_matrix_o_53_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_54_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_54_V, tvout_matrix_o_54_V);

		sc_bv<16>* matrix_o_54_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_451 - aesl_tmp_452];

		// RTL Name: matrix_o_54_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_452) => (aesl_tmp_451 - 1) @ (1)
					for (int i_0 = aesl_tmp_452; i_0 <= aesl_tmp_451 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_450[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_450[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_450[i_0]
						if (&(aesl_tmp_450[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_450[i_0];
							matrix_o_54_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_451 - aesl_tmp_452; i++)
		{
			sprintf(tvout_matrix_o_54_V, "%s\n", (matrix_o_54_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_54_V, tvout_matrix_o_54_V);
		}

		tcl_file.set_num(aesl_tmp_451 - aesl_tmp_452, &tcl_file.matrix_o_54_V_depth);
		sprintf(tvout_matrix_o_54_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_54_V, tvout_matrix_o_54_V);

		// release memory allocation
		delete [] matrix_o_54_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_54_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_54_V, wrapc_stream_size_out_matrix_o_54_V);
		sprintf(wrapc_stream_size_out_matrix_o_54_V, "%d\n", aesl_tmp_451 - aesl_tmp_452);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_54_V, wrapc_stream_size_out_matrix_o_54_V);
		sprintf(wrapc_stream_size_out_matrix_o_54_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_54_V, wrapc_stream_size_out_matrix_o_54_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_55_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_55_V, tvout_matrix_o_55_V);

		sc_bv<16>* matrix_o_55_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_454 - aesl_tmp_455];

		// RTL Name: matrix_o_55_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_455) => (aesl_tmp_454 - 1) @ (1)
					for (int i_0 = aesl_tmp_455; i_0 <= aesl_tmp_454 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_453[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_453[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_453[i_0]
						if (&(aesl_tmp_453[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_453[i_0];
							matrix_o_55_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_454 - aesl_tmp_455; i++)
		{
			sprintf(tvout_matrix_o_55_V, "%s\n", (matrix_o_55_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_55_V, tvout_matrix_o_55_V);
		}

		tcl_file.set_num(aesl_tmp_454 - aesl_tmp_455, &tcl_file.matrix_o_55_V_depth);
		sprintf(tvout_matrix_o_55_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_55_V, tvout_matrix_o_55_V);

		// release memory allocation
		delete [] matrix_o_55_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_55_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_55_V, wrapc_stream_size_out_matrix_o_55_V);
		sprintf(wrapc_stream_size_out_matrix_o_55_V, "%d\n", aesl_tmp_454 - aesl_tmp_455);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_55_V, wrapc_stream_size_out_matrix_o_55_V);
		sprintf(wrapc_stream_size_out_matrix_o_55_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_55_V, wrapc_stream_size_out_matrix_o_55_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_56_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_56_V, tvout_matrix_o_56_V);

		sc_bv<16>* matrix_o_56_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_457 - aesl_tmp_458];

		// RTL Name: matrix_o_56_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_458) => (aesl_tmp_457 - 1) @ (1)
					for (int i_0 = aesl_tmp_458; i_0 <= aesl_tmp_457 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_456[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_456[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_456[i_0]
						if (&(aesl_tmp_456[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_456[i_0];
							matrix_o_56_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_457 - aesl_tmp_458; i++)
		{
			sprintf(tvout_matrix_o_56_V, "%s\n", (matrix_o_56_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_56_V, tvout_matrix_o_56_V);
		}

		tcl_file.set_num(aesl_tmp_457 - aesl_tmp_458, &tcl_file.matrix_o_56_V_depth);
		sprintf(tvout_matrix_o_56_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_56_V, tvout_matrix_o_56_V);

		// release memory allocation
		delete [] matrix_o_56_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_56_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_56_V, wrapc_stream_size_out_matrix_o_56_V);
		sprintf(wrapc_stream_size_out_matrix_o_56_V, "%d\n", aesl_tmp_457 - aesl_tmp_458);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_56_V, wrapc_stream_size_out_matrix_o_56_V);
		sprintf(wrapc_stream_size_out_matrix_o_56_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_56_V, wrapc_stream_size_out_matrix_o_56_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_57_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_57_V, tvout_matrix_o_57_V);

		sc_bv<16>* matrix_o_57_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_460 - aesl_tmp_461];

		// RTL Name: matrix_o_57_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_461) => (aesl_tmp_460 - 1) @ (1)
					for (int i_0 = aesl_tmp_461; i_0 <= aesl_tmp_460 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_459[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_459[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_459[i_0]
						if (&(aesl_tmp_459[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_459[i_0];
							matrix_o_57_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_460 - aesl_tmp_461; i++)
		{
			sprintf(tvout_matrix_o_57_V, "%s\n", (matrix_o_57_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_57_V, tvout_matrix_o_57_V);
		}

		tcl_file.set_num(aesl_tmp_460 - aesl_tmp_461, &tcl_file.matrix_o_57_V_depth);
		sprintf(tvout_matrix_o_57_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_57_V, tvout_matrix_o_57_V);

		// release memory allocation
		delete [] matrix_o_57_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_57_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_57_V, wrapc_stream_size_out_matrix_o_57_V);
		sprintf(wrapc_stream_size_out_matrix_o_57_V, "%d\n", aesl_tmp_460 - aesl_tmp_461);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_57_V, wrapc_stream_size_out_matrix_o_57_V);
		sprintf(wrapc_stream_size_out_matrix_o_57_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_57_V, wrapc_stream_size_out_matrix_o_57_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_58_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_58_V, tvout_matrix_o_58_V);

		sc_bv<16>* matrix_o_58_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_463 - aesl_tmp_464];

		// RTL Name: matrix_o_58_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_464) => (aesl_tmp_463 - 1) @ (1)
					for (int i_0 = aesl_tmp_464; i_0 <= aesl_tmp_463 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_462[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_462[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_462[i_0]
						if (&(aesl_tmp_462[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_462[i_0];
							matrix_o_58_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_463 - aesl_tmp_464; i++)
		{
			sprintf(tvout_matrix_o_58_V, "%s\n", (matrix_o_58_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_58_V, tvout_matrix_o_58_V);
		}

		tcl_file.set_num(aesl_tmp_463 - aesl_tmp_464, &tcl_file.matrix_o_58_V_depth);
		sprintf(tvout_matrix_o_58_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_58_V, tvout_matrix_o_58_V);

		// release memory allocation
		delete [] matrix_o_58_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_58_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_58_V, wrapc_stream_size_out_matrix_o_58_V);
		sprintf(wrapc_stream_size_out_matrix_o_58_V, "%d\n", aesl_tmp_463 - aesl_tmp_464);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_58_V, wrapc_stream_size_out_matrix_o_58_V);
		sprintf(wrapc_stream_size_out_matrix_o_58_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_58_V, wrapc_stream_size_out_matrix_o_58_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_59_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_59_V, tvout_matrix_o_59_V);

		sc_bv<16>* matrix_o_59_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_466 - aesl_tmp_467];

		// RTL Name: matrix_o_59_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_467) => (aesl_tmp_466 - 1) @ (1)
					for (int i_0 = aesl_tmp_467; i_0 <= aesl_tmp_466 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_465[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_465[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_465[i_0]
						if (&(aesl_tmp_465[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_465[i_0];
							matrix_o_59_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_466 - aesl_tmp_467; i++)
		{
			sprintf(tvout_matrix_o_59_V, "%s\n", (matrix_o_59_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_59_V, tvout_matrix_o_59_V);
		}

		tcl_file.set_num(aesl_tmp_466 - aesl_tmp_467, &tcl_file.matrix_o_59_V_depth);
		sprintf(tvout_matrix_o_59_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_59_V, tvout_matrix_o_59_V);

		// release memory allocation
		delete [] matrix_o_59_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_59_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_59_V, wrapc_stream_size_out_matrix_o_59_V);
		sprintf(wrapc_stream_size_out_matrix_o_59_V, "%d\n", aesl_tmp_466 - aesl_tmp_467);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_59_V, wrapc_stream_size_out_matrix_o_59_V);
		sprintf(wrapc_stream_size_out_matrix_o_59_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_59_V, wrapc_stream_size_out_matrix_o_59_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_60_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_60_V, tvout_matrix_o_60_V);

		sc_bv<16>* matrix_o_60_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_469 - aesl_tmp_470];

		// RTL Name: matrix_o_60_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_470) => (aesl_tmp_469 - 1) @ (1)
					for (int i_0 = aesl_tmp_470; i_0 <= aesl_tmp_469 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_468[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_468[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_468[i_0]
						if (&(aesl_tmp_468[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_468[i_0];
							matrix_o_60_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_469 - aesl_tmp_470; i++)
		{
			sprintf(tvout_matrix_o_60_V, "%s\n", (matrix_o_60_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_60_V, tvout_matrix_o_60_V);
		}

		tcl_file.set_num(aesl_tmp_469 - aesl_tmp_470, &tcl_file.matrix_o_60_V_depth);
		sprintf(tvout_matrix_o_60_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_60_V, tvout_matrix_o_60_V);

		// release memory allocation
		delete [] matrix_o_60_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_60_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_60_V, wrapc_stream_size_out_matrix_o_60_V);
		sprintf(wrapc_stream_size_out_matrix_o_60_V, "%d\n", aesl_tmp_469 - aesl_tmp_470);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_60_V, wrapc_stream_size_out_matrix_o_60_V);
		sprintf(wrapc_stream_size_out_matrix_o_60_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_60_V, wrapc_stream_size_out_matrix_o_60_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_61_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_61_V, tvout_matrix_o_61_V);

		sc_bv<16>* matrix_o_61_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_472 - aesl_tmp_473];

		// RTL Name: matrix_o_61_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_473) => (aesl_tmp_472 - 1) @ (1)
					for (int i_0 = aesl_tmp_473; i_0 <= aesl_tmp_472 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_471[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_471[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_471[i_0]
						if (&(aesl_tmp_471[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_471[i_0];
							matrix_o_61_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_472 - aesl_tmp_473; i++)
		{
			sprintf(tvout_matrix_o_61_V, "%s\n", (matrix_o_61_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_61_V, tvout_matrix_o_61_V);
		}

		tcl_file.set_num(aesl_tmp_472 - aesl_tmp_473, &tcl_file.matrix_o_61_V_depth);
		sprintf(tvout_matrix_o_61_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_61_V, tvout_matrix_o_61_V);

		// release memory allocation
		delete [] matrix_o_61_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_61_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_61_V, wrapc_stream_size_out_matrix_o_61_V);
		sprintf(wrapc_stream_size_out_matrix_o_61_V, "%d\n", aesl_tmp_472 - aesl_tmp_473);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_61_V, wrapc_stream_size_out_matrix_o_61_V);
		sprintf(wrapc_stream_size_out_matrix_o_61_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_61_V, wrapc_stream_size_out_matrix_o_61_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_62_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_62_V, tvout_matrix_o_62_V);

		sc_bv<16>* matrix_o_62_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_475 - aesl_tmp_476];

		// RTL Name: matrix_o_62_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_476) => (aesl_tmp_475 - 1) @ (1)
					for (int i_0 = aesl_tmp_476; i_0 <= aesl_tmp_475 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_474[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_474[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_474[i_0]
						if (&(aesl_tmp_474[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_474[i_0];
							matrix_o_62_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_475 - aesl_tmp_476; i++)
		{
			sprintf(tvout_matrix_o_62_V, "%s\n", (matrix_o_62_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_62_V, tvout_matrix_o_62_V);
		}

		tcl_file.set_num(aesl_tmp_475 - aesl_tmp_476, &tcl_file.matrix_o_62_V_depth);
		sprintf(tvout_matrix_o_62_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_62_V, tvout_matrix_o_62_V);

		// release memory allocation
		delete [] matrix_o_62_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_62_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_62_V, wrapc_stream_size_out_matrix_o_62_V);
		sprintf(wrapc_stream_size_out_matrix_o_62_V, "%d\n", aesl_tmp_475 - aesl_tmp_476);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_62_V, wrapc_stream_size_out_matrix_o_62_V);
		sprintf(wrapc_stream_size_out_matrix_o_62_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_62_V, wrapc_stream_size_out_matrix_o_62_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_63_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_63_V, tvout_matrix_o_63_V);

		sc_bv<16>* matrix_o_63_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_478 - aesl_tmp_479];

		// RTL Name: matrix_o_63_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_479) => (aesl_tmp_478 - 1) @ (1)
					for (int i_0 = aesl_tmp_479; i_0 <= aesl_tmp_478 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_477[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_477[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_477[i_0]
						if (&(aesl_tmp_477[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_477[i_0];
							matrix_o_63_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_478 - aesl_tmp_479; i++)
		{
			sprintf(tvout_matrix_o_63_V, "%s\n", (matrix_o_63_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_63_V, tvout_matrix_o_63_V);
		}

		tcl_file.set_num(aesl_tmp_478 - aesl_tmp_479, &tcl_file.matrix_o_63_V_depth);
		sprintf(tvout_matrix_o_63_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_63_V, tvout_matrix_o_63_V);

		// release memory allocation
		delete [] matrix_o_63_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_63_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_63_V, wrapc_stream_size_out_matrix_o_63_V);
		sprintf(wrapc_stream_size_out_matrix_o_63_V, "%d\n", aesl_tmp_478 - aesl_tmp_479);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_63_V, wrapc_stream_size_out_matrix_o_63_V);
		sprintf(wrapc_stream_size_out_matrix_o_63_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_63_V, wrapc_stream_size_out_matrix_o_63_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_64_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_64_V, tvout_matrix_o_64_V);

		sc_bv<16>* matrix_o_64_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_481 - aesl_tmp_482];

		// RTL Name: matrix_o_64_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_482) => (aesl_tmp_481 - 1) @ (1)
					for (int i_0 = aesl_tmp_482; i_0 <= aesl_tmp_481 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_480[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_480[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_480[i_0]
						if (&(aesl_tmp_480[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_480[i_0];
							matrix_o_64_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_481 - aesl_tmp_482; i++)
		{
			sprintf(tvout_matrix_o_64_V, "%s\n", (matrix_o_64_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_64_V, tvout_matrix_o_64_V);
		}

		tcl_file.set_num(aesl_tmp_481 - aesl_tmp_482, &tcl_file.matrix_o_64_V_depth);
		sprintf(tvout_matrix_o_64_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_64_V, tvout_matrix_o_64_V);

		// release memory allocation
		delete [] matrix_o_64_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_64_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_64_V, wrapc_stream_size_out_matrix_o_64_V);
		sprintf(wrapc_stream_size_out_matrix_o_64_V, "%d\n", aesl_tmp_481 - aesl_tmp_482);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_64_V, wrapc_stream_size_out_matrix_o_64_V);
		sprintf(wrapc_stream_size_out_matrix_o_64_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_64_V, wrapc_stream_size_out_matrix_o_64_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_65_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_65_V, tvout_matrix_o_65_V);

		sc_bv<16>* matrix_o_65_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_484 - aesl_tmp_485];

		// RTL Name: matrix_o_65_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_485) => (aesl_tmp_484 - 1) @ (1)
					for (int i_0 = aesl_tmp_485; i_0 <= aesl_tmp_484 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_483[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_483[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_483[i_0]
						if (&(aesl_tmp_483[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_483[i_0];
							matrix_o_65_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_484 - aesl_tmp_485; i++)
		{
			sprintf(tvout_matrix_o_65_V, "%s\n", (matrix_o_65_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_65_V, tvout_matrix_o_65_V);
		}

		tcl_file.set_num(aesl_tmp_484 - aesl_tmp_485, &tcl_file.matrix_o_65_V_depth);
		sprintf(tvout_matrix_o_65_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_65_V, tvout_matrix_o_65_V);

		// release memory allocation
		delete [] matrix_o_65_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_65_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_65_V, wrapc_stream_size_out_matrix_o_65_V);
		sprintf(wrapc_stream_size_out_matrix_o_65_V, "%d\n", aesl_tmp_484 - aesl_tmp_485);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_65_V, wrapc_stream_size_out_matrix_o_65_V);
		sprintf(wrapc_stream_size_out_matrix_o_65_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_65_V, wrapc_stream_size_out_matrix_o_65_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_66_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_66_V, tvout_matrix_o_66_V);

		sc_bv<16>* matrix_o_66_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_487 - aesl_tmp_488];

		// RTL Name: matrix_o_66_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_488) => (aesl_tmp_487 - 1) @ (1)
					for (int i_0 = aesl_tmp_488; i_0 <= aesl_tmp_487 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_486[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_486[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_486[i_0]
						if (&(aesl_tmp_486[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_486[i_0];
							matrix_o_66_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_487 - aesl_tmp_488; i++)
		{
			sprintf(tvout_matrix_o_66_V, "%s\n", (matrix_o_66_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_66_V, tvout_matrix_o_66_V);
		}

		tcl_file.set_num(aesl_tmp_487 - aesl_tmp_488, &tcl_file.matrix_o_66_V_depth);
		sprintf(tvout_matrix_o_66_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_66_V, tvout_matrix_o_66_V);

		// release memory allocation
		delete [] matrix_o_66_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_66_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_66_V, wrapc_stream_size_out_matrix_o_66_V);
		sprintf(wrapc_stream_size_out_matrix_o_66_V, "%d\n", aesl_tmp_487 - aesl_tmp_488);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_66_V, wrapc_stream_size_out_matrix_o_66_V);
		sprintf(wrapc_stream_size_out_matrix_o_66_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_66_V, wrapc_stream_size_out_matrix_o_66_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_67_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_67_V, tvout_matrix_o_67_V);

		sc_bv<16>* matrix_o_67_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_490 - aesl_tmp_491];

		// RTL Name: matrix_o_67_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_491) => (aesl_tmp_490 - 1) @ (1)
					for (int i_0 = aesl_tmp_491; i_0 <= aesl_tmp_490 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_489[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_489[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_489[i_0]
						if (&(aesl_tmp_489[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_489[i_0];
							matrix_o_67_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_490 - aesl_tmp_491; i++)
		{
			sprintf(tvout_matrix_o_67_V, "%s\n", (matrix_o_67_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_67_V, tvout_matrix_o_67_V);
		}

		tcl_file.set_num(aesl_tmp_490 - aesl_tmp_491, &tcl_file.matrix_o_67_V_depth);
		sprintf(tvout_matrix_o_67_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_67_V, tvout_matrix_o_67_V);

		// release memory allocation
		delete [] matrix_o_67_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_67_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_67_V, wrapc_stream_size_out_matrix_o_67_V);
		sprintf(wrapc_stream_size_out_matrix_o_67_V, "%d\n", aesl_tmp_490 - aesl_tmp_491);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_67_V, wrapc_stream_size_out_matrix_o_67_V);
		sprintf(wrapc_stream_size_out_matrix_o_67_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_67_V, wrapc_stream_size_out_matrix_o_67_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_68_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_68_V, tvout_matrix_o_68_V);

		sc_bv<16>* matrix_o_68_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_493 - aesl_tmp_494];

		// RTL Name: matrix_o_68_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_494) => (aesl_tmp_493 - 1) @ (1)
					for (int i_0 = aesl_tmp_494; i_0 <= aesl_tmp_493 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_492[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_492[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_492[i_0]
						if (&(aesl_tmp_492[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_492[i_0];
							matrix_o_68_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_493 - aesl_tmp_494; i++)
		{
			sprintf(tvout_matrix_o_68_V, "%s\n", (matrix_o_68_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_68_V, tvout_matrix_o_68_V);
		}

		tcl_file.set_num(aesl_tmp_493 - aesl_tmp_494, &tcl_file.matrix_o_68_V_depth);
		sprintf(tvout_matrix_o_68_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_68_V, tvout_matrix_o_68_V);

		// release memory allocation
		delete [] matrix_o_68_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_68_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_68_V, wrapc_stream_size_out_matrix_o_68_V);
		sprintf(wrapc_stream_size_out_matrix_o_68_V, "%d\n", aesl_tmp_493 - aesl_tmp_494);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_68_V, wrapc_stream_size_out_matrix_o_68_V);
		sprintf(wrapc_stream_size_out_matrix_o_68_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_68_V, wrapc_stream_size_out_matrix_o_68_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_69_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_69_V, tvout_matrix_o_69_V);

		sc_bv<16>* matrix_o_69_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_496 - aesl_tmp_497];

		// RTL Name: matrix_o_69_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_497) => (aesl_tmp_496 - 1) @ (1)
					for (int i_0 = aesl_tmp_497; i_0 <= aesl_tmp_496 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_495[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_495[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_495[i_0]
						if (&(aesl_tmp_495[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_495[i_0];
							matrix_o_69_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_496 - aesl_tmp_497; i++)
		{
			sprintf(tvout_matrix_o_69_V, "%s\n", (matrix_o_69_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_69_V, tvout_matrix_o_69_V);
		}

		tcl_file.set_num(aesl_tmp_496 - aesl_tmp_497, &tcl_file.matrix_o_69_V_depth);
		sprintf(tvout_matrix_o_69_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_69_V, tvout_matrix_o_69_V);

		// release memory allocation
		delete [] matrix_o_69_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_69_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_69_V, wrapc_stream_size_out_matrix_o_69_V);
		sprintf(wrapc_stream_size_out_matrix_o_69_V, "%d\n", aesl_tmp_496 - aesl_tmp_497);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_69_V, wrapc_stream_size_out_matrix_o_69_V);
		sprintf(wrapc_stream_size_out_matrix_o_69_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_69_V, wrapc_stream_size_out_matrix_o_69_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_70_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_70_V, tvout_matrix_o_70_V);

		sc_bv<16>* matrix_o_70_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_499 - aesl_tmp_500];

		// RTL Name: matrix_o_70_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_500) => (aesl_tmp_499 - 1) @ (1)
					for (int i_0 = aesl_tmp_500; i_0 <= aesl_tmp_499 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_498[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_498[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_498[i_0]
						if (&(aesl_tmp_498[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_498[i_0];
							matrix_o_70_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_499 - aesl_tmp_500; i++)
		{
			sprintf(tvout_matrix_o_70_V, "%s\n", (matrix_o_70_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_70_V, tvout_matrix_o_70_V);
		}

		tcl_file.set_num(aesl_tmp_499 - aesl_tmp_500, &tcl_file.matrix_o_70_V_depth);
		sprintf(tvout_matrix_o_70_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_70_V, tvout_matrix_o_70_V);

		// release memory allocation
		delete [] matrix_o_70_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_70_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_70_V, wrapc_stream_size_out_matrix_o_70_V);
		sprintf(wrapc_stream_size_out_matrix_o_70_V, "%d\n", aesl_tmp_499 - aesl_tmp_500);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_70_V, wrapc_stream_size_out_matrix_o_70_V);
		sprintf(wrapc_stream_size_out_matrix_o_70_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_70_V, wrapc_stream_size_out_matrix_o_70_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_71_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_71_V, tvout_matrix_o_71_V);

		sc_bv<16>* matrix_o_71_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_502 - aesl_tmp_503];

		// RTL Name: matrix_o_71_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_503) => (aesl_tmp_502 - 1) @ (1)
					for (int i_0 = aesl_tmp_503; i_0 <= aesl_tmp_502 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_501[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_501[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_501[i_0]
						if (&(aesl_tmp_501[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_501[i_0];
							matrix_o_71_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_502 - aesl_tmp_503; i++)
		{
			sprintf(tvout_matrix_o_71_V, "%s\n", (matrix_o_71_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_71_V, tvout_matrix_o_71_V);
		}

		tcl_file.set_num(aesl_tmp_502 - aesl_tmp_503, &tcl_file.matrix_o_71_V_depth);
		sprintf(tvout_matrix_o_71_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_71_V, tvout_matrix_o_71_V);

		// release memory allocation
		delete [] matrix_o_71_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_71_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_71_V, wrapc_stream_size_out_matrix_o_71_V);
		sprintf(wrapc_stream_size_out_matrix_o_71_V, "%d\n", aesl_tmp_502 - aesl_tmp_503);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_71_V, wrapc_stream_size_out_matrix_o_71_V);
		sprintf(wrapc_stream_size_out_matrix_o_71_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_71_V, wrapc_stream_size_out_matrix_o_71_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_72_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_72_V, tvout_matrix_o_72_V);

		sc_bv<16>* matrix_o_72_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_505 - aesl_tmp_506];

		// RTL Name: matrix_o_72_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_506) => (aesl_tmp_505 - 1) @ (1)
					for (int i_0 = aesl_tmp_506; i_0 <= aesl_tmp_505 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_504[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_504[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_504[i_0]
						if (&(aesl_tmp_504[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_504[i_0];
							matrix_o_72_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_505 - aesl_tmp_506; i++)
		{
			sprintf(tvout_matrix_o_72_V, "%s\n", (matrix_o_72_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_72_V, tvout_matrix_o_72_V);
		}

		tcl_file.set_num(aesl_tmp_505 - aesl_tmp_506, &tcl_file.matrix_o_72_V_depth);
		sprintf(tvout_matrix_o_72_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_72_V, tvout_matrix_o_72_V);

		// release memory allocation
		delete [] matrix_o_72_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_72_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_72_V, wrapc_stream_size_out_matrix_o_72_V);
		sprintf(wrapc_stream_size_out_matrix_o_72_V, "%d\n", aesl_tmp_505 - aesl_tmp_506);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_72_V, wrapc_stream_size_out_matrix_o_72_V);
		sprintf(wrapc_stream_size_out_matrix_o_72_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_72_V, wrapc_stream_size_out_matrix_o_72_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_73_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_73_V, tvout_matrix_o_73_V);

		sc_bv<16>* matrix_o_73_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_508 - aesl_tmp_509];

		// RTL Name: matrix_o_73_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_509) => (aesl_tmp_508 - 1) @ (1)
					for (int i_0 = aesl_tmp_509; i_0 <= aesl_tmp_508 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_507[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_507[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_507[i_0]
						if (&(aesl_tmp_507[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_507[i_0];
							matrix_o_73_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_508 - aesl_tmp_509; i++)
		{
			sprintf(tvout_matrix_o_73_V, "%s\n", (matrix_o_73_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_73_V, tvout_matrix_o_73_V);
		}

		tcl_file.set_num(aesl_tmp_508 - aesl_tmp_509, &tcl_file.matrix_o_73_V_depth);
		sprintf(tvout_matrix_o_73_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_73_V, tvout_matrix_o_73_V);

		// release memory allocation
		delete [] matrix_o_73_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_73_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_73_V, wrapc_stream_size_out_matrix_o_73_V);
		sprintf(wrapc_stream_size_out_matrix_o_73_V, "%d\n", aesl_tmp_508 - aesl_tmp_509);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_73_V, wrapc_stream_size_out_matrix_o_73_V);
		sprintf(wrapc_stream_size_out_matrix_o_73_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_73_V, wrapc_stream_size_out_matrix_o_73_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_74_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_74_V, tvout_matrix_o_74_V);

		sc_bv<16>* matrix_o_74_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_511 - aesl_tmp_512];

		// RTL Name: matrix_o_74_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_512) => (aesl_tmp_511 - 1) @ (1)
					for (int i_0 = aesl_tmp_512; i_0 <= aesl_tmp_511 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_510[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_510[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_510[i_0]
						if (&(aesl_tmp_510[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_510[i_0];
							matrix_o_74_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_511 - aesl_tmp_512; i++)
		{
			sprintf(tvout_matrix_o_74_V, "%s\n", (matrix_o_74_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_74_V, tvout_matrix_o_74_V);
		}

		tcl_file.set_num(aesl_tmp_511 - aesl_tmp_512, &tcl_file.matrix_o_74_V_depth);
		sprintf(tvout_matrix_o_74_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_74_V, tvout_matrix_o_74_V);

		// release memory allocation
		delete [] matrix_o_74_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_74_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_74_V, wrapc_stream_size_out_matrix_o_74_V);
		sprintf(wrapc_stream_size_out_matrix_o_74_V, "%d\n", aesl_tmp_511 - aesl_tmp_512);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_74_V, wrapc_stream_size_out_matrix_o_74_V);
		sprintf(wrapc_stream_size_out_matrix_o_74_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_74_V, wrapc_stream_size_out_matrix_o_74_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_75_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_75_V, tvout_matrix_o_75_V);

		sc_bv<16>* matrix_o_75_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_514 - aesl_tmp_515];

		// RTL Name: matrix_o_75_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_515) => (aesl_tmp_514 - 1) @ (1)
					for (int i_0 = aesl_tmp_515; i_0 <= aesl_tmp_514 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_513[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_513[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_513[i_0]
						if (&(aesl_tmp_513[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_513[i_0];
							matrix_o_75_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_514 - aesl_tmp_515; i++)
		{
			sprintf(tvout_matrix_o_75_V, "%s\n", (matrix_o_75_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_75_V, tvout_matrix_o_75_V);
		}

		tcl_file.set_num(aesl_tmp_514 - aesl_tmp_515, &tcl_file.matrix_o_75_V_depth);
		sprintf(tvout_matrix_o_75_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_75_V, tvout_matrix_o_75_V);

		// release memory allocation
		delete [] matrix_o_75_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_75_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_75_V, wrapc_stream_size_out_matrix_o_75_V);
		sprintf(wrapc_stream_size_out_matrix_o_75_V, "%d\n", aesl_tmp_514 - aesl_tmp_515);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_75_V, wrapc_stream_size_out_matrix_o_75_V);
		sprintf(wrapc_stream_size_out_matrix_o_75_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_75_V, wrapc_stream_size_out_matrix_o_75_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_76_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_76_V, tvout_matrix_o_76_V);

		sc_bv<16>* matrix_o_76_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_517 - aesl_tmp_518];

		// RTL Name: matrix_o_76_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_518) => (aesl_tmp_517 - 1) @ (1)
					for (int i_0 = aesl_tmp_518; i_0 <= aesl_tmp_517 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_516[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_516[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_516[i_0]
						if (&(aesl_tmp_516[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_516[i_0];
							matrix_o_76_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_517 - aesl_tmp_518; i++)
		{
			sprintf(tvout_matrix_o_76_V, "%s\n", (matrix_o_76_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_76_V, tvout_matrix_o_76_V);
		}

		tcl_file.set_num(aesl_tmp_517 - aesl_tmp_518, &tcl_file.matrix_o_76_V_depth);
		sprintf(tvout_matrix_o_76_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_76_V, tvout_matrix_o_76_V);

		// release memory allocation
		delete [] matrix_o_76_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_76_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_76_V, wrapc_stream_size_out_matrix_o_76_V);
		sprintf(wrapc_stream_size_out_matrix_o_76_V, "%d\n", aesl_tmp_517 - aesl_tmp_518);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_76_V, wrapc_stream_size_out_matrix_o_76_V);
		sprintf(wrapc_stream_size_out_matrix_o_76_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_76_V, wrapc_stream_size_out_matrix_o_76_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_77_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_77_V, tvout_matrix_o_77_V);

		sc_bv<16>* matrix_o_77_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_520 - aesl_tmp_521];

		// RTL Name: matrix_o_77_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_521) => (aesl_tmp_520 - 1) @ (1)
					for (int i_0 = aesl_tmp_521; i_0 <= aesl_tmp_520 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_519[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_519[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_519[i_0]
						if (&(aesl_tmp_519[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_519[i_0];
							matrix_o_77_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_520 - aesl_tmp_521; i++)
		{
			sprintf(tvout_matrix_o_77_V, "%s\n", (matrix_o_77_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_77_V, tvout_matrix_o_77_V);
		}

		tcl_file.set_num(aesl_tmp_520 - aesl_tmp_521, &tcl_file.matrix_o_77_V_depth);
		sprintf(tvout_matrix_o_77_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_77_V, tvout_matrix_o_77_V);

		// release memory allocation
		delete [] matrix_o_77_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_77_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_77_V, wrapc_stream_size_out_matrix_o_77_V);
		sprintf(wrapc_stream_size_out_matrix_o_77_V, "%d\n", aesl_tmp_520 - aesl_tmp_521);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_77_V, wrapc_stream_size_out_matrix_o_77_V);
		sprintf(wrapc_stream_size_out_matrix_o_77_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_77_V, wrapc_stream_size_out_matrix_o_77_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_78_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_78_V, tvout_matrix_o_78_V);

		sc_bv<16>* matrix_o_78_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_523 - aesl_tmp_524];

		// RTL Name: matrix_o_78_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_524) => (aesl_tmp_523 - 1) @ (1)
					for (int i_0 = aesl_tmp_524; i_0 <= aesl_tmp_523 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_522[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_522[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_522[i_0]
						if (&(aesl_tmp_522[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_522[i_0];
							matrix_o_78_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_523 - aesl_tmp_524; i++)
		{
			sprintf(tvout_matrix_o_78_V, "%s\n", (matrix_o_78_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_78_V, tvout_matrix_o_78_V);
		}

		tcl_file.set_num(aesl_tmp_523 - aesl_tmp_524, &tcl_file.matrix_o_78_V_depth);
		sprintf(tvout_matrix_o_78_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_78_V, tvout_matrix_o_78_V);

		// release memory allocation
		delete [] matrix_o_78_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_78_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_78_V, wrapc_stream_size_out_matrix_o_78_V);
		sprintf(wrapc_stream_size_out_matrix_o_78_V, "%d\n", aesl_tmp_523 - aesl_tmp_524);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_78_V, wrapc_stream_size_out_matrix_o_78_V);
		sprintf(wrapc_stream_size_out_matrix_o_78_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_78_V, wrapc_stream_size_out_matrix_o_78_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_79_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_79_V, tvout_matrix_o_79_V);

		sc_bv<16>* matrix_o_79_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_526 - aesl_tmp_527];

		// RTL Name: matrix_o_79_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_527) => (aesl_tmp_526 - 1) @ (1)
					for (int i_0 = aesl_tmp_527; i_0 <= aesl_tmp_526 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_525[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_525[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_525[i_0]
						if (&(aesl_tmp_525[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_525[i_0];
							matrix_o_79_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_526 - aesl_tmp_527; i++)
		{
			sprintf(tvout_matrix_o_79_V, "%s\n", (matrix_o_79_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_79_V, tvout_matrix_o_79_V);
		}

		tcl_file.set_num(aesl_tmp_526 - aesl_tmp_527, &tcl_file.matrix_o_79_V_depth);
		sprintf(tvout_matrix_o_79_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_79_V, tvout_matrix_o_79_V);

		// release memory allocation
		delete [] matrix_o_79_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_79_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_79_V, wrapc_stream_size_out_matrix_o_79_V);
		sprintf(wrapc_stream_size_out_matrix_o_79_V, "%d\n", aesl_tmp_526 - aesl_tmp_527);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_79_V, wrapc_stream_size_out_matrix_o_79_V);
		sprintf(wrapc_stream_size_out_matrix_o_79_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_79_V, wrapc_stream_size_out_matrix_o_79_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_80_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_80_V, tvout_matrix_o_80_V);

		sc_bv<16>* matrix_o_80_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_529 - aesl_tmp_530];

		// RTL Name: matrix_o_80_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_530) => (aesl_tmp_529 - 1) @ (1)
					for (int i_0 = aesl_tmp_530; i_0 <= aesl_tmp_529 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_528[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_528[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_528[i_0]
						if (&(aesl_tmp_528[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_528[i_0];
							matrix_o_80_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_529 - aesl_tmp_530; i++)
		{
			sprintf(tvout_matrix_o_80_V, "%s\n", (matrix_o_80_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_80_V, tvout_matrix_o_80_V);
		}

		tcl_file.set_num(aesl_tmp_529 - aesl_tmp_530, &tcl_file.matrix_o_80_V_depth);
		sprintf(tvout_matrix_o_80_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_80_V, tvout_matrix_o_80_V);

		// release memory allocation
		delete [] matrix_o_80_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_80_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_80_V, wrapc_stream_size_out_matrix_o_80_V);
		sprintf(wrapc_stream_size_out_matrix_o_80_V, "%d\n", aesl_tmp_529 - aesl_tmp_530);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_80_V, wrapc_stream_size_out_matrix_o_80_V);
		sprintf(wrapc_stream_size_out_matrix_o_80_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_80_V, wrapc_stream_size_out_matrix_o_80_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_81_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_81_V, tvout_matrix_o_81_V);

		sc_bv<16>* matrix_o_81_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_532 - aesl_tmp_533];

		// RTL Name: matrix_o_81_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_533) => (aesl_tmp_532 - 1) @ (1)
					for (int i_0 = aesl_tmp_533; i_0 <= aesl_tmp_532 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_531[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_531[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_531[i_0]
						if (&(aesl_tmp_531[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_531[i_0];
							matrix_o_81_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_532 - aesl_tmp_533; i++)
		{
			sprintf(tvout_matrix_o_81_V, "%s\n", (matrix_o_81_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_81_V, tvout_matrix_o_81_V);
		}

		tcl_file.set_num(aesl_tmp_532 - aesl_tmp_533, &tcl_file.matrix_o_81_V_depth);
		sprintf(tvout_matrix_o_81_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_81_V, tvout_matrix_o_81_V);

		// release memory allocation
		delete [] matrix_o_81_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_81_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_81_V, wrapc_stream_size_out_matrix_o_81_V);
		sprintf(wrapc_stream_size_out_matrix_o_81_V, "%d\n", aesl_tmp_532 - aesl_tmp_533);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_81_V, wrapc_stream_size_out_matrix_o_81_V);
		sprintf(wrapc_stream_size_out_matrix_o_81_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_81_V, wrapc_stream_size_out_matrix_o_81_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_82_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_82_V, tvout_matrix_o_82_V);

		sc_bv<16>* matrix_o_82_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_535 - aesl_tmp_536];

		// RTL Name: matrix_o_82_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_536) => (aesl_tmp_535 - 1) @ (1)
					for (int i_0 = aesl_tmp_536; i_0 <= aesl_tmp_535 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_534[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_534[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_534[i_0]
						if (&(aesl_tmp_534[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_534[i_0];
							matrix_o_82_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_535 - aesl_tmp_536; i++)
		{
			sprintf(tvout_matrix_o_82_V, "%s\n", (matrix_o_82_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_82_V, tvout_matrix_o_82_V);
		}

		tcl_file.set_num(aesl_tmp_535 - aesl_tmp_536, &tcl_file.matrix_o_82_V_depth);
		sprintf(tvout_matrix_o_82_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_82_V, tvout_matrix_o_82_V);

		// release memory allocation
		delete [] matrix_o_82_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_82_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_82_V, wrapc_stream_size_out_matrix_o_82_V);
		sprintf(wrapc_stream_size_out_matrix_o_82_V, "%d\n", aesl_tmp_535 - aesl_tmp_536);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_82_V, wrapc_stream_size_out_matrix_o_82_V);
		sprintf(wrapc_stream_size_out_matrix_o_82_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_82_V, wrapc_stream_size_out_matrix_o_82_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_83_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_83_V, tvout_matrix_o_83_V);

		sc_bv<16>* matrix_o_83_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_538 - aesl_tmp_539];

		// RTL Name: matrix_o_83_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_539) => (aesl_tmp_538 - 1) @ (1)
					for (int i_0 = aesl_tmp_539; i_0 <= aesl_tmp_538 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_537[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_537[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_537[i_0]
						if (&(aesl_tmp_537[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_537[i_0];
							matrix_o_83_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_538 - aesl_tmp_539; i++)
		{
			sprintf(tvout_matrix_o_83_V, "%s\n", (matrix_o_83_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_83_V, tvout_matrix_o_83_V);
		}

		tcl_file.set_num(aesl_tmp_538 - aesl_tmp_539, &tcl_file.matrix_o_83_V_depth);
		sprintf(tvout_matrix_o_83_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_83_V, tvout_matrix_o_83_V);

		// release memory allocation
		delete [] matrix_o_83_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_83_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_83_V, wrapc_stream_size_out_matrix_o_83_V);
		sprintf(wrapc_stream_size_out_matrix_o_83_V, "%d\n", aesl_tmp_538 - aesl_tmp_539);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_83_V, wrapc_stream_size_out_matrix_o_83_V);
		sprintf(wrapc_stream_size_out_matrix_o_83_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_83_V, wrapc_stream_size_out_matrix_o_83_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_84_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_84_V, tvout_matrix_o_84_V);

		sc_bv<16>* matrix_o_84_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_541 - aesl_tmp_542];

		// RTL Name: matrix_o_84_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_542) => (aesl_tmp_541 - 1) @ (1)
					for (int i_0 = aesl_tmp_542; i_0 <= aesl_tmp_541 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_540[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_540[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_540[i_0]
						if (&(aesl_tmp_540[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_540[i_0];
							matrix_o_84_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_541 - aesl_tmp_542; i++)
		{
			sprintf(tvout_matrix_o_84_V, "%s\n", (matrix_o_84_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_84_V, tvout_matrix_o_84_V);
		}

		tcl_file.set_num(aesl_tmp_541 - aesl_tmp_542, &tcl_file.matrix_o_84_V_depth);
		sprintf(tvout_matrix_o_84_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_84_V, tvout_matrix_o_84_V);

		// release memory allocation
		delete [] matrix_o_84_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_84_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_84_V, wrapc_stream_size_out_matrix_o_84_V);
		sprintf(wrapc_stream_size_out_matrix_o_84_V, "%d\n", aesl_tmp_541 - aesl_tmp_542);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_84_V, wrapc_stream_size_out_matrix_o_84_V);
		sprintf(wrapc_stream_size_out_matrix_o_84_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_84_V, wrapc_stream_size_out_matrix_o_84_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_85_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_85_V, tvout_matrix_o_85_V);

		sc_bv<16>* matrix_o_85_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_544 - aesl_tmp_545];

		// RTL Name: matrix_o_85_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_545) => (aesl_tmp_544 - 1) @ (1)
					for (int i_0 = aesl_tmp_545; i_0 <= aesl_tmp_544 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_543[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_543[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_543[i_0]
						if (&(aesl_tmp_543[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_543[i_0];
							matrix_o_85_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_544 - aesl_tmp_545; i++)
		{
			sprintf(tvout_matrix_o_85_V, "%s\n", (matrix_o_85_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_85_V, tvout_matrix_o_85_V);
		}

		tcl_file.set_num(aesl_tmp_544 - aesl_tmp_545, &tcl_file.matrix_o_85_V_depth);
		sprintf(tvout_matrix_o_85_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_85_V, tvout_matrix_o_85_V);

		// release memory allocation
		delete [] matrix_o_85_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_85_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_85_V, wrapc_stream_size_out_matrix_o_85_V);
		sprintf(wrapc_stream_size_out_matrix_o_85_V, "%d\n", aesl_tmp_544 - aesl_tmp_545);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_85_V, wrapc_stream_size_out_matrix_o_85_V);
		sprintf(wrapc_stream_size_out_matrix_o_85_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_85_V, wrapc_stream_size_out_matrix_o_85_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_86_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_86_V, tvout_matrix_o_86_V);

		sc_bv<16>* matrix_o_86_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_547 - aesl_tmp_548];

		// RTL Name: matrix_o_86_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_548) => (aesl_tmp_547 - 1) @ (1)
					for (int i_0 = aesl_tmp_548; i_0 <= aesl_tmp_547 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_546[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_546[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_546[i_0]
						if (&(aesl_tmp_546[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_546[i_0];
							matrix_o_86_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_547 - aesl_tmp_548; i++)
		{
			sprintf(tvout_matrix_o_86_V, "%s\n", (matrix_o_86_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_86_V, tvout_matrix_o_86_V);
		}

		tcl_file.set_num(aesl_tmp_547 - aesl_tmp_548, &tcl_file.matrix_o_86_V_depth);
		sprintf(tvout_matrix_o_86_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_86_V, tvout_matrix_o_86_V);

		// release memory allocation
		delete [] matrix_o_86_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_86_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_86_V, wrapc_stream_size_out_matrix_o_86_V);
		sprintf(wrapc_stream_size_out_matrix_o_86_V, "%d\n", aesl_tmp_547 - aesl_tmp_548);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_86_V, wrapc_stream_size_out_matrix_o_86_V);
		sprintf(wrapc_stream_size_out_matrix_o_86_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_86_V, wrapc_stream_size_out_matrix_o_86_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_87_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_87_V, tvout_matrix_o_87_V);

		sc_bv<16>* matrix_o_87_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_550 - aesl_tmp_551];

		// RTL Name: matrix_o_87_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_551) => (aesl_tmp_550 - 1) @ (1)
					for (int i_0 = aesl_tmp_551; i_0 <= aesl_tmp_550 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_549[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_549[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_549[i_0]
						if (&(aesl_tmp_549[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_549[i_0];
							matrix_o_87_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_550 - aesl_tmp_551; i++)
		{
			sprintf(tvout_matrix_o_87_V, "%s\n", (matrix_o_87_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_87_V, tvout_matrix_o_87_V);
		}

		tcl_file.set_num(aesl_tmp_550 - aesl_tmp_551, &tcl_file.matrix_o_87_V_depth);
		sprintf(tvout_matrix_o_87_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_87_V, tvout_matrix_o_87_V);

		// release memory allocation
		delete [] matrix_o_87_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_87_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_87_V, wrapc_stream_size_out_matrix_o_87_V);
		sprintf(wrapc_stream_size_out_matrix_o_87_V, "%d\n", aesl_tmp_550 - aesl_tmp_551);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_87_V, wrapc_stream_size_out_matrix_o_87_V);
		sprintf(wrapc_stream_size_out_matrix_o_87_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_87_V, wrapc_stream_size_out_matrix_o_87_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_88_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_88_V, tvout_matrix_o_88_V);

		sc_bv<16>* matrix_o_88_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_553 - aesl_tmp_554];

		// RTL Name: matrix_o_88_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_554) => (aesl_tmp_553 - 1) @ (1)
					for (int i_0 = aesl_tmp_554; i_0 <= aesl_tmp_553 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_552[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_552[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_552[i_0]
						if (&(aesl_tmp_552[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_552[i_0];
							matrix_o_88_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_553 - aesl_tmp_554; i++)
		{
			sprintf(tvout_matrix_o_88_V, "%s\n", (matrix_o_88_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_88_V, tvout_matrix_o_88_V);
		}

		tcl_file.set_num(aesl_tmp_553 - aesl_tmp_554, &tcl_file.matrix_o_88_V_depth);
		sprintf(tvout_matrix_o_88_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_88_V, tvout_matrix_o_88_V);

		// release memory allocation
		delete [] matrix_o_88_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_88_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_88_V, wrapc_stream_size_out_matrix_o_88_V);
		sprintf(wrapc_stream_size_out_matrix_o_88_V, "%d\n", aesl_tmp_553 - aesl_tmp_554);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_88_V, wrapc_stream_size_out_matrix_o_88_V);
		sprintf(wrapc_stream_size_out_matrix_o_88_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_88_V, wrapc_stream_size_out_matrix_o_88_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_89_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_89_V, tvout_matrix_o_89_V);

		sc_bv<16>* matrix_o_89_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_556 - aesl_tmp_557];

		// RTL Name: matrix_o_89_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_557) => (aesl_tmp_556 - 1) @ (1)
					for (int i_0 = aesl_tmp_557; i_0 <= aesl_tmp_556 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_555[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_555[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_555[i_0]
						if (&(aesl_tmp_555[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_555[i_0];
							matrix_o_89_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_556 - aesl_tmp_557; i++)
		{
			sprintf(tvout_matrix_o_89_V, "%s\n", (matrix_o_89_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_89_V, tvout_matrix_o_89_V);
		}

		tcl_file.set_num(aesl_tmp_556 - aesl_tmp_557, &tcl_file.matrix_o_89_V_depth);
		sprintf(tvout_matrix_o_89_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_89_V, tvout_matrix_o_89_V);

		// release memory allocation
		delete [] matrix_o_89_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_89_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_89_V, wrapc_stream_size_out_matrix_o_89_V);
		sprintf(wrapc_stream_size_out_matrix_o_89_V, "%d\n", aesl_tmp_556 - aesl_tmp_557);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_89_V, wrapc_stream_size_out_matrix_o_89_V);
		sprintf(wrapc_stream_size_out_matrix_o_89_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_89_V, wrapc_stream_size_out_matrix_o_89_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_90_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_90_V, tvout_matrix_o_90_V);

		sc_bv<16>* matrix_o_90_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_559 - aesl_tmp_560];

		// RTL Name: matrix_o_90_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_560) => (aesl_tmp_559 - 1) @ (1)
					for (int i_0 = aesl_tmp_560; i_0 <= aesl_tmp_559 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_558[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_558[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_558[i_0]
						if (&(aesl_tmp_558[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_558[i_0];
							matrix_o_90_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_559 - aesl_tmp_560; i++)
		{
			sprintf(tvout_matrix_o_90_V, "%s\n", (matrix_o_90_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_90_V, tvout_matrix_o_90_V);
		}

		tcl_file.set_num(aesl_tmp_559 - aesl_tmp_560, &tcl_file.matrix_o_90_V_depth);
		sprintf(tvout_matrix_o_90_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_90_V, tvout_matrix_o_90_V);

		// release memory allocation
		delete [] matrix_o_90_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_90_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_90_V, wrapc_stream_size_out_matrix_o_90_V);
		sprintf(wrapc_stream_size_out_matrix_o_90_V, "%d\n", aesl_tmp_559 - aesl_tmp_560);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_90_V, wrapc_stream_size_out_matrix_o_90_V);
		sprintf(wrapc_stream_size_out_matrix_o_90_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_90_V, wrapc_stream_size_out_matrix_o_90_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_91_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_91_V, tvout_matrix_o_91_V);

		sc_bv<16>* matrix_o_91_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_562 - aesl_tmp_563];

		// RTL Name: matrix_o_91_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_563) => (aesl_tmp_562 - 1) @ (1)
					for (int i_0 = aesl_tmp_563; i_0 <= aesl_tmp_562 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_561[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_561[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_561[i_0]
						if (&(aesl_tmp_561[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_561[i_0];
							matrix_o_91_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_562 - aesl_tmp_563; i++)
		{
			sprintf(tvout_matrix_o_91_V, "%s\n", (matrix_o_91_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_91_V, tvout_matrix_o_91_V);
		}

		tcl_file.set_num(aesl_tmp_562 - aesl_tmp_563, &tcl_file.matrix_o_91_V_depth);
		sprintf(tvout_matrix_o_91_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_91_V, tvout_matrix_o_91_V);

		// release memory allocation
		delete [] matrix_o_91_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_91_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_91_V, wrapc_stream_size_out_matrix_o_91_V);
		sprintf(wrapc_stream_size_out_matrix_o_91_V, "%d\n", aesl_tmp_562 - aesl_tmp_563);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_91_V, wrapc_stream_size_out_matrix_o_91_V);
		sprintf(wrapc_stream_size_out_matrix_o_91_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_91_V, wrapc_stream_size_out_matrix_o_91_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_92_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_92_V, tvout_matrix_o_92_V);

		sc_bv<16>* matrix_o_92_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_565 - aesl_tmp_566];

		// RTL Name: matrix_o_92_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_566) => (aesl_tmp_565 - 1) @ (1)
					for (int i_0 = aesl_tmp_566; i_0 <= aesl_tmp_565 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_564[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_564[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_564[i_0]
						if (&(aesl_tmp_564[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_564[i_0];
							matrix_o_92_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_565 - aesl_tmp_566; i++)
		{
			sprintf(tvout_matrix_o_92_V, "%s\n", (matrix_o_92_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_92_V, tvout_matrix_o_92_V);
		}

		tcl_file.set_num(aesl_tmp_565 - aesl_tmp_566, &tcl_file.matrix_o_92_V_depth);
		sprintf(tvout_matrix_o_92_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_92_V, tvout_matrix_o_92_V);

		// release memory allocation
		delete [] matrix_o_92_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_92_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_92_V, wrapc_stream_size_out_matrix_o_92_V);
		sprintf(wrapc_stream_size_out_matrix_o_92_V, "%d\n", aesl_tmp_565 - aesl_tmp_566);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_92_V, wrapc_stream_size_out_matrix_o_92_V);
		sprintf(wrapc_stream_size_out_matrix_o_92_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_92_V, wrapc_stream_size_out_matrix_o_92_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_93_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_93_V, tvout_matrix_o_93_V);

		sc_bv<16>* matrix_o_93_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_568 - aesl_tmp_569];

		// RTL Name: matrix_o_93_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_569) => (aesl_tmp_568 - 1) @ (1)
					for (int i_0 = aesl_tmp_569; i_0 <= aesl_tmp_568 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_567[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_567[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_567[i_0]
						if (&(aesl_tmp_567[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_567[i_0];
							matrix_o_93_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_568 - aesl_tmp_569; i++)
		{
			sprintf(tvout_matrix_o_93_V, "%s\n", (matrix_o_93_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_93_V, tvout_matrix_o_93_V);
		}

		tcl_file.set_num(aesl_tmp_568 - aesl_tmp_569, &tcl_file.matrix_o_93_V_depth);
		sprintf(tvout_matrix_o_93_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_93_V, tvout_matrix_o_93_V);

		// release memory allocation
		delete [] matrix_o_93_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_93_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_93_V, wrapc_stream_size_out_matrix_o_93_V);
		sprintf(wrapc_stream_size_out_matrix_o_93_V, "%d\n", aesl_tmp_568 - aesl_tmp_569);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_93_V, wrapc_stream_size_out_matrix_o_93_V);
		sprintf(wrapc_stream_size_out_matrix_o_93_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_93_V, wrapc_stream_size_out_matrix_o_93_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_94_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_94_V, tvout_matrix_o_94_V);

		sc_bv<16>* matrix_o_94_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_571 - aesl_tmp_572];

		// RTL Name: matrix_o_94_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_572) => (aesl_tmp_571 - 1) @ (1)
					for (int i_0 = aesl_tmp_572; i_0 <= aesl_tmp_571 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_570[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_570[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_570[i_0]
						if (&(aesl_tmp_570[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_570[i_0];
							matrix_o_94_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_571 - aesl_tmp_572; i++)
		{
			sprintf(tvout_matrix_o_94_V, "%s\n", (matrix_o_94_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_94_V, tvout_matrix_o_94_V);
		}

		tcl_file.set_num(aesl_tmp_571 - aesl_tmp_572, &tcl_file.matrix_o_94_V_depth);
		sprintf(tvout_matrix_o_94_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_94_V, tvout_matrix_o_94_V);

		// release memory allocation
		delete [] matrix_o_94_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_94_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_94_V, wrapc_stream_size_out_matrix_o_94_V);
		sprintf(wrapc_stream_size_out_matrix_o_94_V, "%d\n", aesl_tmp_571 - aesl_tmp_572);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_94_V, wrapc_stream_size_out_matrix_o_94_V);
		sprintf(wrapc_stream_size_out_matrix_o_94_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_94_V, wrapc_stream_size_out_matrix_o_94_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_95_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_95_V, tvout_matrix_o_95_V);

		sc_bv<16>* matrix_o_95_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_574 - aesl_tmp_575];

		// RTL Name: matrix_o_95_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_575) => (aesl_tmp_574 - 1) @ (1)
					for (int i_0 = aesl_tmp_575; i_0 <= aesl_tmp_574 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_573[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_573[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_573[i_0]
						if (&(aesl_tmp_573[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_573[i_0];
							matrix_o_95_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_574 - aesl_tmp_575; i++)
		{
			sprintf(tvout_matrix_o_95_V, "%s\n", (matrix_o_95_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_95_V, tvout_matrix_o_95_V);
		}

		tcl_file.set_num(aesl_tmp_574 - aesl_tmp_575, &tcl_file.matrix_o_95_V_depth);
		sprintf(tvout_matrix_o_95_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_95_V, tvout_matrix_o_95_V);

		// release memory allocation
		delete [] matrix_o_95_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_95_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_95_V, wrapc_stream_size_out_matrix_o_95_V);
		sprintf(wrapc_stream_size_out_matrix_o_95_V, "%d\n", aesl_tmp_574 - aesl_tmp_575);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_95_V, wrapc_stream_size_out_matrix_o_95_V);
		sprintf(wrapc_stream_size_out_matrix_o_95_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_95_V, wrapc_stream_size_out_matrix_o_95_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_96_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_96_V, tvout_matrix_o_96_V);

		sc_bv<16>* matrix_o_96_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_577 - aesl_tmp_578];

		// RTL Name: matrix_o_96_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_578) => (aesl_tmp_577 - 1) @ (1)
					for (int i_0 = aesl_tmp_578; i_0 <= aesl_tmp_577 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_576[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_576[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_576[i_0]
						if (&(aesl_tmp_576[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_576[i_0];
							matrix_o_96_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_577 - aesl_tmp_578; i++)
		{
			sprintf(tvout_matrix_o_96_V, "%s\n", (matrix_o_96_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_96_V, tvout_matrix_o_96_V);
		}

		tcl_file.set_num(aesl_tmp_577 - aesl_tmp_578, &tcl_file.matrix_o_96_V_depth);
		sprintf(tvout_matrix_o_96_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_96_V, tvout_matrix_o_96_V);

		// release memory allocation
		delete [] matrix_o_96_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_96_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_96_V, wrapc_stream_size_out_matrix_o_96_V);
		sprintf(wrapc_stream_size_out_matrix_o_96_V, "%d\n", aesl_tmp_577 - aesl_tmp_578);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_96_V, wrapc_stream_size_out_matrix_o_96_V);
		sprintf(wrapc_stream_size_out_matrix_o_96_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_96_V, wrapc_stream_size_out_matrix_o_96_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_97_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_97_V, tvout_matrix_o_97_V);

		sc_bv<16>* matrix_o_97_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_580 - aesl_tmp_581];

		// RTL Name: matrix_o_97_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_581) => (aesl_tmp_580 - 1) @ (1)
					for (int i_0 = aesl_tmp_581; i_0 <= aesl_tmp_580 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_579[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_579[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_579[i_0]
						if (&(aesl_tmp_579[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_579[i_0];
							matrix_o_97_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_580 - aesl_tmp_581; i++)
		{
			sprintf(tvout_matrix_o_97_V, "%s\n", (matrix_o_97_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_97_V, tvout_matrix_o_97_V);
		}

		tcl_file.set_num(aesl_tmp_580 - aesl_tmp_581, &tcl_file.matrix_o_97_V_depth);
		sprintf(tvout_matrix_o_97_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_97_V, tvout_matrix_o_97_V);

		// release memory allocation
		delete [] matrix_o_97_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_97_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_97_V, wrapc_stream_size_out_matrix_o_97_V);
		sprintf(wrapc_stream_size_out_matrix_o_97_V, "%d\n", aesl_tmp_580 - aesl_tmp_581);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_97_V, wrapc_stream_size_out_matrix_o_97_V);
		sprintf(wrapc_stream_size_out_matrix_o_97_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_97_V, wrapc_stream_size_out_matrix_o_97_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_98_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_98_V, tvout_matrix_o_98_V);

		sc_bv<16>* matrix_o_98_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_583 - aesl_tmp_584];

		// RTL Name: matrix_o_98_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_584) => (aesl_tmp_583 - 1) @ (1)
					for (int i_0 = aesl_tmp_584; i_0 <= aesl_tmp_583 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_582[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_582[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_582[i_0]
						if (&(aesl_tmp_582[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_582[i_0];
							matrix_o_98_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_583 - aesl_tmp_584; i++)
		{
			sprintf(tvout_matrix_o_98_V, "%s\n", (matrix_o_98_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_98_V, tvout_matrix_o_98_V);
		}

		tcl_file.set_num(aesl_tmp_583 - aesl_tmp_584, &tcl_file.matrix_o_98_V_depth);
		sprintf(tvout_matrix_o_98_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_98_V, tvout_matrix_o_98_V);

		// release memory allocation
		delete [] matrix_o_98_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_98_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_98_V, wrapc_stream_size_out_matrix_o_98_V);
		sprintf(wrapc_stream_size_out_matrix_o_98_V, "%d\n", aesl_tmp_583 - aesl_tmp_584);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_98_V, wrapc_stream_size_out_matrix_o_98_V);
		sprintf(wrapc_stream_size_out_matrix_o_98_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_98_V, wrapc_stream_size_out_matrix_o_98_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_99_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_99_V, tvout_matrix_o_99_V);

		sc_bv<16>* matrix_o_99_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_586 - aesl_tmp_587];

		// RTL Name: matrix_o_99_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_587) => (aesl_tmp_586 - 1) @ (1)
					for (int i_0 = aesl_tmp_587; i_0 <= aesl_tmp_586 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_585[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_585[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_585[i_0]
						if (&(aesl_tmp_585[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_585[i_0];
							matrix_o_99_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_586 - aesl_tmp_587; i++)
		{
			sprintf(tvout_matrix_o_99_V, "%s\n", (matrix_o_99_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_99_V, tvout_matrix_o_99_V);
		}

		tcl_file.set_num(aesl_tmp_586 - aesl_tmp_587, &tcl_file.matrix_o_99_V_depth);
		sprintf(tvout_matrix_o_99_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_99_V, tvout_matrix_o_99_V);

		// release memory allocation
		delete [] matrix_o_99_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_99_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_99_V, wrapc_stream_size_out_matrix_o_99_V);
		sprintf(wrapc_stream_size_out_matrix_o_99_V, "%d\n", aesl_tmp_586 - aesl_tmp_587);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_99_V, wrapc_stream_size_out_matrix_o_99_V);
		sprintf(wrapc_stream_size_out_matrix_o_99_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_99_V, wrapc_stream_size_out_matrix_o_99_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_100_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_100_V, tvout_matrix_o_100_V);

		sc_bv<16>* matrix_o_100_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_589 - aesl_tmp_590];

		// RTL Name: matrix_o_100_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_590) => (aesl_tmp_589 - 1) @ (1)
					for (int i_0 = aesl_tmp_590; i_0 <= aesl_tmp_589 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_588[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_588[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_588[i_0]
						if (&(aesl_tmp_588[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_588[i_0];
							matrix_o_100_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_589 - aesl_tmp_590; i++)
		{
			sprintf(tvout_matrix_o_100_V, "%s\n", (matrix_o_100_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_100_V, tvout_matrix_o_100_V);
		}

		tcl_file.set_num(aesl_tmp_589 - aesl_tmp_590, &tcl_file.matrix_o_100_V_depth);
		sprintf(tvout_matrix_o_100_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_100_V, tvout_matrix_o_100_V);

		// release memory allocation
		delete [] matrix_o_100_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_100_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_100_V, wrapc_stream_size_out_matrix_o_100_V);
		sprintf(wrapc_stream_size_out_matrix_o_100_V, "%d\n", aesl_tmp_589 - aesl_tmp_590);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_100_V, wrapc_stream_size_out_matrix_o_100_V);
		sprintf(wrapc_stream_size_out_matrix_o_100_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_100_V, wrapc_stream_size_out_matrix_o_100_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_101_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_101_V, tvout_matrix_o_101_V);

		sc_bv<16>* matrix_o_101_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_592 - aesl_tmp_593];

		// RTL Name: matrix_o_101_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_593) => (aesl_tmp_592 - 1) @ (1)
					for (int i_0 = aesl_tmp_593; i_0 <= aesl_tmp_592 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_591[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_591[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_591[i_0]
						if (&(aesl_tmp_591[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_591[i_0];
							matrix_o_101_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_592 - aesl_tmp_593; i++)
		{
			sprintf(tvout_matrix_o_101_V, "%s\n", (matrix_o_101_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_101_V, tvout_matrix_o_101_V);
		}

		tcl_file.set_num(aesl_tmp_592 - aesl_tmp_593, &tcl_file.matrix_o_101_V_depth);
		sprintf(tvout_matrix_o_101_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_101_V, tvout_matrix_o_101_V);

		// release memory allocation
		delete [] matrix_o_101_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_101_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_101_V, wrapc_stream_size_out_matrix_o_101_V);
		sprintf(wrapc_stream_size_out_matrix_o_101_V, "%d\n", aesl_tmp_592 - aesl_tmp_593);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_101_V, wrapc_stream_size_out_matrix_o_101_V);
		sprintf(wrapc_stream_size_out_matrix_o_101_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_101_V, wrapc_stream_size_out_matrix_o_101_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_102_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_102_V, tvout_matrix_o_102_V);

		sc_bv<16>* matrix_o_102_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_595 - aesl_tmp_596];

		// RTL Name: matrix_o_102_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_596) => (aesl_tmp_595 - 1) @ (1)
					for (int i_0 = aesl_tmp_596; i_0 <= aesl_tmp_595 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_594[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_594[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_594[i_0]
						if (&(aesl_tmp_594[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_594[i_0];
							matrix_o_102_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_595 - aesl_tmp_596; i++)
		{
			sprintf(tvout_matrix_o_102_V, "%s\n", (matrix_o_102_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_102_V, tvout_matrix_o_102_V);
		}

		tcl_file.set_num(aesl_tmp_595 - aesl_tmp_596, &tcl_file.matrix_o_102_V_depth);
		sprintf(tvout_matrix_o_102_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_102_V, tvout_matrix_o_102_V);

		// release memory allocation
		delete [] matrix_o_102_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_102_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_102_V, wrapc_stream_size_out_matrix_o_102_V);
		sprintf(wrapc_stream_size_out_matrix_o_102_V, "%d\n", aesl_tmp_595 - aesl_tmp_596);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_102_V, wrapc_stream_size_out_matrix_o_102_V);
		sprintf(wrapc_stream_size_out_matrix_o_102_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_102_V, wrapc_stream_size_out_matrix_o_102_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_103_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_103_V, tvout_matrix_o_103_V);

		sc_bv<16>* matrix_o_103_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_598 - aesl_tmp_599];

		// RTL Name: matrix_o_103_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_599) => (aesl_tmp_598 - 1) @ (1)
					for (int i_0 = aesl_tmp_599; i_0 <= aesl_tmp_598 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_597[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_597[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_597[i_0]
						if (&(aesl_tmp_597[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_597[i_0];
							matrix_o_103_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_598 - aesl_tmp_599; i++)
		{
			sprintf(tvout_matrix_o_103_V, "%s\n", (matrix_o_103_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_103_V, tvout_matrix_o_103_V);
		}

		tcl_file.set_num(aesl_tmp_598 - aesl_tmp_599, &tcl_file.matrix_o_103_V_depth);
		sprintf(tvout_matrix_o_103_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_103_V, tvout_matrix_o_103_V);

		// release memory allocation
		delete [] matrix_o_103_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_103_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_103_V, wrapc_stream_size_out_matrix_o_103_V);
		sprintf(wrapc_stream_size_out_matrix_o_103_V, "%d\n", aesl_tmp_598 - aesl_tmp_599);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_103_V, wrapc_stream_size_out_matrix_o_103_V);
		sprintf(wrapc_stream_size_out_matrix_o_103_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_103_V, wrapc_stream_size_out_matrix_o_103_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_104_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_104_V, tvout_matrix_o_104_V);

		sc_bv<16>* matrix_o_104_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_601 - aesl_tmp_602];

		// RTL Name: matrix_o_104_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_602) => (aesl_tmp_601 - 1) @ (1)
					for (int i_0 = aesl_tmp_602; i_0 <= aesl_tmp_601 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_600[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_600[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_600[i_0]
						if (&(aesl_tmp_600[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_600[i_0];
							matrix_o_104_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_601 - aesl_tmp_602; i++)
		{
			sprintf(tvout_matrix_o_104_V, "%s\n", (matrix_o_104_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_104_V, tvout_matrix_o_104_V);
		}

		tcl_file.set_num(aesl_tmp_601 - aesl_tmp_602, &tcl_file.matrix_o_104_V_depth);
		sprintf(tvout_matrix_o_104_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_104_V, tvout_matrix_o_104_V);

		// release memory allocation
		delete [] matrix_o_104_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_104_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_104_V, wrapc_stream_size_out_matrix_o_104_V);
		sprintf(wrapc_stream_size_out_matrix_o_104_V, "%d\n", aesl_tmp_601 - aesl_tmp_602);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_104_V, wrapc_stream_size_out_matrix_o_104_V);
		sprintf(wrapc_stream_size_out_matrix_o_104_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_104_V, wrapc_stream_size_out_matrix_o_104_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_105_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_105_V, tvout_matrix_o_105_V);

		sc_bv<16>* matrix_o_105_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_604 - aesl_tmp_605];

		// RTL Name: matrix_o_105_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_605) => (aesl_tmp_604 - 1) @ (1)
					for (int i_0 = aesl_tmp_605; i_0 <= aesl_tmp_604 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_603[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_603[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_603[i_0]
						if (&(aesl_tmp_603[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_603[i_0];
							matrix_o_105_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_604 - aesl_tmp_605; i++)
		{
			sprintf(tvout_matrix_o_105_V, "%s\n", (matrix_o_105_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_105_V, tvout_matrix_o_105_V);
		}

		tcl_file.set_num(aesl_tmp_604 - aesl_tmp_605, &tcl_file.matrix_o_105_V_depth);
		sprintf(tvout_matrix_o_105_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_105_V, tvout_matrix_o_105_V);

		// release memory allocation
		delete [] matrix_o_105_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_105_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_105_V, wrapc_stream_size_out_matrix_o_105_V);
		sprintf(wrapc_stream_size_out_matrix_o_105_V, "%d\n", aesl_tmp_604 - aesl_tmp_605);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_105_V, wrapc_stream_size_out_matrix_o_105_V);
		sprintf(wrapc_stream_size_out_matrix_o_105_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_105_V, wrapc_stream_size_out_matrix_o_105_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_106_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_106_V, tvout_matrix_o_106_V);

		sc_bv<16>* matrix_o_106_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_607 - aesl_tmp_608];

		// RTL Name: matrix_o_106_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_608) => (aesl_tmp_607 - 1) @ (1)
					for (int i_0 = aesl_tmp_608; i_0 <= aesl_tmp_607 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_606[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_606[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_606[i_0]
						if (&(aesl_tmp_606[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_606[i_0];
							matrix_o_106_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_607 - aesl_tmp_608; i++)
		{
			sprintf(tvout_matrix_o_106_V, "%s\n", (matrix_o_106_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_106_V, tvout_matrix_o_106_V);
		}

		tcl_file.set_num(aesl_tmp_607 - aesl_tmp_608, &tcl_file.matrix_o_106_V_depth);
		sprintf(tvout_matrix_o_106_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_106_V, tvout_matrix_o_106_V);

		// release memory allocation
		delete [] matrix_o_106_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_106_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_106_V, wrapc_stream_size_out_matrix_o_106_V);
		sprintf(wrapc_stream_size_out_matrix_o_106_V, "%d\n", aesl_tmp_607 - aesl_tmp_608);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_106_V, wrapc_stream_size_out_matrix_o_106_V);
		sprintf(wrapc_stream_size_out_matrix_o_106_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_106_V, wrapc_stream_size_out_matrix_o_106_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_107_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_107_V, tvout_matrix_o_107_V);

		sc_bv<16>* matrix_o_107_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_610 - aesl_tmp_611];

		// RTL Name: matrix_o_107_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_611) => (aesl_tmp_610 - 1) @ (1)
					for (int i_0 = aesl_tmp_611; i_0 <= aesl_tmp_610 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_609[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_609[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_609[i_0]
						if (&(aesl_tmp_609[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_609[i_0];
							matrix_o_107_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_610 - aesl_tmp_611; i++)
		{
			sprintf(tvout_matrix_o_107_V, "%s\n", (matrix_o_107_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_107_V, tvout_matrix_o_107_V);
		}

		tcl_file.set_num(aesl_tmp_610 - aesl_tmp_611, &tcl_file.matrix_o_107_V_depth);
		sprintf(tvout_matrix_o_107_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_107_V, tvout_matrix_o_107_V);

		// release memory allocation
		delete [] matrix_o_107_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_107_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_107_V, wrapc_stream_size_out_matrix_o_107_V);
		sprintf(wrapc_stream_size_out_matrix_o_107_V, "%d\n", aesl_tmp_610 - aesl_tmp_611);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_107_V, wrapc_stream_size_out_matrix_o_107_V);
		sprintf(wrapc_stream_size_out_matrix_o_107_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_107_V, wrapc_stream_size_out_matrix_o_107_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_108_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_108_V, tvout_matrix_o_108_V);

		sc_bv<16>* matrix_o_108_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_613 - aesl_tmp_614];

		// RTL Name: matrix_o_108_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_614) => (aesl_tmp_613 - 1) @ (1)
					for (int i_0 = aesl_tmp_614; i_0 <= aesl_tmp_613 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_612[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_612[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_612[i_0]
						if (&(aesl_tmp_612[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_612[i_0];
							matrix_o_108_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_613 - aesl_tmp_614; i++)
		{
			sprintf(tvout_matrix_o_108_V, "%s\n", (matrix_o_108_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_108_V, tvout_matrix_o_108_V);
		}

		tcl_file.set_num(aesl_tmp_613 - aesl_tmp_614, &tcl_file.matrix_o_108_V_depth);
		sprintf(tvout_matrix_o_108_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_108_V, tvout_matrix_o_108_V);

		// release memory allocation
		delete [] matrix_o_108_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_108_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_108_V, wrapc_stream_size_out_matrix_o_108_V);
		sprintf(wrapc_stream_size_out_matrix_o_108_V, "%d\n", aesl_tmp_613 - aesl_tmp_614);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_108_V, wrapc_stream_size_out_matrix_o_108_V);
		sprintf(wrapc_stream_size_out_matrix_o_108_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_108_V, wrapc_stream_size_out_matrix_o_108_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_109_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_109_V, tvout_matrix_o_109_V);

		sc_bv<16>* matrix_o_109_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_616 - aesl_tmp_617];

		// RTL Name: matrix_o_109_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_617) => (aesl_tmp_616 - 1) @ (1)
					for (int i_0 = aesl_tmp_617; i_0 <= aesl_tmp_616 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_615[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_615[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_615[i_0]
						if (&(aesl_tmp_615[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_615[i_0];
							matrix_o_109_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_616 - aesl_tmp_617; i++)
		{
			sprintf(tvout_matrix_o_109_V, "%s\n", (matrix_o_109_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_109_V, tvout_matrix_o_109_V);
		}

		tcl_file.set_num(aesl_tmp_616 - aesl_tmp_617, &tcl_file.matrix_o_109_V_depth);
		sprintf(tvout_matrix_o_109_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_109_V, tvout_matrix_o_109_V);

		// release memory allocation
		delete [] matrix_o_109_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_109_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_109_V, wrapc_stream_size_out_matrix_o_109_V);
		sprintf(wrapc_stream_size_out_matrix_o_109_V, "%d\n", aesl_tmp_616 - aesl_tmp_617);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_109_V, wrapc_stream_size_out_matrix_o_109_V);
		sprintf(wrapc_stream_size_out_matrix_o_109_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_109_V, wrapc_stream_size_out_matrix_o_109_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_110_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_110_V, tvout_matrix_o_110_V);

		sc_bv<16>* matrix_o_110_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_619 - aesl_tmp_620];

		// RTL Name: matrix_o_110_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_620) => (aesl_tmp_619 - 1) @ (1)
					for (int i_0 = aesl_tmp_620; i_0 <= aesl_tmp_619 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_618[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_618[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_618[i_0]
						if (&(aesl_tmp_618[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_618[i_0];
							matrix_o_110_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_619 - aesl_tmp_620; i++)
		{
			sprintf(tvout_matrix_o_110_V, "%s\n", (matrix_o_110_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_110_V, tvout_matrix_o_110_V);
		}

		tcl_file.set_num(aesl_tmp_619 - aesl_tmp_620, &tcl_file.matrix_o_110_V_depth);
		sprintf(tvout_matrix_o_110_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_110_V, tvout_matrix_o_110_V);

		// release memory allocation
		delete [] matrix_o_110_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_110_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_110_V, wrapc_stream_size_out_matrix_o_110_V);
		sprintf(wrapc_stream_size_out_matrix_o_110_V, "%d\n", aesl_tmp_619 - aesl_tmp_620);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_110_V, wrapc_stream_size_out_matrix_o_110_V);
		sprintf(wrapc_stream_size_out_matrix_o_110_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_110_V, wrapc_stream_size_out_matrix_o_110_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_111_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_111_V, tvout_matrix_o_111_V);

		sc_bv<16>* matrix_o_111_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_622 - aesl_tmp_623];

		// RTL Name: matrix_o_111_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_623) => (aesl_tmp_622 - 1) @ (1)
					for (int i_0 = aesl_tmp_623; i_0 <= aesl_tmp_622 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_621[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_621[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_621[i_0]
						if (&(aesl_tmp_621[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_621[i_0];
							matrix_o_111_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_622 - aesl_tmp_623; i++)
		{
			sprintf(tvout_matrix_o_111_V, "%s\n", (matrix_o_111_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_111_V, tvout_matrix_o_111_V);
		}

		tcl_file.set_num(aesl_tmp_622 - aesl_tmp_623, &tcl_file.matrix_o_111_V_depth);
		sprintf(tvout_matrix_o_111_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_111_V, tvout_matrix_o_111_V);

		// release memory allocation
		delete [] matrix_o_111_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_111_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_111_V, wrapc_stream_size_out_matrix_o_111_V);
		sprintf(wrapc_stream_size_out_matrix_o_111_V, "%d\n", aesl_tmp_622 - aesl_tmp_623);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_111_V, wrapc_stream_size_out_matrix_o_111_V);
		sprintf(wrapc_stream_size_out_matrix_o_111_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_111_V, wrapc_stream_size_out_matrix_o_111_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_112_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_112_V, tvout_matrix_o_112_V);

		sc_bv<16>* matrix_o_112_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_625 - aesl_tmp_626];

		// RTL Name: matrix_o_112_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_626) => (aesl_tmp_625 - 1) @ (1)
					for (int i_0 = aesl_tmp_626; i_0 <= aesl_tmp_625 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_624[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_624[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_624[i_0]
						if (&(aesl_tmp_624[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_624[i_0];
							matrix_o_112_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_625 - aesl_tmp_626; i++)
		{
			sprintf(tvout_matrix_o_112_V, "%s\n", (matrix_o_112_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_112_V, tvout_matrix_o_112_V);
		}

		tcl_file.set_num(aesl_tmp_625 - aesl_tmp_626, &tcl_file.matrix_o_112_V_depth);
		sprintf(tvout_matrix_o_112_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_112_V, tvout_matrix_o_112_V);

		// release memory allocation
		delete [] matrix_o_112_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_112_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_112_V, wrapc_stream_size_out_matrix_o_112_V);
		sprintf(wrapc_stream_size_out_matrix_o_112_V, "%d\n", aesl_tmp_625 - aesl_tmp_626);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_112_V, wrapc_stream_size_out_matrix_o_112_V);
		sprintf(wrapc_stream_size_out_matrix_o_112_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_112_V, wrapc_stream_size_out_matrix_o_112_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_113_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_113_V, tvout_matrix_o_113_V);

		sc_bv<16>* matrix_o_113_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_628 - aesl_tmp_629];

		// RTL Name: matrix_o_113_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_629) => (aesl_tmp_628 - 1) @ (1)
					for (int i_0 = aesl_tmp_629; i_0 <= aesl_tmp_628 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_627[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_627[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_627[i_0]
						if (&(aesl_tmp_627[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_627[i_0];
							matrix_o_113_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_628 - aesl_tmp_629; i++)
		{
			sprintf(tvout_matrix_o_113_V, "%s\n", (matrix_o_113_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_113_V, tvout_matrix_o_113_V);
		}

		tcl_file.set_num(aesl_tmp_628 - aesl_tmp_629, &tcl_file.matrix_o_113_V_depth);
		sprintf(tvout_matrix_o_113_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_113_V, tvout_matrix_o_113_V);

		// release memory allocation
		delete [] matrix_o_113_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_113_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_113_V, wrapc_stream_size_out_matrix_o_113_V);
		sprintf(wrapc_stream_size_out_matrix_o_113_V, "%d\n", aesl_tmp_628 - aesl_tmp_629);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_113_V, wrapc_stream_size_out_matrix_o_113_V);
		sprintf(wrapc_stream_size_out_matrix_o_113_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_113_V, wrapc_stream_size_out_matrix_o_113_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_114_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_114_V, tvout_matrix_o_114_V);

		sc_bv<16>* matrix_o_114_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_631 - aesl_tmp_632];

		// RTL Name: matrix_o_114_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_632) => (aesl_tmp_631 - 1) @ (1)
					for (int i_0 = aesl_tmp_632; i_0 <= aesl_tmp_631 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_630[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_630[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_630[i_0]
						if (&(aesl_tmp_630[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_630[i_0];
							matrix_o_114_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_631 - aesl_tmp_632; i++)
		{
			sprintf(tvout_matrix_o_114_V, "%s\n", (matrix_o_114_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_114_V, tvout_matrix_o_114_V);
		}

		tcl_file.set_num(aesl_tmp_631 - aesl_tmp_632, &tcl_file.matrix_o_114_V_depth);
		sprintf(tvout_matrix_o_114_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_114_V, tvout_matrix_o_114_V);

		// release memory allocation
		delete [] matrix_o_114_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_114_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_114_V, wrapc_stream_size_out_matrix_o_114_V);
		sprintf(wrapc_stream_size_out_matrix_o_114_V, "%d\n", aesl_tmp_631 - aesl_tmp_632);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_114_V, wrapc_stream_size_out_matrix_o_114_V);
		sprintf(wrapc_stream_size_out_matrix_o_114_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_114_V, wrapc_stream_size_out_matrix_o_114_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_115_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_115_V, tvout_matrix_o_115_V);

		sc_bv<16>* matrix_o_115_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_634 - aesl_tmp_635];

		// RTL Name: matrix_o_115_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_635) => (aesl_tmp_634 - 1) @ (1)
					for (int i_0 = aesl_tmp_635; i_0 <= aesl_tmp_634 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_633[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_633[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_633[i_0]
						if (&(aesl_tmp_633[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_633[i_0];
							matrix_o_115_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_634 - aesl_tmp_635; i++)
		{
			sprintf(tvout_matrix_o_115_V, "%s\n", (matrix_o_115_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_115_V, tvout_matrix_o_115_V);
		}

		tcl_file.set_num(aesl_tmp_634 - aesl_tmp_635, &tcl_file.matrix_o_115_V_depth);
		sprintf(tvout_matrix_o_115_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_115_V, tvout_matrix_o_115_V);

		// release memory allocation
		delete [] matrix_o_115_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_115_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_115_V, wrapc_stream_size_out_matrix_o_115_V);
		sprintf(wrapc_stream_size_out_matrix_o_115_V, "%d\n", aesl_tmp_634 - aesl_tmp_635);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_115_V, wrapc_stream_size_out_matrix_o_115_V);
		sprintf(wrapc_stream_size_out_matrix_o_115_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_115_V, wrapc_stream_size_out_matrix_o_115_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_116_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_116_V, tvout_matrix_o_116_V);

		sc_bv<16>* matrix_o_116_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_637 - aesl_tmp_638];

		// RTL Name: matrix_o_116_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_638) => (aesl_tmp_637 - 1) @ (1)
					for (int i_0 = aesl_tmp_638; i_0 <= aesl_tmp_637 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_636[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_636[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_636[i_0]
						if (&(aesl_tmp_636[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_636[i_0];
							matrix_o_116_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_637 - aesl_tmp_638; i++)
		{
			sprintf(tvout_matrix_o_116_V, "%s\n", (matrix_o_116_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_116_V, tvout_matrix_o_116_V);
		}

		tcl_file.set_num(aesl_tmp_637 - aesl_tmp_638, &tcl_file.matrix_o_116_V_depth);
		sprintf(tvout_matrix_o_116_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_116_V, tvout_matrix_o_116_V);

		// release memory allocation
		delete [] matrix_o_116_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_116_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_116_V, wrapc_stream_size_out_matrix_o_116_V);
		sprintf(wrapc_stream_size_out_matrix_o_116_V, "%d\n", aesl_tmp_637 - aesl_tmp_638);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_116_V, wrapc_stream_size_out_matrix_o_116_V);
		sprintf(wrapc_stream_size_out_matrix_o_116_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_116_V, wrapc_stream_size_out_matrix_o_116_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_117_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_117_V, tvout_matrix_o_117_V);

		sc_bv<16>* matrix_o_117_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_640 - aesl_tmp_641];

		// RTL Name: matrix_o_117_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_641) => (aesl_tmp_640 - 1) @ (1)
					for (int i_0 = aesl_tmp_641; i_0 <= aesl_tmp_640 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_639[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_639[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_639[i_0]
						if (&(aesl_tmp_639[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_639[i_0];
							matrix_o_117_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_640 - aesl_tmp_641; i++)
		{
			sprintf(tvout_matrix_o_117_V, "%s\n", (matrix_o_117_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_117_V, tvout_matrix_o_117_V);
		}

		tcl_file.set_num(aesl_tmp_640 - aesl_tmp_641, &tcl_file.matrix_o_117_V_depth);
		sprintf(tvout_matrix_o_117_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_117_V, tvout_matrix_o_117_V);

		// release memory allocation
		delete [] matrix_o_117_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_117_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_117_V, wrapc_stream_size_out_matrix_o_117_V);
		sprintf(wrapc_stream_size_out_matrix_o_117_V, "%d\n", aesl_tmp_640 - aesl_tmp_641);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_117_V, wrapc_stream_size_out_matrix_o_117_V);
		sprintf(wrapc_stream_size_out_matrix_o_117_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_117_V, wrapc_stream_size_out_matrix_o_117_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_118_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_118_V, tvout_matrix_o_118_V);

		sc_bv<16>* matrix_o_118_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_643 - aesl_tmp_644];

		// RTL Name: matrix_o_118_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_644) => (aesl_tmp_643 - 1) @ (1)
					for (int i_0 = aesl_tmp_644; i_0 <= aesl_tmp_643 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_642[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_642[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_642[i_0]
						if (&(aesl_tmp_642[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_642[i_0];
							matrix_o_118_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_643 - aesl_tmp_644; i++)
		{
			sprintf(tvout_matrix_o_118_V, "%s\n", (matrix_o_118_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_118_V, tvout_matrix_o_118_V);
		}

		tcl_file.set_num(aesl_tmp_643 - aesl_tmp_644, &tcl_file.matrix_o_118_V_depth);
		sprintf(tvout_matrix_o_118_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_118_V, tvout_matrix_o_118_V);

		// release memory allocation
		delete [] matrix_o_118_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_118_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_118_V, wrapc_stream_size_out_matrix_o_118_V);
		sprintf(wrapc_stream_size_out_matrix_o_118_V, "%d\n", aesl_tmp_643 - aesl_tmp_644);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_118_V, wrapc_stream_size_out_matrix_o_118_V);
		sprintf(wrapc_stream_size_out_matrix_o_118_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_118_V, wrapc_stream_size_out_matrix_o_118_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_119_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_119_V, tvout_matrix_o_119_V);

		sc_bv<16>* matrix_o_119_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_646 - aesl_tmp_647];

		// RTL Name: matrix_o_119_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_647) => (aesl_tmp_646 - 1) @ (1)
					for (int i_0 = aesl_tmp_647; i_0 <= aesl_tmp_646 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_645[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_645[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_645[i_0]
						if (&(aesl_tmp_645[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_645[i_0];
							matrix_o_119_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_646 - aesl_tmp_647; i++)
		{
			sprintf(tvout_matrix_o_119_V, "%s\n", (matrix_o_119_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_119_V, tvout_matrix_o_119_V);
		}

		tcl_file.set_num(aesl_tmp_646 - aesl_tmp_647, &tcl_file.matrix_o_119_V_depth);
		sprintf(tvout_matrix_o_119_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_119_V, tvout_matrix_o_119_V);

		// release memory allocation
		delete [] matrix_o_119_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_119_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_119_V, wrapc_stream_size_out_matrix_o_119_V);
		sprintf(wrapc_stream_size_out_matrix_o_119_V, "%d\n", aesl_tmp_646 - aesl_tmp_647);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_119_V, wrapc_stream_size_out_matrix_o_119_V);
		sprintf(wrapc_stream_size_out_matrix_o_119_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_119_V, wrapc_stream_size_out_matrix_o_119_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_120_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_120_V, tvout_matrix_o_120_V);

		sc_bv<16>* matrix_o_120_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_649 - aesl_tmp_650];

		// RTL Name: matrix_o_120_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_650) => (aesl_tmp_649 - 1) @ (1)
					for (int i_0 = aesl_tmp_650; i_0 <= aesl_tmp_649 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_648[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_648[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_648[i_0]
						if (&(aesl_tmp_648[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_648[i_0];
							matrix_o_120_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_649 - aesl_tmp_650; i++)
		{
			sprintf(tvout_matrix_o_120_V, "%s\n", (matrix_o_120_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_120_V, tvout_matrix_o_120_V);
		}

		tcl_file.set_num(aesl_tmp_649 - aesl_tmp_650, &tcl_file.matrix_o_120_V_depth);
		sprintf(tvout_matrix_o_120_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_120_V, tvout_matrix_o_120_V);

		// release memory allocation
		delete [] matrix_o_120_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_120_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_120_V, wrapc_stream_size_out_matrix_o_120_V);
		sprintf(wrapc_stream_size_out_matrix_o_120_V, "%d\n", aesl_tmp_649 - aesl_tmp_650);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_120_V, wrapc_stream_size_out_matrix_o_120_V);
		sprintf(wrapc_stream_size_out_matrix_o_120_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_120_V, wrapc_stream_size_out_matrix_o_120_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_121_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_121_V, tvout_matrix_o_121_V);

		sc_bv<16>* matrix_o_121_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_652 - aesl_tmp_653];

		// RTL Name: matrix_o_121_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_653) => (aesl_tmp_652 - 1) @ (1)
					for (int i_0 = aesl_tmp_653; i_0 <= aesl_tmp_652 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_651[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_651[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_651[i_0]
						if (&(aesl_tmp_651[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_651[i_0];
							matrix_o_121_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_652 - aesl_tmp_653; i++)
		{
			sprintf(tvout_matrix_o_121_V, "%s\n", (matrix_o_121_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_121_V, tvout_matrix_o_121_V);
		}

		tcl_file.set_num(aesl_tmp_652 - aesl_tmp_653, &tcl_file.matrix_o_121_V_depth);
		sprintf(tvout_matrix_o_121_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_121_V, tvout_matrix_o_121_V);

		// release memory allocation
		delete [] matrix_o_121_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_121_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_121_V, wrapc_stream_size_out_matrix_o_121_V);
		sprintf(wrapc_stream_size_out_matrix_o_121_V, "%d\n", aesl_tmp_652 - aesl_tmp_653);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_121_V, wrapc_stream_size_out_matrix_o_121_V);
		sprintf(wrapc_stream_size_out_matrix_o_121_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_121_V, wrapc_stream_size_out_matrix_o_121_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_122_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_122_V, tvout_matrix_o_122_V);

		sc_bv<16>* matrix_o_122_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_655 - aesl_tmp_656];

		// RTL Name: matrix_o_122_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_656) => (aesl_tmp_655 - 1) @ (1)
					for (int i_0 = aesl_tmp_656; i_0 <= aesl_tmp_655 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_654[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_654[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_654[i_0]
						if (&(aesl_tmp_654[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_654[i_0];
							matrix_o_122_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_655 - aesl_tmp_656; i++)
		{
			sprintf(tvout_matrix_o_122_V, "%s\n", (matrix_o_122_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_122_V, tvout_matrix_o_122_V);
		}

		tcl_file.set_num(aesl_tmp_655 - aesl_tmp_656, &tcl_file.matrix_o_122_V_depth);
		sprintf(tvout_matrix_o_122_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_122_V, tvout_matrix_o_122_V);

		// release memory allocation
		delete [] matrix_o_122_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_122_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_122_V, wrapc_stream_size_out_matrix_o_122_V);
		sprintf(wrapc_stream_size_out_matrix_o_122_V, "%d\n", aesl_tmp_655 - aesl_tmp_656);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_122_V, wrapc_stream_size_out_matrix_o_122_V);
		sprintf(wrapc_stream_size_out_matrix_o_122_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_122_V, wrapc_stream_size_out_matrix_o_122_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_123_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_123_V, tvout_matrix_o_123_V);

		sc_bv<16>* matrix_o_123_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_658 - aesl_tmp_659];

		// RTL Name: matrix_o_123_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_659) => (aesl_tmp_658 - 1) @ (1)
					for (int i_0 = aesl_tmp_659; i_0 <= aesl_tmp_658 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_657[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_657[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_657[i_0]
						if (&(aesl_tmp_657[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_657[i_0];
							matrix_o_123_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_658 - aesl_tmp_659; i++)
		{
			sprintf(tvout_matrix_o_123_V, "%s\n", (matrix_o_123_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_123_V, tvout_matrix_o_123_V);
		}

		tcl_file.set_num(aesl_tmp_658 - aesl_tmp_659, &tcl_file.matrix_o_123_V_depth);
		sprintf(tvout_matrix_o_123_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_123_V, tvout_matrix_o_123_V);

		// release memory allocation
		delete [] matrix_o_123_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_123_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_123_V, wrapc_stream_size_out_matrix_o_123_V);
		sprintf(wrapc_stream_size_out_matrix_o_123_V, "%d\n", aesl_tmp_658 - aesl_tmp_659);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_123_V, wrapc_stream_size_out_matrix_o_123_V);
		sprintf(wrapc_stream_size_out_matrix_o_123_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_123_V, wrapc_stream_size_out_matrix_o_123_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_124_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_124_V, tvout_matrix_o_124_V);

		sc_bv<16>* matrix_o_124_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_661 - aesl_tmp_662];

		// RTL Name: matrix_o_124_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_662) => (aesl_tmp_661 - 1) @ (1)
					for (int i_0 = aesl_tmp_662; i_0 <= aesl_tmp_661 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_660[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_660[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_660[i_0]
						if (&(aesl_tmp_660[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_660[i_0];
							matrix_o_124_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_661 - aesl_tmp_662; i++)
		{
			sprintf(tvout_matrix_o_124_V, "%s\n", (matrix_o_124_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_124_V, tvout_matrix_o_124_V);
		}

		tcl_file.set_num(aesl_tmp_661 - aesl_tmp_662, &tcl_file.matrix_o_124_V_depth);
		sprintf(tvout_matrix_o_124_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_124_V, tvout_matrix_o_124_V);

		// release memory allocation
		delete [] matrix_o_124_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_124_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_124_V, wrapc_stream_size_out_matrix_o_124_V);
		sprintf(wrapc_stream_size_out_matrix_o_124_V, "%d\n", aesl_tmp_661 - aesl_tmp_662);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_124_V, wrapc_stream_size_out_matrix_o_124_V);
		sprintf(wrapc_stream_size_out_matrix_o_124_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_124_V, wrapc_stream_size_out_matrix_o_124_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_125_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_125_V, tvout_matrix_o_125_V);

		sc_bv<16>* matrix_o_125_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_664 - aesl_tmp_665];

		// RTL Name: matrix_o_125_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_665) => (aesl_tmp_664 - 1) @ (1)
					for (int i_0 = aesl_tmp_665; i_0 <= aesl_tmp_664 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_663[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_663[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_663[i_0]
						if (&(aesl_tmp_663[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_663[i_0];
							matrix_o_125_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_664 - aesl_tmp_665; i++)
		{
			sprintf(tvout_matrix_o_125_V, "%s\n", (matrix_o_125_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_125_V, tvout_matrix_o_125_V);
		}

		tcl_file.set_num(aesl_tmp_664 - aesl_tmp_665, &tcl_file.matrix_o_125_V_depth);
		sprintf(tvout_matrix_o_125_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_125_V, tvout_matrix_o_125_V);

		// release memory allocation
		delete [] matrix_o_125_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_125_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_125_V, wrapc_stream_size_out_matrix_o_125_V);
		sprintf(wrapc_stream_size_out_matrix_o_125_V, "%d\n", aesl_tmp_664 - aesl_tmp_665);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_125_V, wrapc_stream_size_out_matrix_o_125_V);
		sprintf(wrapc_stream_size_out_matrix_o_125_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_125_V, wrapc_stream_size_out_matrix_o_125_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_126_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_126_V, tvout_matrix_o_126_V);

		sc_bv<16>* matrix_o_126_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_667 - aesl_tmp_668];

		// RTL Name: matrix_o_126_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_668) => (aesl_tmp_667 - 1) @ (1)
					for (int i_0 = aesl_tmp_668; i_0 <= aesl_tmp_667 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_666[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_666[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_666[i_0]
						if (&(aesl_tmp_666[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_666[i_0];
							matrix_o_126_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_667 - aesl_tmp_668; i++)
		{
			sprintf(tvout_matrix_o_126_V, "%s\n", (matrix_o_126_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_126_V, tvout_matrix_o_126_V);
		}

		tcl_file.set_num(aesl_tmp_667 - aesl_tmp_668, &tcl_file.matrix_o_126_V_depth);
		sprintf(tvout_matrix_o_126_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_126_V, tvout_matrix_o_126_V);

		// release memory allocation
		delete [] matrix_o_126_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_126_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_126_V, wrapc_stream_size_out_matrix_o_126_V);
		sprintf(wrapc_stream_size_out_matrix_o_126_V, "%d\n", aesl_tmp_667 - aesl_tmp_668);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_126_V, wrapc_stream_size_out_matrix_o_126_V);
		sprintf(wrapc_stream_size_out_matrix_o_126_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_126_V, wrapc_stream_size_out_matrix_o_126_V);

		// [[transaction]]
		sprintf(tvout_matrix_o_127_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_127_V, tvout_matrix_o_127_V);

		sc_bv<16>* matrix_o_127_V_tvout_wrapc_buffer = new sc_bv<16>[aesl_tmp_670 - aesl_tmp_671];

		// RTL Name: matrix_o_127_V
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: matrix_o.V(15, 0)
				{
					// carray: (aesl_tmp_671) => (aesl_tmp_670 - 1) @ (1)
					for (int i_0 = aesl_tmp_671; i_0 <= aesl_tmp_670 - 1; i_0 += 1)
					{
						// sub                   : i_0
						// ori_name              : aesl_tmp_669[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : aesl_tmp_669[0]
						// regulate_c_name       : matrix_o_V
						// input_type_conversion : aesl_tmp_669[i_0]
						if (&(aesl_tmp_669[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> matrix_o_V_tmp_mem;
							matrix_o_V_tmp_mem = aesl_tmp_669[i_0];
							matrix_o_127_V_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = matrix_o_V_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < aesl_tmp_670 - aesl_tmp_671; i++)
		{
			sprintf(tvout_matrix_o_127_V, "%s\n", (matrix_o_127_V_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_matrix_o_127_V, tvout_matrix_o_127_V);
		}

		tcl_file.set_num(aesl_tmp_670 - aesl_tmp_671, &tcl_file.matrix_o_127_V_depth);
		sprintf(tvout_matrix_o_127_V, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_matrix_o_127_V, tvout_matrix_o_127_V);

		// release memory allocation
		delete [] matrix_o_127_V_tvout_wrapc_buffer;

		// dump stream size
		sprintf(wrapc_stream_size_out_matrix_o_127_V, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_127_V, wrapc_stream_size_out_matrix_o_127_V);
		sprintf(wrapc_stream_size_out_matrix_o_127_V, "%d\n", aesl_tmp_670 - aesl_tmp_671);
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_127_V, wrapc_stream_size_out_matrix_o_127_V);
		sprintf(wrapc_stream_size_out_matrix_o_127_V, "[[/transaction]] \n");
		aesl_fh.write(WRAPC_STREAM_SIZE_OUT_matrix_o_127_V, wrapc_stream_size_out_matrix_o_127_V);

		// push back output stream: "matrix_o[0]"
		for (int i = 0; i < aesl_tmp_289; i++)
		{
			matrix_o[0].write(aesl_tmp_288[i]);
		}

		// push back output stream: "matrix_o[1]"
		for (int i = 0; i < aesl_tmp_292; i++)
		{
			matrix_o[1].write(aesl_tmp_291[i]);
		}

		// push back output stream: "matrix_o[2]"
		for (int i = 0; i < aesl_tmp_295; i++)
		{
			matrix_o[2].write(aesl_tmp_294[i]);
		}

		// push back output stream: "matrix_o[3]"
		for (int i = 0; i < aesl_tmp_298; i++)
		{
			matrix_o[3].write(aesl_tmp_297[i]);
		}

		// push back output stream: "matrix_o[4]"
		for (int i = 0; i < aesl_tmp_301; i++)
		{
			matrix_o[4].write(aesl_tmp_300[i]);
		}

		// push back output stream: "matrix_o[5]"
		for (int i = 0; i < aesl_tmp_304; i++)
		{
			matrix_o[5].write(aesl_tmp_303[i]);
		}

		// push back output stream: "matrix_o[6]"
		for (int i = 0; i < aesl_tmp_307; i++)
		{
			matrix_o[6].write(aesl_tmp_306[i]);
		}

		// push back output stream: "matrix_o[7]"
		for (int i = 0; i < aesl_tmp_310; i++)
		{
			matrix_o[7].write(aesl_tmp_309[i]);
		}

		// push back output stream: "matrix_o[8]"
		for (int i = 0; i < aesl_tmp_313; i++)
		{
			matrix_o[8].write(aesl_tmp_312[i]);
		}

		// push back output stream: "matrix_o[9]"
		for (int i = 0; i < aesl_tmp_316; i++)
		{
			matrix_o[9].write(aesl_tmp_315[i]);
		}

		// push back output stream: "matrix_o[10]"
		for (int i = 0; i < aesl_tmp_319; i++)
		{
			matrix_o[10].write(aesl_tmp_318[i]);
		}

		// push back output stream: "matrix_o[11]"
		for (int i = 0; i < aesl_tmp_322; i++)
		{
			matrix_o[11].write(aesl_tmp_321[i]);
		}

		// push back output stream: "matrix_o[12]"
		for (int i = 0; i < aesl_tmp_325; i++)
		{
			matrix_o[12].write(aesl_tmp_324[i]);
		}

		// push back output stream: "matrix_o[13]"
		for (int i = 0; i < aesl_tmp_328; i++)
		{
			matrix_o[13].write(aesl_tmp_327[i]);
		}

		// push back output stream: "matrix_o[14]"
		for (int i = 0; i < aesl_tmp_331; i++)
		{
			matrix_o[14].write(aesl_tmp_330[i]);
		}

		// push back output stream: "matrix_o[15]"
		for (int i = 0; i < aesl_tmp_334; i++)
		{
			matrix_o[15].write(aesl_tmp_333[i]);
		}

		// push back output stream: "matrix_o[16]"
		for (int i = 0; i < aesl_tmp_337; i++)
		{
			matrix_o[16].write(aesl_tmp_336[i]);
		}

		// push back output stream: "matrix_o[17]"
		for (int i = 0; i < aesl_tmp_340; i++)
		{
			matrix_o[17].write(aesl_tmp_339[i]);
		}

		// push back output stream: "matrix_o[18]"
		for (int i = 0; i < aesl_tmp_343; i++)
		{
			matrix_o[18].write(aesl_tmp_342[i]);
		}

		// push back output stream: "matrix_o[19]"
		for (int i = 0; i < aesl_tmp_346; i++)
		{
			matrix_o[19].write(aesl_tmp_345[i]);
		}

		// push back output stream: "matrix_o[20]"
		for (int i = 0; i < aesl_tmp_349; i++)
		{
			matrix_o[20].write(aesl_tmp_348[i]);
		}

		// push back output stream: "matrix_o[21]"
		for (int i = 0; i < aesl_tmp_352; i++)
		{
			matrix_o[21].write(aesl_tmp_351[i]);
		}

		// push back output stream: "matrix_o[22]"
		for (int i = 0; i < aesl_tmp_355; i++)
		{
			matrix_o[22].write(aesl_tmp_354[i]);
		}

		// push back output stream: "matrix_o[23]"
		for (int i = 0; i < aesl_tmp_358; i++)
		{
			matrix_o[23].write(aesl_tmp_357[i]);
		}

		// push back output stream: "matrix_o[24]"
		for (int i = 0; i < aesl_tmp_361; i++)
		{
			matrix_o[24].write(aesl_tmp_360[i]);
		}

		// push back output stream: "matrix_o[25]"
		for (int i = 0; i < aesl_tmp_364; i++)
		{
			matrix_o[25].write(aesl_tmp_363[i]);
		}

		// push back output stream: "matrix_o[26]"
		for (int i = 0; i < aesl_tmp_367; i++)
		{
			matrix_o[26].write(aesl_tmp_366[i]);
		}

		// push back output stream: "matrix_o[27]"
		for (int i = 0; i < aesl_tmp_370; i++)
		{
			matrix_o[27].write(aesl_tmp_369[i]);
		}

		// push back output stream: "matrix_o[28]"
		for (int i = 0; i < aesl_tmp_373; i++)
		{
			matrix_o[28].write(aesl_tmp_372[i]);
		}

		// push back output stream: "matrix_o[29]"
		for (int i = 0; i < aesl_tmp_376; i++)
		{
			matrix_o[29].write(aesl_tmp_375[i]);
		}

		// push back output stream: "matrix_o[30]"
		for (int i = 0; i < aesl_tmp_379; i++)
		{
			matrix_o[30].write(aesl_tmp_378[i]);
		}

		// push back output stream: "matrix_o[31]"
		for (int i = 0; i < aesl_tmp_382; i++)
		{
			matrix_o[31].write(aesl_tmp_381[i]);
		}

		// push back output stream: "matrix_o[32]"
		for (int i = 0; i < aesl_tmp_385; i++)
		{
			matrix_o[32].write(aesl_tmp_384[i]);
		}

		// push back output stream: "matrix_o[33]"
		for (int i = 0; i < aesl_tmp_388; i++)
		{
			matrix_o[33].write(aesl_tmp_387[i]);
		}

		// push back output stream: "matrix_o[34]"
		for (int i = 0; i < aesl_tmp_391; i++)
		{
			matrix_o[34].write(aesl_tmp_390[i]);
		}

		// push back output stream: "matrix_o[35]"
		for (int i = 0; i < aesl_tmp_394; i++)
		{
			matrix_o[35].write(aesl_tmp_393[i]);
		}

		// push back output stream: "matrix_o[36]"
		for (int i = 0; i < aesl_tmp_397; i++)
		{
			matrix_o[36].write(aesl_tmp_396[i]);
		}

		// push back output stream: "matrix_o[37]"
		for (int i = 0; i < aesl_tmp_400; i++)
		{
			matrix_o[37].write(aesl_tmp_399[i]);
		}

		// push back output stream: "matrix_o[38]"
		for (int i = 0; i < aesl_tmp_403; i++)
		{
			matrix_o[38].write(aesl_tmp_402[i]);
		}

		// push back output stream: "matrix_o[39]"
		for (int i = 0; i < aesl_tmp_406; i++)
		{
			matrix_o[39].write(aesl_tmp_405[i]);
		}

		// push back output stream: "matrix_o[40]"
		for (int i = 0; i < aesl_tmp_409; i++)
		{
			matrix_o[40].write(aesl_tmp_408[i]);
		}

		// push back output stream: "matrix_o[41]"
		for (int i = 0; i < aesl_tmp_412; i++)
		{
			matrix_o[41].write(aesl_tmp_411[i]);
		}

		// push back output stream: "matrix_o[42]"
		for (int i = 0; i < aesl_tmp_415; i++)
		{
			matrix_o[42].write(aesl_tmp_414[i]);
		}

		// push back output stream: "matrix_o[43]"
		for (int i = 0; i < aesl_tmp_418; i++)
		{
			matrix_o[43].write(aesl_tmp_417[i]);
		}

		// push back output stream: "matrix_o[44]"
		for (int i = 0; i < aesl_tmp_421; i++)
		{
			matrix_o[44].write(aesl_tmp_420[i]);
		}

		// push back output stream: "matrix_o[45]"
		for (int i = 0; i < aesl_tmp_424; i++)
		{
			matrix_o[45].write(aesl_tmp_423[i]);
		}

		// push back output stream: "matrix_o[46]"
		for (int i = 0; i < aesl_tmp_427; i++)
		{
			matrix_o[46].write(aesl_tmp_426[i]);
		}

		// push back output stream: "matrix_o[47]"
		for (int i = 0; i < aesl_tmp_430; i++)
		{
			matrix_o[47].write(aesl_tmp_429[i]);
		}

		// push back output stream: "matrix_o[48]"
		for (int i = 0; i < aesl_tmp_433; i++)
		{
			matrix_o[48].write(aesl_tmp_432[i]);
		}

		// push back output stream: "matrix_o[49]"
		for (int i = 0; i < aesl_tmp_436; i++)
		{
			matrix_o[49].write(aesl_tmp_435[i]);
		}

		// push back output stream: "matrix_o[50]"
		for (int i = 0; i < aesl_tmp_439; i++)
		{
			matrix_o[50].write(aesl_tmp_438[i]);
		}

		// push back output stream: "matrix_o[51]"
		for (int i = 0; i < aesl_tmp_442; i++)
		{
			matrix_o[51].write(aesl_tmp_441[i]);
		}

		// push back output stream: "matrix_o[52]"
		for (int i = 0; i < aesl_tmp_445; i++)
		{
			matrix_o[52].write(aesl_tmp_444[i]);
		}

		// push back output stream: "matrix_o[53]"
		for (int i = 0; i < aesl_tmp_448; i++)
		{
			matrix_o[53].write(aesl_tmp_447[i]);
		}

		// push back output stream: "matrix_o[54]"
		for (int i = 0; i < aesl_tmp_451; i++)
		{
			matrix_o[54].write(aesl_tmp_450[i]);
		}

		// push back output stream: "matrix_o[55]"
		for (int i = 0; i < aesl_tmp_454; i++)
		{
			matrix_o[55].write(aesl_tmp_453[i]);
		}

		// push back output stream: "matrix_o[56]"
		for (int i = 0; i < aesl_tmp_457; i++)
		{
			matrix_o[56].write(aesl_tmp_456[i]);
		}

		// push back output stream: "matrix_o[57]"
		for (int i = 0; i < aesl_tmp_460; i++)
		{
			matrix_o[57].write(aesl_tmp_459[i]);
		}

		// push back output stream: "matrix_o[58]"
		for (int i = 0; i < aesl_tmp_463; i++)
		{
			matrix_o[58].write(aesl_tmp_462[i]);
		}

		// push back output stream: "matrix_o[59]"
		for (int i = 0; i < aesl_tmp_466; i++)
		{
			matrix_o[59].write(aesl_tmp_465[i]);
		}

		// push back output stream: "matrix_o[60]"
		for (int i = 0; i < aesl_tmp_469; i++)
		{
			matrix_o[60].write(aesl_tmp_468[i]);
		}

		// push back output stream: "matrix_o[61]"
		for (int i = 0; i < aesl_tmp_472; i++)
		{
			matrix_o[61].write(aesl_tmp_471[i]);
		}

		// push back output stream: "matrix_o[62]"
		for (int i = 0; i < aesl_tmp_475; i++)
		{
			matrix_o[62].write(aesl_tmp_474[i]);
		}

		// push back output stream: "matrix_o[63]"
		for (int i = 0; i < aesl_tmp_478; i++)
		{
			matrix_o[63].write(aesl_tmp_477[i]);
		}

		// push back output stream: "matrix_o[64]"
		for (int i = 0; i < aesl_tmp_481; i++)
		{
			matrix_o[64].write(aesl_tmp_480[i]);
		}

		// push back output stream: "matrix_o[65]"
		for (int i = 0; i < aesl_tmp_484; i++)
		{
			matrix_o[65].write(aesl_tmp_483[i]);
		}

		// push back output stream: "matrix_o[66]"
		for (int i = 0; i < aesl_tmp_487; i++)
		{
			matrix_o[66].write(aesl_tmp_486[i]);
		}

		// push back output stream: "matrix_o[67]"
		for (int i = 0; i < aesl_tmp_490; i++)
		{
			matrix_o[67].write(aesl_tmp_489[i]);
		}

		// push back output stream: "matrix_o[68]"
		for (int i = 0; i < aesl_tmp_493; i++)
		{
			matrix_o[68].write(aesl_tmp_492[i]);
		}

		// push back output stream: "matrix_o[69]"
		for (int i = 0; i < aesl_tmp_496; i++)
		{
			matrix_o[69].write(aesl_tmp_495[i]);
		}

		// push back output stream: "matrix_o[70]"
		for (int i = 0; i < aesl_tmp_499; i++)
		{
			matrix_o[70].write(aesl_tmp_498[i]);
		}

		// push back output stream: "matrix_o[71]"
		for (int i = 0; i < aesl_tmp_502; i++)
		{
			matrix_o[71].write(aesl_tmp_501[i]);
		}

		// push back output stream: "matrix_o[72]"
		for (int i = 0; i < aesl_tmp_505; i++)
		{
			matrix_o[72].write(aesl_tmp_504[i]);
		}

		// push back output stream: "matrix_o[73]"
		for (int i = 0; i < aesl_tmp_508; i++)
		{
			matrix_o[73].write(aesl_tmp_507[i]);
		}

		// push back output stream: "matrix_o[74]"
		for (int i = 0; i < aesl_tmp_511; i++)
		{
			matrix_o[74].write(aesl_tmp_510[i]);
		}

		// push back output stream: "matrix_o[75]"
		for (int i = 0; i < aesl_tmp_514; i++)
		{
			matrix_o[75].write(aesl_tmp_513[i]);
		}

		// push back output stream: "matrix_o[76]"
		for (int i = 0; i < aesl_tmp_517; i++)
		{
			matrix_o[76].write(aesl_tmp_516[i]);
		}

		// push back output stream: "matrix_o[77]"
		for (int i = 0; i < aesl_tmp_520; i++)
		{
			matrix_o[77].write(aesl_tmp_519[i]);
		}

		// push back output stream: "matrix_o[78]"
		for (int i = 0; i < aesl_tmp_523; i++)
		{
			matrix_o[78].write(aesl_tmp_522[i]);
		}

		// push back output stream: "matrix_o[79]"
		for (int i = 0; i < aesl_tmp_526; i++)
		{
			matrix_o[79].write(aesl_tmp_525[i]);
		}

		// push back output stream: "matrix_o[80]"
		for (int i = 0; i < aesl_tmp_529; i++)
		{
			matrix_o[80].write(aesl_tmp_528[i]);
		}

		// push back output stream: "matrix_o[81]"
		for (int i = 0; i < aesl_tmp_532; i++)
		{
			matrix_o[81].write(aesl_tmp_531[i]);
		}

		// push back output stream: "matrix_o[82]"
		for (int i = 0; i < aesl_tmp_535; i++)
		{
			matrix_o[82].write(aesl_tmp_534[i]);
		}

		// push back output stream: "matrix_o[83]"
		for (int i = 0; i < aesl_tmp_538; i++)
		{
			matrix_o[83].write(aesl_tmp_537[i]);
		}

		// push back output stream: "matrix_o[84]"
		for (int i = 0; i < aesl_tmp_541; i++)
		{
			matrix_o[84].write(aesl_tmp_540[i]);
		}

		// push back output stream: "matrix_o[85]"
		for (int i = 0; i < aesl_tmp_544; i++)
		{
			matrix_o[85].write(aesl_tmp_543[i]);
		}

		// push back output stream: "matrix_o[86]"
		for (int i = 0; i < aesl_tmp_547; i++)
		{
			matrix_o[86].write(aesl_tmp_546[i]);
		}

		// push back output stream: "matrix_o[87]"
		for (int i = 0; i < aesl_tmp_550; i++)
		{
			matrix_o[87].write(aesl_tmp_549[i]);
		}

		// push back output stream: "matrix_o[88]"
		for (int i = 0; i < aesl_tmp_553; i++)
		{
			matrix_o[88].write(aesl_tmp_552[i]);
		}

		// push back output stream: "matrix_o[89]"
		for (int i = 0; i < aesl_tmp_556; i++)
		{
			matrix_o[89].write(aesl_tmp_555[i]);
		}

		// push back output stream: "matrix_o[90]"
		for (int i = 0; i < aesl_tmp_559; i++)
		{
			matrix_o[90].write(aesl_tmp_558[i]);
		}

		// push back output stream: "matrix_o[91]"
		for (int i = 0; i < aesl_tmp_562; i++)
		{
			matrix_o[91].write(aesl_tmp_561[i]);
		}

		// push back output stream: "matrix_o[92]"
		for (int i = 0; i < aesl_tmp_565; i++)
		{
			matrix_o[92].write(aesl_tmp_564[i]);
		}

		// push back output stream: "matrix_o[93]"
		for (int i = 0; i < aesl_tmp_568; i++)
		{
			matrix_o[93].write(aesl_tmp_567[i]);
		}

		// push back output stream: "matrix_o[94]"
		for (int i = 0; i < aesl_tmp_571; i++)
		{
			matrix_o[94].write(aesl_tmp_570[i]);
		}

		// push back output stream: "matrix_o[95]"
		for (int i = 0; i < aesl_tmp_574; i++)
		{
			matrix_o[95].write(aesl_tmp_573[i]);
		}

		// push back output stream: "matrix_o[96]"
		for (int i = 0; i < aesl_tmp_577; i++)
		{
			matrix_o[96].write(aesl_tmp_576[i]);
		}

		// push back output stream: "matrix_o[97]"
		for (int i = 0; i < aesl_tmp_580; i++)
		{
			matrix_o[97].write(aesl_tmp_579[i]);
		}

		// push back output stream: "matrix_o[98]"
		for (int i = 0; i < aesl_tmp_583; i++)
		{
			matrix_o[98].write(aesl_tmp_582[i]);
		}

		// push back output stream: "matrix_o[99]"
		for (int i = 0; i < aesl_tmp_586; i++)
		{
			matrix_o[99].write(aesl_tmp_585[i]);
		}

		// push back output stream: "matrix_o[100]"
		for (int i = 0; i < aesl_tmp_589; i++)
		{
			matrix_o[100].write(aesl_tmp_588[i]);
		}

		// push back output stream: "matrix_o[101]"
		for (int i = 0; i < aesl_tmp_592; i++)
		{
			matrix_o[101].write(aesl_tmp_591[i]);
		}

		// push back output stream: "matrix_o[102]"
		for (int i = 0; i < aesl_tmp_595; i++)
		{
			matrix_o[102].write(aesl_tmp_594[i]);
		}

		// push back output stream: "matrix_o[103]"
		for (int i = 0; i < aesl_tmp_598; i++)
		{
			matrix_o[103].write(aesl_tmp_597[i]);
		}

		// push back output stream: "matrix_o[104]"
		for (int i = 0; i < aesl_tmp_601; i++)
		{
			matrix_o[104].write(aesl_tmp_600[i]);
		}

		// push back output stream: "matrix_o[105]"
		for (int i = 0; i < aesl_tmp_604; i++)
		{
			matrix_o[105].write(aesl_tmp_603[i]);
		}

		// push back output stream: "matrix_o[106]"
		for (int i = 0; i < aesl_tmp_607; i++)
		{
			matrix_o[106].write(aesl_tmp_606[i]);
		}

		// push back output stream: "matrix_o[107]"
		for (int i = 0; i < aesl_tmp_610; i++)
		{
			matrix_o[107].write(aesl_tmp_609[i]);
		}

		// push back output stream: "matrix_o[108]"
		for (int i = 0; i < aesl_tmp_613; i++)
		{
			matrix_o[108].write(aesl_tmp_612[i]);
		}

		// push back output stream: "matrix_o[109]"
		for (int i = 0; i < aesl_tmp_616; i++)
		{
			matrix_o[109].write(aesl_tmp_615[i]);
		}

		// push back output stream: "matrix_o[110]"
		for (int i = 0; i < aesl_tmp_619; i++)
		{
			matrix_o[110].write(aesl_tmp_618[i]);
		}

		// push back output stream: "matrix_o[111]"
		for (int i = 0; i < aesl_tmp_622; i++)
		{
			matrix_o[111].write(aesl_tmp_621[i]);
		}

		// push back output stream: "matrix_o[112]"
		for (int i = 0; i < aesl_tmp_625; i++)
		{
			matrix_o[112].write(aesl_tmp_624[i]);
		}

		// push back output stream: "matrix_o[113]"
		for (int i = 0; i < aesl_tmp_628; i++)
		{
			matrix_o[113].write(aesl_tmp_627[i]);
		}

		// push back output stream: "matrix_o[114]"
		for (int i = 0; i < aesl_tmp_631; i++)
		{
			matrix_o[114].write(aesl_tmp_630[i]);
		}

		// push back output stream: "matrix_o[115]"
		for (int i = 0; i < aesl_tmp_634; i++)
		{
			matrix_o[115].write(aesl_tmp_633[i]);
		}

		// push back output stream: "matrix_o[116]"
		for (int i = 0; i < aesl_tmp_637; i++)
		{
			matrix_o[116].write(aesl_tmp_636[i]);
		}

		// push back output stream: "matrix_o[117]"
		for (int i = 0; i < aesl_tmp_640; i++)
		{
			matrix_o[117].write(aesl_tmp_639[i]);
		}

		// push back output stream: "matrix_o[118]"
		for (int i = 0; i < aesl_tmp_643; i++)
		{
			matrix_o[118].write(aesl_tmp_642[i]);
		}

		// push back output stream: "matrix_o[119]"
		for (int i = 0; i < aesl_tmp_646; i++)
		{
			matrix_o[119].write(aesl_tmp_645[i]);
		}

		// push back output stream: "matrix_o[120]"
		for (int i = 0; i < aesl_tmp_649; i++)
		{
			matrix_o[120].write(aesl_tmp_648[i]);
		}

		// push back output stream: "matrix_o[121]"
		for (int i = 0; i < aesl_tmp_652; i++)
		{
			matrix_o[121].write(aesl_tmp_651[i]);
		}

		// push back output stream: "matrix_o[122]"
		for (int i = 0; i < aesl_tmp_655; i++)
		{
			matrix_o[122].write(aesl_tmp_654[i]);
		}

		// push back output stream: "matrix_o[123]"
		for (int i = 0; i < aesl_tmp_658; i++)
		{
			matrix_o[123].write(aesl_tmp_657[i]);
		}

		// push back output stream: "matrix_o[124]"
		for (int i = 0; i < aesl_tmp_661; i++)
		{
			matrix_o[124].write(aesl_tmp_660[i]);
		}

		// push back output stream: "matrix_o[125]"
		for (int i = 0; i < aesl_tmp_664; i++)
		{
			matrix_o[125].write(aesl_tmp_663[i]);
		}

		// push back output stream: "matrix_o[126]"
		for (int i = 0; i < aesl_tmp_667; i++)
		{
			matrix_o[126].write(aesl_tmp_666[i]);
		}

		// push back output stream: "matrix_o[127]"
		for (int i = 0; i < aesl_tmp_670; i++)
		{
			matrix_o[127].write(aesl_tmp_669[i]);
		}

		// release memory allocation: "matrix_i_0_V"
		delete [] tvin_matrix_i_0_V;
		delete [] wrapc_stream_size_in_matrix_i_0_V;
		// release memory allocation: "matrix_i_1_V"
		delete [] tvin_matrix_i_1_V;
		delete [] wrapc_stream_size_in_matrix_i_1_V;
		// release memory allocation: "matrix_i_2_V"
		delete [] tvin_matrix_i_2_V;
		delete [] wrapc_stream_size_in_matrix_i_2_V;
		// release memory allocation: "matrix_i_3_V"
		delete [] tvin_matrix_i_3_V;
		delete [] wrapc_stream_size_in_matrix_i_3_V;
		// release memory allocation: "matrix_i_4_V"
		delete [] tvin_matrix_i_4_V;
		delete [] wrapc_stream_size_in_matrix_i_4_V;
		// release memory allocation: "matrix_i_5_V"
		delete [] tvin_matrix_i_5_V;
		delete [] wrapc_stream_size_in_matrix_i_5_V;
		// release memory allocation: "matrix_i_6_V"
		delete [] tvin_matrix_i_6_V;
		delete [] wrapc_stream_size_in_matrix_i_6_V;
		// release memory allocation: "matrix_i_7_V"
		delete [] tvin_matrix_i_7_V;
		delete [] wrapc_stream_size_in_matrix_i_7_V;
		// release memory allocation: "matrix_i_8_V"
		delete [] tvin_matrix_i_8_V;
		delete [] wrapc_stream_size_in_matrix_i_8_V;
		// release memory allocation: "matrix_i_9_V"
		delete [] tvin_matrix_i_9_V;
		delete [] wrapc_stream_size_in_matrix_i_9_V;
		// release memory allocation: "matrix_i_10_V"
		delete [] tvin_matrix_i_10_V;
		delete [] wrapc_stream_size_in_matrix_i_10_V;
		// release memory allocation: "matrix_i_11_V"
		delete [] tvin_matrix_i_11_V;
		delete [] wrapc_stream_size_in_matrix_i_11_V;
		// release memory allocation: "matrix_i_12_V"
		delete [] tvin_matrix_i_12_V;
		delete [] wrapc_stream_size_in_matrix_i_12_V;
		// release memory allocation: "matrix_i_13_V"
		delete [] tvin_matrix_i_13_V;
		delete [] wrapc_stream_size_in_matrix_i_13_V;
		// release memory allocation: "matrix_i_14_V"
		delete [] tvin_matrix_i_14_V;
		delete [] wrapc_stream_size_in_matrix_i_14_V;
		// release memory allocation: "matrix_i_15_V"
		delete [] tvin_matrix_i_15_V;
		delete [] wrapc_stream_size_in_matrix_i_15_V;
		// release memory allocation: "matrix_i_16_V"
		delete [] tvin_matrix_i_16_V;
		delete [] wrapc_stream_size_in_matrix_i_16_V;
		// release memory allocation: "matrix_i_17_V"
		delete [] tvin_matrix_i_17_V;
		delete [] wrapc_stream_size_in_matrix_i_17_V;
		// release memory allocation: "matrix_i_18_V"
		delete [] tvin_matrix_i_18_V;
		delete [] wrapc_stream_size_in_matrix_i_18_V;
		// release memory allocation: "matrix_i_19_V"
		delete [] tvin_matrix_i_19_V;
		delete [] wrapc_stream_size_in_matrix_i_19_V;
		// release memory allocation: "matrix_i_20_V"
		delete [] tvin_matrix_i_20_V;
		delete [] wrapc_stream_size_in_matrix_i_20_V;
		// release memory allocation: "matrix_i_21_V"
		delete [] tvin_matrix_i_21_V;
		delete [] wrapc_stream_size_in_matrix_i_21_V;
		// release memory allocation: "matrix_i_22_V"
		delete [] tvin_matrix_i_22_V;
		delete [] wrapc_stream_size_in_matrix_i_22_V;
		// release memory allocation: "matrix_i_23_V"
		delete [] tvin_matrix_i_23_V;
		delete [] wrapc_stream_size_in_matrix_i_23_V;
		// release memory allocation: "matrix_i_24_V"
		delete [] tvin_matrix_i_24_V;
		delete [] wrapc_stream_size_in_matrix_i_24_V;
		// release memory allocation: "matrix_i_25_V"
		delete [] tvin_matrix_i_25_V;
		delete [] wrapc_stream_size_in_matrix_i_25_V;
		// release memory allocation: "matrix_i_26_V"
		delete [] tvin_matrix_i_26_V;
		delete [] wrapc_stream_size_in_matrix_i_26_V;
		// release memory allocation: "matrix_i_27_V"
		delete [] tvin_matrix_i_27_V;
		delete [] wrapc_stream_size_in_matrix_i_27_V;
		// release memory allocation: "matrix_i_28_V"
		delete [] tvin_matrix_i_28_V;
		delete [] wrapc_stream_size_in_matrix_i_28_V;
		// release memory allocation: "matrix_i_29_V"
		delete [] tvin_matrix_i_29_V;
		delete [] wrapc_stream_size_in_matrix_i_29_V;
		// release memory allocation: "matrix_i_30_V"
		delete [] tvin_matrix_i_30_V;
		delete [] wrapc_stream_size_in_matrix_i_30_V;
		// release memory allocation: "matrix_i_31_V"
		delete [] tvin_matrix_i_31_V;
		delete [] wrapc_stream_size_in_matrix_i_31_V;
		// release memory allocation: "matrix_i_32_V"
		delete [] tvin_matrix_i_32_V;
		delete [] wrapc_stream_size_in_matrix_i_32_V;
		// release memory allocation: "matrix_i_33_V"
		delete [] tvin_matrix_i_33_V;
		delete [] wrapc_stream_size_in_matrix_i_33_V;
		// release memory allocation: "matrix_i_34_V"
		delete [] tvin_matrix_i_34_V;
		delete [] wrapc_stream_size_in_matrix_i_34_V;
		// release memory allocation: "matrix_i_35_V"
		delete [] tvin_matrix_i_35_V;
		delete [] wrapc_stream_size_in_matrix_i_35_V;
		// release memory allocation: "matrix_i_36_V"
		delete [] tvin_matrix_i_36_V;
		delete [] wrapc_stream_size_in_matrix_i_36_V;
		// release memory allocation: "matrix_i_37_V"
		delete [] tvin_matrix_i_37_V;
		delete [] wrapc_stream_size_in_matrix_i_37_V;
		// release memory allocation: "matrix_i_38_V"
		delete [] tvin_matrix_i_38_V;
		delete [] wrapc_stream_size_in_matrix_i_38_V;
		// release memory allocation: "matrix_i_39_V"
		delete [] tvin_matrix_i_39_V;
		delete [] wrapc_stream_size_in_matrix_i_39_V;
		// release memory allocation: "matrix_i_40_V"
		delete [] tvin_matrix_i_40_V;
		delete [] wrapc_stream_size_in_matrix_i_40_V;
		// release memory allocation: "matrix_i_41_V"
		delete [] tvin_matrix_i_41_V;
		delete [] wrapc_stream_size_in_matrix_i_41_V;
		// release memory allocation: "matrix_i_42_V"
		delete [] tvin_matrix_i_42_V;
		delete [] wrapc_stream_size_in_matrix_i_42_V;
		// release memory allocation: "matrix_i_43_V"
		delete [] tvin_matrix_i_43_V;
		delete [] wrapc_stream_size_in_matrix_i_43_V;
		// release memory allocation: "matrix_i_44_V"
		delete [] tvin_matrix_i_44_V;
		delete [] wrapc_stream_size_in_matrix_i_44_V;
		// release memory allocation: "matrix_i_45_V"
		delete [] tvin_matrix_i_45_V;
		delete [] wrapc_stream_size_in_matrix_i_45_V;
		// release memory allocation: "matrix_i_46_V"
		delete [] tvin_matrix_i_46_V;
		delete [] wrapc_stream_size_in_matrix_i_46_V;
		// release memory allocation: "matrix_i_47_V"
		delete [] tvin_matrix_i_47_V;
		delete [] wrapc_stream_size_in_matrix_i_47_V;
		// release memory allocation: "matrix_i_48_V"
		delete [] tvin_matrix_i_48_V;
		delete [] wrapc_stream_size_in_matrix_i_48_V;
		// release memory allocation: "matrix_i_49_V"
		delete [] tvin_matrix_i_49_V;
		delete [] wrapc_stream_size_in_matrix_i_49_V;
		// release memory allocation: "matrix_i_50_V"
		delete [] tvin_matrix_i_50_V;
		delete [] wrapc_stream_size_in_matrix_i_50_V;
		// release memory allocation: "matrix_i_51_V"
		delete [] tvin_matrix_i_51_V;
		delete [] wrapc_stream_size_in_matrix_i_51_V;
		// release memory allocation: "matrix_i_52_V"
		delete [] tvin_matrix_i_52_V;
		delete [] wrapc_stream_size_in_matrix_i_52_V;
		// release memory allocation: "matrix_i_53_V"
		delete [] tvin_matrix_i_53_V;
		delete [] wrapc_stream_size_in_matrix_i_53_V;
		// release memory allocation: "matrix_i_54_V"
		delete [] tvin_matrix_i_54_V;
		delete [] wrapc_stream_size_in_matrix_i_54_V;
		// release memory allocation: "matrix_i_55_V"
		delete [] tvin_matrix_i_55_V;
		delete [] wrapc_stream_size_in_matrix_i_55_V;
		// release memory allocation: "matrix_i_56_V"
		delete [] tvin_matrix_i_56_V;
		delete [] wrapc_stream_size_in_matrix_i_56_V;
		// release memory allocation: "matrix_i_57_V"
		delete [] tvin_matrix_i_57_V;
		delete [] wrapc_stream_size_in_matrix_i_57_V;
		// release memory allocation: "matrix_i_58_V"
		delete [] tvin_matrix_i_58_V;
		delete [] wrapc_stream_size_in_matrix_i_58_V;
		// release memory allocation: "matrix_i_59_V"
		delete [] tvin_matrix_i_59_V;
		delete [] wrapc_stream_size_in_matrix_i_59_V;
		// release memory allocation: "matrix_i_60_V"
		delete [] tvin_matrix_i_60_V;
		delete [] wrapc_stream_size_in_matrix_i_60_V;
		// release memory allocation: "matrix_i_61_V"
		delete [] tvin_matrix_i_61_V;
		delete [] wrapc_stream_size_in_matrix_i_61_V;
		// release memory allocation: "matrix_i_62_V"
		delete [] tvin_matrix_i_62_V;
		delete [] wrapc_stream_size_in_matrix_i_62_V;
		// release memory allocation: "matrix_i_63_V"
		delete [] tvin_matrix_i_63_V;
		delete [] wrapc_stream_size_in_matrix_i_63_V;
		// release memory allocation: "matrix_i_64_V"
		delete [] tvin_matrix_i_64_V;
		delete [] wrapc_stream_size_in_matrix_i_64_V;
		// release memory allocation: "matrix_i_65_V"
		delete [] tvin_matrix_i_65_V;
		delete [] wrapc_stream_size_in_matrix_i_65_V;
		// release memory allocation: "matrix_i_66_V"
		delete [] tvin_matrix_i_66_V;
		delete [] wrapc_stream_size_in_matrix_i_66_V;
		// release memory allocation: "matrix_i_67_V"
		delete [] tvin_matrix_i_67_V;
		delete [] wrapc_stream_size_in_matrix_i_67_V;
		// release memory allocation: "matrix_i_68_V"
		delete [] tvin_matrix_i_68_V;
		delete [] wrapc_stream_size_in_matrix_i_68_V;
		// release memory allocation: "matrix_i_69_V"
		delete [] tvin_matrix_i_69_V;
		delete [] wrapc_stream_size_in_matrix_i_69_V;
		// release memory allocation: "matrix_i_70_V"
		delete [] tvin_matrix_i_70_V;
		delete [] wrapc_stream_size_in_matrix_i_70_V;
		// release memory allocation: "matrix_i_71_V"
		delete [] tvin_matrix_i_71_V;
		delete [] wrapc_stream_size_in_matrix_i_71_V;
		// release memory allocation: "matrix_i_72_V"
		delete [] tvin_matrix_i_72_V;
		delete [] wrapc_stream_size_in_matrix_i_72_V;
		// release memory allocation: "matrix_i_73_V"
		delete [] tvin_matrix_i_73_V;
		delete [] wrapc_stream_size_in_matrix_i_73_V;
		// release memory allocation: "matrix_i_74_V"
		delete [] tvin_matrix_i_74_V;
		delete [] wrapc_stream_size_in_matrix_i_74_V;
		// release memory allocation: "matrix_i_75_V"
		delete [] tvin_matrix_i_75_V;
		delete [] wrapc_stream_size_in_matrix_i_75_V;
		// release memory allocation: "matrix_i_76_V"
		delete [] tvin_matrix_i_76_V;
		delete [] wrapc_stream_size_in_matrix_i_76_V;
		// release memory allocation: "matrix_i_77_V"
		delete [] tvin_matrix_i_77_V;
		delete [] wrapc_stream_size_in_matrix_i_77_V;
		// release memory allocation: "matrix_i_78_V"
		delete [] tvin_matrix_i_78_V;
		delete [] wrapc_stream_size_in_matrix_i_78_V;
		// release memory allocation: "matrix_i_79_V"
		delete [] tvin_matrix_i_79_V;
		delete [] wrapc_stream_size_in_matrix_i_79_V;
		// release memory allocation: "matrix_i_80_V"
		delete [] tvin_matrix_i_80_V;
		delete [] wrapc_stream_size_in_matrix_i_80_V;
		// release memory allocation: "matrix_i_81_V"
		delete [] tvin_matrix_i_81_V;
		delete [] wrapc_stream_size_in_matrix_i_81_V;
		// release memory allocation: "matrix_i_82_V"
		delete [] tvin_matrix_i_82_V;
		delete [] wrapc_stream_size_in_matrix_i_82_V;
		// release memory allocation: "matrix_i_83_V"
		delete [] tvin_matrix_i_83_V;
		delete [] wrapc_stream_size_in_matrix_i_83_V;
		// release memory allocation: "matrix_i_84_V"
		delete [] tvin_matrix_i_84_V;
		delete [] wrapc_stream_size_in_matrix_i_84_V;
		// release memory allocation: "matrix_i_85_V"
		delete [] tvin_matrix_i_85_V;
		delete [] wrapc_stream_size_in_matrix_i_85_V;
		// release memory allocation: "matrix_i_86_V"
		delete [] tvin_matrix_i_86_V;
		delete [] wrapc_stream_size_in_matrix_i_86_V;
		// release memory allocation: "matrix_i_87_V"
		delete [] tvin_matrix_i_87_V;
		delete [] wrapc_stream_size_in_matrix_i_87_V;
		// release memory allocation: "matrix_i_88_V"
		delete [] tvin_matrix_i_88_V;
		delete [] wrapc_stream_size_in_matrix_i_88_V;
		// release memory allocation: "matrix_i_89_V"
		delete [] tvin_matrix_i_89_V;
		delete [] wrapc_stream_size_in_matrix_i_89_V;
		// release memory allocation: "matrix_i_90_V"
		delete [] tvin_matrix_i_90_V;
		delete [] wrapc_stream_size_in_matrix_i_90_V;
		// release memory allocation: "matrix_i_91_V"
		delete [] tvin_matrix_i_91_V;
		delete [] wrapc_stream_size_in_matrix_i_91_V;
		// release memory allocation: "matrix_i_92_V"
		delete [] tvin_matrix_i_92_V;
		delete [] wrapc_stream_size_in_matrix_i_92_V;
		// release memory allocation: "matrix_i_93_V"
		delete [] tvin_matrix_i_93_V;
		delete [] wrapc_stream_size_in_matrix_i_93_V;
		// release memory allocation: "matrix_i_94_V"
		delete [] tvin_matrix_i_94_V;
		delete [] wrapc_stream_size_in_matrix_i_94_V;
		// release memory allocation: "matrix_i_95_V"
		delete [] tvin_matrix_i_95_V;
		delete [] wrapc_stream_size_in_matrix_i_95_V;
		// release memory allocation: "kernel_s1x1"
		delete [] tvin_kernel_s1x1;
		// release memory allocation: "kernel_e1x1"
		delete [] tvin_kernel_e1x1;
		// release memory allocation: "kernel_e3x3"
		delete [] tvin_kernel_e3x3;
		// release memory allocation: "matrix_o_0_V"
		delete [] tvout_matrix_o_0_V;
		delete [] tvin_matrix_o_0_V;
		delete [] wrapc_stream_size_out_matrix_o_0_V;
		// release memory allocation: "matrix_o_1_V"
		delete [] tvout_matrix_o_1_V;
		delete [] tvin_matrix_o_1_V;
		delete [] wrapc_stream_size_out_matrix_o_1_V;
		// release memory allocation: "matrix_o_2_V"
		delete [] tvout_matrix_o_2_V;
		delete [] tvin_matrix_o_2_V;
		delete [] wrapc_stream_size_out_matrix_o_2_V;
		// release memory allocation: "matrix_o_3_V"
		delete [] tvout_matrix_o_3_V;
		delete [] tvin_matrix_o_3_V;
		delete [] wrapc_stream_size_out_matrix_o_3_V;
		// release memory allocation: "matrix_o_4_V"
		delete [] tvout_matrix_o_4_V;
		delete [] tvin_matrix_o_4_V;
		delete [] wrapc_stream_size_out_matrix_o_4_V;
		// release memory allocation: "matrix_o_5_V"
		delete [] tvout_matrix_o_5_V;
		delete [] tvin_matrix_o_5_V;
		delete [] wrapc_stream_size_out_matrix_o_5_V;
		// release memory allocation: "matrix_o_6_V"
		delete [] tvout_matrix_o_6_V;
		delete [] tvin_matrix_o_6_V;
		delete [] wrapc_stream_size_out_matrix_o_6_V;
		// release memory allocation: "matrix_o_7_V"
		delete [] tvout_matrix_o_7_V;
		delete [] tvin_matrix_o_7_V;
		delete [] wrapc_stream_size_out_matrix_o_7_V;
		// release memory allocation: "matrix_o_8_V"
		delete [] tvout_matrix_o_8_V;
		delete [] tvin_matrix_o_8_V;
		delete [] wrapc_stream_size_out_matrix_o_8_V;
		// release memory allocation: "matrix_o_9_V"
		delete [] tvout_matrix_o_9_V;
		delete [] tvin_matrix_o_9_V;
		delete [] wrapc_stream_size_out_matrix_o_9_V;
		// release memory allocation: "matrix_o_10_V"
		delete [] tvout_matrix_o_10_V;
		delete [] tvin_matrix_o_10_V;
		delete [] wrapc_stream_size_out_matrix_o_10_V;
		// release memory allocation: "matrix_o_11_V"
		delete [] tvout_matrix_o_11_V;
		delete [] tvin_matrix_o_11_V;
		delete [] wrapc_stream_size_out_matrix_o_11_V;
		// release memory allocation: "matrix_o_12_V"
		delete [] tvout_matrix_o_12_V;
		delete [] tvin_matrix_o_12_V;
		delete [] wrapc_stream_size_out_matrix_o_12_V;
		// release memory allocation: "matrix_o_13_V"
		delete [] tvout_matrix_o_13_V;
		delete [] tvin_matrix_o_13_V;
		delete [] wrapc_stream_size_out_matrix_o_13_V;
		// release memory allocation: "matrix_o_14_V"
		delete [] tvout_matrix_o_14_V;
		delete [] tvin_matrix_o_14_V;
		delete [] wrapc_stream_size_out_matrix_o_14_V;
		// release memory allocation: "matrix_o_15_V"
		delete [] tvout_matrix_o_15_V;
		delete [] tvin_matrix_o_15_V;
		delete [] wrapc_stream_size_out_matrix_o_15_V;
		// release memory allocation: "matrix_o_16_V"
		delete [] tvout_matrix_o_16_V;
		delete [] tvin_matrix_o_16_V;
		delete [] wrapc_stream_size_out_matrix_o_16_V;
		// release memory allocation: "matrix_o_17_V"
		delete [] tvout_matrix_o_17_V;
		delete [] tvin_matrix_o_17_V;
		delete [] wrapc_stream_size_out_matrix_o_17_V;
		// release memory allocation: "matrix_o_18_V"
		delete [] tvout_matrix_o_18_V;
		delete [] tvin_matrix_o_18_V;
		delete [] wrapc_stream_size_out_matrix_o_18_V;
		// release memory allocation: "matrix_o_19_V"
		delete [] tvout_matrix_o_19_V;
		delete [] tvin_matrix_o_19_V;
		delete [] wrapc_stream_size_out_matrix_o_19_V;
		// release memory allocation: "matrix_o_20_V"
		delete [] tvout_matrix_o_20_V;
		delete [] tvin_matrix_o_20_V;
		delete [] wrapc_stream_size_out_matrix_o_20_V;
		// release memory allocation: "matrix_o_21_V"
		delete [] tvout_matrix_o_21_V;
		delete [] tvin_matrix_o_21_V;
		delete [] wrapc_stream_size_out_matrix_o_21_V;
		// release memory allocation: "matrix_o_22_V"
		delete [] tvout_matrix_o_22_V;
		delete [] tvin_matrix_o_22_V;
		delete [] wrapc_stream_size_out_matrix_o_22_V;
		// release memory allocation: "matrix_o_23_V"
		delete [] tvout_matrix_o_23_V;
		delete [] tvin_matrix_o_23_V;
		delete [] wrapc_stream_size_out_matrix_o_23_V;
		// release memory allocation: "matrix_o_24_V"
		delete [] tvout_matrix_o_24_V;
		delete [] tvin_matrix_o_24_V;
		delete [] wrapc_stream_size_out_matrix_o_24_V;
		// release memory allocation: "matrix_o_25_V"
		delete [] tvout_matrix_o_25_V;
		delete [] tvin_matrix_o_25_V;
		delete [] wrapc_stream_size_out_matrix_o_25_V;
		// release memory allocation: "matrix_o_26_V"
		delete [] tvout_matrix_o_26_V;
		delete [] tvin_matrix_o_26_V;
		delete [] wrapc_stream_size_out_matrix_o_26_V;
		// release memory allocation: "matrix_o_27_V"
		delete [] tvout_matrix_o_27_V;
		delete [] tvin_matrix_o_27_V;
		delete [] wrapc_stream_size_out_matrix_o_27_V;
		// release memory allocation: "matrix_o_28_V"
		delete [] tvout_matrix_o_28_V;
		delete [] tvin_matrix_o_28_V;
		delete [] wrapc_stream_size_out_matrix_o_28_V;
		// release memory allocation: "matrix_o_29_V"
		delete [] tvout_matrix_o_29_V;
		delete [] tvin_matrix_o_29_V;
		delete [] wrapc_stream_size_out_matrix_o_29_V;
		// release memory allocation: "matrix_o_30_V"
		delete [] tvout_matrix_o_30_V;
		delete [] tvin_matrix_o_30_V;
		delete [] wrapc_stream_size_out_matrix_o_30_V;
		// release memory allocation: "matrix_o_31_V"
		delete [] tvout_matrix_o_31_V;
		delete [] tvin_matrix_o_31_V;
		delete [] wrapc_stream_size_out_matrix_o_31_V;
		// release memory allocation: "matrix_o_32_V"
		delete [] tvout_matrix_o_32_V;
		delete [] tvin_matrix_o_32_V;
		delete [] wrapc_stream_size_out_matrix_o_32_V;
		// release memory allocation: "matrix_o_33_V"
		delete [] tvout_matrix_o_33_V;
		delete [] tvin_matrix_o_33_V;
		delete [] wrapc_stream_size_out_matrix_o_33_V;
		// release memory allocation: "matrix_o_34_V"
		delete [] tvout_matrix_o_34_V;
		delete [] tvin_matrix_o_34_V;
		delete [] wrapc_stream_size_out_matrix_o_34_V;
		// release memory allocation: "matrix_o_35_V"
		delete [] tvout_matrix_o_35_V;
		delete [] tvin_matrix_o_35_V;
		delete [] wrapc_stream_size_out_matrix_o_35_V;
		// release memory allocation: "matrix_o_36_V"
		delete [] tvout_matrix_o_36_V;
		delete [] tvin_matrix_o_36_V;
		delete [] wrapc_stream_size_out_matrix_o_36_V;
		// release memory allocation: "matrix_o_37_V"
		delete [] tvout_matrix_o_37_V;
		delete [] tvin_matrix_o_37_V;
		delete [] wrapc_stream_size_out_matrix_o_37_V;
		// release memory allocation: "matrix_o_38_V"
		delete [] tvout_matrix_o_38_V;
		delete [] tvin_matrix_o_38_V;
		delete [] wrapc_stream_size_out_matrix_o_38_V;
		// release memory allocation: "matrix_o_39_V"
		delete [] tvout_matrix_o_39_V;
		delete [] tvin_matrix_o_39_V;
		delete [] wrapc_stream_size_out_matrix_o_39_V;
		// release memory allocation: "matrix_o_40_V"
		delete [] tvout_matrix_o_40_V;
		delete [] tvin_matrix_o_40_V;
		delete [] wrapc_stream_size_out_matrix_o_40_V;
		// release memory allocation: "matrix_o_41_V"
		delete [] tvout_matrix_o_41_V;
		delete [] tvin_matrix_o_41_V;
		delete [] wrapc_stream_size_out_matrix_o_41_V;
		// release memory allocation: "matrix_o_42_V"
		delete [] tvout_matrix_o_42_V;
		delete [] tvin_matrix_o_42_V;
		delete [] wrapc_stream_size_out_matrix_o_42_V;
		// release memory allocation: "matrix_o_43_V"
		delete [] tvout_matrix_o_43_V;
		delete [] tvin_matrix_o_43_V;
		delete [] wrapc_stream_size_out_matrix_o_43_V;
		// release memory allocation: "matrix_o_44_V"
		delete [] tvout_matrix_o_44_V;
		delete [] tvin_matrix_o_44_V;
		delete [] wrapc_stream_size_out_matrix_o_44_V;
		// release memory allocation: "matrix_o_45_V"
		delete [] tvout_matrix_o_45_V;
		delete [] tvin_matrix_o_45_V;
		delete [] wrapc_stream_size_out_matrix_o_45_V;
		// release memory allocation: "matrix_o_46_V"
		delete [] tvout_matrix_o_46_V;
		delete [] tvin_matrix_o_46_V;
		delete [] wrapc_stream_size_out_matrix_o_46_V;
		// release memory allocation: "matrix_o_47_V"
		delete [] tvout_matrix_o_47_V;
		delete [] tvin_matrix_o_47_V;
		delete [] wrapc_stream_size_out_matrix_o_47_V;
		// release memory allocation: "matrix_o_48_V"
		delete [] tvout_matrix_o_48_V;
		delete [] tvin_matrix_o_48_V;
		delete [] wrapc_stream_size_out_matrix_o_48_V;
		// release memory allocation: "matrix_o_49_V"
		delete [] tvout_matrix_o_49_V;
		delete [] tvin_matrix_o_49_V;
		delete [] wrapc_stream_size_out_matrix_o_49_V;
		// release memory allocation: "matrix_o_50_V"
		delete [] tvout_matrix_o_50_V;
		delete [] tvin_matrix_o_50_V;
		delete [] wrapc_stream_size_out_matrix_o_50_V;
		// release memory allocation: "matrix_o_51_V"
		delete [] tvout_matrix_o_51_V;
		delete [] tvin_matrix_o_51_V;
		delete [] wrapc_stream_size_out_matrix_o_51_V;
		// release memory allocation: "matrix_o_52_V"
		delete [] tvout_matrix_o_52_V;
		delete [] tvin_matrix_o_52_V;
		delete [] wrapc_stream_size_out_matrix_o_52_V;
		// release memory allocation: "matrix_o_53_V"
		delete [] tvout_matrix_o_53_V;
		delete [] tvin_matrix_o_53_V;
		delete [] wrapc_stream_size_out_matrix_o_53_V;
		// release memory allocation: "matrix_o_54_V"
		delete [] tvout_matrix_o_54_V;
		delete [] tvin_matrix_o_54_V;
		delete [] wrapc_stream_size_out_matrix_o_54_V;
		// release memory allocation: "matrix_o_55_V"
		delete [] tvout_matrix_o_55_V;
		delete [] tvin_matrix_o_55_V;
		delete [] wrapc_stream_size_out_matrix_o_55_V;
		// release memory allocation: "matrix_o_56_V"
		delete [] tvout_matrix_o_56_V;
		delete [] tvin_matrix_o_56_V;
		delete [] wrapc_stream_size_out_matrix_o_56_V;
		// release memory allocation: "matrix_o_57_V"
		delete [] tvout_matrix_o_57_V;
		delete [] tvin_matrix_o_57_V;
		delete [] wrapc_stream_size_out_matrix_o_57_V;
		// release memory allocation: "matrix_o_58_V"
		delete [] tvout_matrix_o_58_V;
		delete [] tvin_matrix_o_58_V;
		delete [] wrapc_stream_size_out_matrix_o_58_V;
		// release memory allocation: "matrix_o_59_V"
		delete [] tvout_matrix_o_59_V;
		delete [] tvin_matrix_o_59_V;
		delete [] wrapc_stream_size_out_matrix_o_59_V;
		// release memory allocation: "matrix_o_60_V"
		delete [] tvout_matrix_o_60_V;
		delete [] tvin_matrix_o_60_V;
		delete [] wrapc_stream_size_out_matrix_o_60_V;
		// release memory allocation: "matrix_o_61_V"
		delete [] tvout_matrix_o_61_V;
		delete [] tvin_matrix_o_61_V;
		delete [] wrapc_stream_size_out_matrix_o_61_V;
		// release memory allocation: "matrix_o_62_V"
		delete [] tvout_matrix_o_62_V;
		delete [] tvin_matrix_o_62_V;
		delete [] wrapc_stream_size_out_matrix_o_62_V;
		// release memory allocation: "matrix_o_63_V"
		delete [] tvout_matrix_o_63_V;
		delete [] tvin_matrix_o_63_V;
		delete [] wrapc_stream_size_out_matrix_o_63_V;
		// release memory allocation: "matrix_o_64_V"
		delete [] tvout_matrix_o_64_V;
		delete [] tvin_matrix_o_64_V;
		delete [] wrapc_stream_size_out_matrix_o_64_V;
		// release memory allocation: "matrix_o_65_V"
		delete [] tvout_matrix_o_65_V;
		delete [] tvin_matrix_o_65_V;
		delete [] wrapc_stream_size_out_matrix_o_65_V;
		// release memory allocation: "matrix_o_66_V"
		delete [] tvout_matrix_o_66_V;
		delete [] tvin_matrix_o_66_V;
		delete [] wrapc_stream_size_out_matrix_o_66_V;
		// release memory allocation: "matrix_o_67_V"
		delete [] tvout_matrix_o_67_V;
		delete [] tvin_matrix_o_67_V;
		delete [] wrapc_stream_size_out_matrix_o_67_V;
		// release memory allocation: "matrix_o_68_V"
		delete [] tvout_matrix_o_68_V;
		delete [] tvin_matrix_o_68_V;
		delete [] wrapc_stream_size_out_matrix_o_68_V;
		// release memory allocation: "matrix_o_69_V"
		delete [] tvout_matrix_o_69_V;
		delete [] tvin_matrix_o_69_V;
		delete [] wrapc_stream_size_out_matrix_o_69_V;
		// release memory allocation: "matrix_o_70_V"
		delete [] tvout_matrix_o_70_V;
		delete [] tvin_matrix_o_70_V;
		delete [] wrapc_stream_size_out_matrix_o_70_V;
		// release memory allocation: "matrix_o_71_V"
		delete [] tvout_matrix_o_71_V;
		delete [] tvin_matrix_o_71_V;
		delete [] wrapc_stream_size_out_matrix_o_71_V;
		// release memory allocation: "matrix_o_72_V"
		delete [] tvout_matrix_o_72_V;
		delete [] tvin_matrix_o_72_V;
		delete [] wrapc_stream_size_out_matrix_o_72_V;
		// release memory allocation: "matrix_o_73_V"
		delete [] tvout_matrix_o_73_V;
		delete [] tvin_matrix_o_73_V;
		delete [] wrapc_stream_size_out_matrix_o_73_V;
		// release memory allocation: "matrix_o_74_V"
		delete [] tvout_matrix_o_74_V;
		delete [] tvin_matrix_o_74_V;
		delete [] wrapc_stream_size_out_matrix_o_74_V;
		// release memory allocation: "matrix_o_75_V"
		delete [] tvout_matrix_o_75_V;
		delete [] tvin_matrix_o_75_V;
		delete [] wrapc_stream_size_out_matrix_o_75_V;
		// release memory allocation: "matrix_o_76_V"
		delete [] tvout_matrix_o_76_V;
		delete [] tvin_matrix_o_76_V;
		delete [] wrapc_stream_size_out_matrix_o_76_V;
		// release memory allocation: "matrix_o_77_V"
		delete [] tvout_matrix_o_77_V;
		delete [] tvin_matrix_o_77_V;
		delete [] wrapc_stream_size_out_matrix_o_77_V;
		// release memory allocation: "matrix_o_78_V"
		delete [] tvout_matrix_o_78_V;
		delete [] tvin_matrix_o_78_V;
		delete [] wrapc_stream_size_out_matrix_o_78_V;
		// release memory allocation: "matrix_o_79_V"
		delete [] tvout_matrix_o_79_V;
		delete [] tvin_matrix_o_79_V;
		delete [] wrapc_stream_size_out_matrix_o_79_V;
		// release memory allocation: "matrix_o_80_V"
		delete [] tvout_matrix_o_80_V;
		delete [] tvin_matrix_o_80_V;
		delete [] wrapc_stream_size_out_matrix_o_80_V;
		// release memory allocation: "matrix_o_81_V"
		delete [] tvout_matrix_o_81_V;
		delete [] tvin_matrix_o_81_V;
		delete [] wrapc_stream_size_out_matrix_o_81_V;
		// release memory allocation: "matrix_o_82_V"
		delete [] tvout_matrix_o_82_V;
		delete [] tvin_matrix_o_82_V;
		delete [] wrapc_stream_size_out_matrix_o_82_V;
		// release memory allocation: "matrix_o_83_V"
		delete [] tvout_matrix_o_83_V;
		delete [] tvin_matrix_o_83_V;
		delete [] wrapc_stream_size_out_matrix_o_83_V;
		// release memory allocation: "matrix_o_84_V"
		delete [] tvout_matrix_o_84_V;
		delete [] tvin_matrix_o_84_V;
		delete [] wrapc_stream_size_out_matrix_o_84_V;
		// release memory allocation: "matrix_o_85_V"
		delete [] tvout_matrix_o_85_V;
		delete [] tvin_matrix_o_85_V;
		delete [] wrapc_stream_size_out_matrix_o_85_V;
		// release memory allocation: "matrix_o_86_V"
		delete [] tvout_matrix_o_86_V;
		delete [] tvin_matrix_o_86_V;
		delete [] wrapc_stream_size_out_matrix_o_86_V;
		// release memory allocation: "matrix_o_87_V"
		delete [] tvout_matrix_o_87_V;
		delete [] tvin_matrix_o_87_V;
		delete [] wrapc_stream_size_out_matrix_o_87_V;
		// release memory allocation: "matrix_o_88_V"
		delete [] tvout_matrix_o_88_V;
		delete [] tvin_matrix_o_88_V;
		delete [] wrapc_stream_size_out_matrix_o_88_V;
		// release memory allocation: "matrix_o_89_V"
		delete [] tvout_matrix_o_89_V;
		delete [] tvin_matrix_o_89_V;
		delete [] wrapc_stream_size_out_matrix_o_89_V;
		// release memory allocation: "matrix_o_90_V"
		delete [] tvout_matrix_o_90_V;
		delete [] tvin_matrix_o_90_V;
		delete [] wrapc_stream_size_out_matrix_o_90_V;
		// release memory allocation: "matrix_o_91_V"
		delete [] tvout_matrix_o_91_V;
		delete [] tvin_matrix_o_91_V;
		delete [] wrapc_stream_size_out_matrix_o_91_V;
		// release memory allocation: "matrix_o_92_V"
		delete [] tvout_matrix_o_92_V;
		delete [] tvin_matrix_o_92_V;
		delete [] wrapc_stream_size_out_matrix_o_92_V;
		// release memory allocation: "matrix_o_93_V"
		delete [] tvout_matrix_o_93_V;
		delete [] tvin_matrix_o_93_V;
		delete [] wrapc_stream_size_out_matrix_o_93_V;
		// release memory allocation: "matrix_o_94_V"
		delete [] tvout_matrix_o_94_V;
		delete [] tvin_matrix_o_94_V;
		delete [] wrapc_stream_size_out_matrix_o_94_V;
		// release memory allocation: "matrix_o_95_V"
		delete [] tvout_matrix_o_95_V;
		delete [] tvin_matrix_o_95_V;
		delete [] wrapc_stream_size_out_matrix_o_95_V;
		// release memory allocation: "matrix_o_96_V"
		delete [] tvout_matrix_o_96_V;
		delete [] tvin_matrix_o_96_V;
		delete [] wrapc_stream_size_out_matrix_o_96_V;
		// release memory allocation: "matrix_o_97_V"
		delete [] tvout_matrix_o_97_V;
		delete [] tvin_matrix_o_97_V;
		delete [] wrapc_stream_size_out_matrix_o_97_V;
		// release memory allocation: "matrix_o_98_V"
		delete [] tvout_matrix_o_98_V;
		delete [] tvin_matrix_o_98_V;
		delete [] wrapc_stream_size_out_matrix_o_98_V;
		// release memory allocation: "matrix_o_99_V"
		delete [] tvout_matrix_o_99_V;
		delete [] tvin_matrix_o_99_V;
		delete [] wrapc_stream_size_out_matrix_o_99_V;
		// release memory allocation: "matrix_o_100_V"
		delete [] tvout_matrix_o_100_V;
		delete [] tvin_matrix_o_100_V;
		delete [] wrapc_stream_size_out_matrix_o_100_V;
		// release memory allocation: "matrix_o_101_V"
		delete [] tvout_matrix_o_101_V;
		delete [] tvin_matrix_o_101_V;
		delete [] wrapc_stream_size_out_matrix_o_101_V;
		// release memory allocation: "matrix_o_102_V"
		delete [] tvout_matrix_o_102_V;
		delete [] tvin_matrix_o_102_V;
		delete [] wrapc_stream_size_out_matrix_o_102_V;
		// release memory allocation: "matrix_o_103_V"
		delete [] tvout_matrix_o_103_V;
		delete [] tvin_matrix_o_103_V;
		delete [] wrapc_stream_size_out_matrix_o_103_V;
		// release memory allocation: "matrix_o_104_V"
		delete [] tvout_matrix_o_104_V;
		delete [] tvin_matrix_o_104_V;
		delete [] wrapc_stream_size_out_matrix_o_104_V;
		// release memory allocation: "matrix_o_105_V"
		delete [] tvout_matrix_o_105_V;
		delete [] tvin_matrix_o_105_V;
		delete [] wrapc_stream_size_out_matrix_o_105_V;
		// release memory allocation: "matrix_o_106_V"
		delete [] tvout_matrix_o_106_V;
		delete [] tvin_matrix_o_106_V;
		delete [] wrapc_stream_size_out_matrix_o_106_V;
		// release memory allocation: "matrix_o_107_V"
		delete [] tvout_matrix_o_107_V;
		delete [] tvin_matrix_o_107_V;
		delete [] wrapc_stream_size_out_matrix_o_107_V;
		// release memory allocation: "matrix_o_108_V"
		delete [] tvout_matrix_o_108_V;
		delete [] tvin_matrix_o_108_V;
		delete [] wrapc_stream_size_out_matrix_o_108_V;
		// release memory allocation: "matrix_o_109_V"
		delete [] tvout_matrix_o_109_V;
		delete [] tvin_matrix_o_109_V;
		delete [] wrapc_stream_size_out_matrix_o_109_V;
		// release memory allocation: "matrix_o_110_V"
		delete [] tvout_matrix_o_110_V;
		delete [] tvin_matrix_o_110_V;
		delete [] wrapc_stream_size_out_matrix_o_110_V;
		// release memory allocation: "matrix_o_111_V"
		delete [] tvout_matrix_o_111_V;
		delete [] tvin_matrix_o_111_V;
		delete [] wrapc_stream_size_out_matrix_o_111_V;
		// release memory allocation: "matrix_o_112_V"
		delete [] tvout_matrix_o_112_V;
		delete [] tvin_matrix_o_112_V;
		delete [] wrapc_stream_size_out_matrix_o_112_V;
		// release memory allocation: "matrix_o_113_V"
		delete [] tvout_matrix_o_113_V;
		delete [] tvin_matrix_o_113_V;
		delete [] wrapc_stream_size_out_matrix_o_113_V;
		// release memory allocation: "matrix_o_114_V"
		delete [] tvout_matrix_o_114_V;
		delete [] tvin_matrix_o_114_V;
		delete [] wrapc_stream_size_out_matrix_o_114_V;
		// release memory allocation: "matrix_o_115_V"
		delete [] tvout_matrix_o_115_V;
		delete [] tvin_matrix_o_115_V;
		delete [] wrapc_stream_size_out_matrix_o_115_V;
		// release memory allocation: "matrix_o_116_V"
		delete [] tvout_matrix_o_116_V;
		delete [] tvin_matrix_o_116_V;
		delete [] wrapc_stream_size_out_matrix_o_116_V;
		// release memory allocation: "matrix_o_117_V"
		delete [] tvout_matrix_o_117_V;
		delete [] tvin_matrix_o_117_V;
		delete [] wrapc_stream_size_out_matrix_o_117_V;
		// release memory allocation: "matrix_o_118_V"
		delete [] tvout_matrix_o_118_V;
		delete [] tvin_matrix_o_118_V;
		delete [] wrapc_stream_size_out_matrix_o_118_V;
		// release memory allocation: "matrix_o_119_V"
		delete [] tvout_matrix_o_119_V;
		delete [] tvin_matrix_o_119_V;
		delete [] wrapc_stream_size_out_matrix_o_119_V;
		// release memory allocation: "matrix_o_120_V"
		delete [] tvout_matrix_o_120_V;
		delete [] tvin_matrix_o_120_V;
		delete [] wrapc_stream_size_out_matrix_o_120_V;
		// release memory allocation: "matrix_o_121_V"
		delete [] tvout_matrix_o_121_V;
		delete [] tvin_matrix_o_121_V;
		delete [] wrapc_stream_size_out_matrix_o_121_V;
		// release memory allocation: "matrix_o_122_V"
		delete [] tvout_matrix_o_122_V;
		delete [] tvin_matrix_o_122_V;
		delete [] wrapc_stream_size_out_matrix_o_122_V;
		// release memory allocation: "matrix_o_123_V"
		delete [] tvout_matrix_o_123_V;
		delete [] tvin_matrix_o_123_V;
		delete [] wrapc_stream_size_out_matrix_o_123_V;
		// release memory allocation: "matrix_o_124_V"
		delete [] tvout_matrix_o_124_V;
		delete [] tvin_matrix_o_124_V;
		delete [] wrapc_stream_size_out_matrix_o_124_V;
		// release memory allocation: "matrix_o_125_V"
		delete [] tvout_matrix_o_125_V;
		delete [] tvin_matrix_o_125_V;
		delete [] wrapc_stream_size_out_matrix_o_125_V;
		// release memory allocation: "matrix_o_126_V"
		delete [] tvout_matrix_o_126_V;
		delete [] tvin_matrix_o_126_V;
		delete [] wrapc_stream_size_out_matrix_o_126_V;
		// release memory allocation: "matrix_o_127_V"
		delete [] tvout_matrix_o_127_V;
		delete [] tvin_matrix_o_127_V;
		delete [] wrapc_stream_size_out_matrix_o_127_V;

		AESL_transaction++;

		tcl_file.set_num(AESL_transaction , &tcl_file.trans_num);
	}
}

